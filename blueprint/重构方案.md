# 新架构重构方案

## 一、重构原则

1. **渐进式重构**：创建新目录和文件，不修改旧代码
2. **新旧共存**：新架构和旧架构可以同时存在，逐步迁移
3. **向后兼容**：保持现有功能正常运行
4. **依赖倒置**：所有层都依赖接口，不依赖具体实现

## 二、新架构目录结构

```
web/src/architecture/          # 新架构根目录
├── presentation/              # Presentation Layer (UI 组件层)
│   ├── views/                # 视图组件
│   │   ├── WorkspaceView.vue
│   │   ├── FormView.vue
│   │   └── TableView.vue
│   ├── widgets/               # Widget 组件（从 core/widgets-v2 迁移）
│   │   ├── InputWidget.vue
│   │   ├── SelectWidget.vue
│   │   └── ...
│   └── components/            # 通用 UI 组件
│       └── ...
│
├── application/               # Application Layer (应用层 - 业务流程编排)
│   ├── services/              # Application Services
│   │   ├── WorkspaceApplicationService.ts
│   │   ├── FormApplicationService.ts
│   │   └── TableApplicationService.ts
│   └── README.md
│
├── domain/                    # Domain Layer (领域层 - 业务逻辑)
│   ├── services/             # Domain Services
│   │   ├── WorkspaceDomainService.ts
│   │   ├── FormDomainService.ts
│   │   └── TableDomainService.ts
│   ├── interfaces/           # 接口定义（依赖倒置）
│   │   ├── IEventBus.ts
│   │   ├── IStateManager.ts
│   │   ├── IApiClient.ts
│   │   ├── IFunctionLoader.ts
│   │   └── ICacheManager.ts
│   ├── types/                # 领域类型定义
│   │   ├── FieldConfig.ts
│   │   ├── FieldValue.ts
│   │   └── FunctionDetail.ts
│   └── README.md
│
└── infrastructure/            # Infrastructure Layer (基础设施层 - 技术实现)
    ├── eventBus/             # 事件总线实现
    │   ├── EventBusImpl.ts
    │   └── index.ts
    ├── stateManager/         # 状态管理实现
    │   ├── StateManagerImpl.ts
    │   ├── WorkspaceStateManager.ts
    │   ├── FormStateManager.ts
    │   └── index.ts
    ├── apiClient/            # API 客户端实现
    │   ├── ApiClientImpl.ts
    │   └── index.ts
    ├── functionLoader/       # 函数加载器实现
    │   ├── FunctionLoaderImpl.ts
    │   └── index.ts
    ├── cacheManager/         # 缓存管理实现
    │   ├── CacheManagerImpl.ts
    │   └── index.ts
    ├── widgetRegistry/       # Widget 注册表（从 core/factories-v2 迁移）
    │   ├── WidgetComponentFactory.ts
    │   └── index.ts
    └── README.md
```

## 三、目录说明

### 3.1 Presentation Layer (UI 组件层)

**路径**：`web/src/architecture/presentation/`

**职责**：
- 纯 UI 展示，不包含业务逻辑
- 通过事件与 Application Layer 通信
- 从 StateManager 获取状态并渲染

**目录结构**：
- `views/`：页面级视图组件（WorkspaceView、FormView、TableView）
- `widgets/`：Widget 组件（从 `core/widgets-v2/components/` 迁移）
- `components/`：通用 UI 组件（可选）

**特点**：
- 组件代码量小（< 300 行/个）
- 只负责展示和用户交互
- 不直接调用 API，通过事件通信

### 3.2 Application Layer (应用层)

**路径**：`web/src/architecture/application/`

**职责**：
- 业务流程编排
- 监听事件，调用 Domain Services
- 协调多个 Domain Services 完成业务场景

**目录结构**：
- `services/`：Application Services
  - `WorkspaceApplicationService.ts`：工作空间业务流程
  - `FormApplicationService.ts`：表单业务流程
  - `TableApplicationService.ts`：表格业务流程

**特点**：
- 不包含业务逻辑，只负责编排
- 通过事件监听和触发实现流程控制
- 依赖 Domain Layer 接口

### 3.3 Domain Layer (领域层)

**路径**：`web/src/architecture/domain/`

**职责**：
- 核心业务逻辑
- 定义业务规则和领域模型
- 定义接口（依赖倒置）

**目录结构**：
- `services/`：Domain Services
  - `WorkspaceDomainService.ts`：工作空间业务逻辑
  - `FormDomainService.ts`：表单业务逻辑
  - `TableDomainService.ts`：表格业务逻辑
- `interfaces/`：接口定义
  - `IEventBus.ts`：事件总线接口
  - `IStateManager.ts`：状态管理接口
  - `IApiClient.ts`：API 客户端接口
  - `IFunctionLoader.ts`：函数加载器接口
  - `ICacheManager.ts`：缓存管理接口
- `types/`：领域类型定义
  - `FieldConfig.ts`：字段配置类型
  - `FieldValue.ts`：字段值类型
  - `FunctionDetail.ts`：函数详情类型

**特点**：
- 不依赖 Infrastructure Layer 的具体实现
- 只依赖接口，实现依赖倒置
- 包含核心业务逻辑

### 3.4 Infrastructure Layer (基础设施层)

**路径**：`web/src/architecture/infrastructure/`

**职责**：
- 技术实现（Pinia、EventBus、API 调用等）
- 实现 Domain Layer 定义的接口
- 提供技术能力给上层使用

**目录结构**：
- `eventBus/`：事件总线实现
  - `EventBusImpl.ts`：内存事件总线实现
- `stateManager/`：状态管理实现
  - `StateManagerImpl.ts`：基于 Pinia 的状态管理实现
  - `WorkspaceStateManager.ts`：工作空间状态管理
  - `FormStateManager.ts`：表单状态管理
- `apiClient/`：API 客户端实现
  - `ApiClientImpl.ts`：基于 axios 的 API 客户端实现
- `functionLoader/`：函数加载器实现
  - `FunctionLoaderImpl.ts`：函数加载器实现（带防抖和去重）
- `cacheManager/`：缓存管理实现
  - `CacheManagerImpl.ts`：内存缓存实现
- `widgetRegistry/`：Widget 注册表
  - `WidgetComponentFactory.ts`：Widget 组件工厂（从 `core/factories-v2` 迁移）

**特点**：
- 实现 Domain Layer 定义的接口
- 可以轻松替换实现（例如：从内存缓存切换到 Redis 缓存）
- 提供技术能力，不包含业务逻辑

## 四、迁移计划

### Phase 1：基础设施层（当前阶段）

**目标**：创建基础设施层，实现核心接口

**任务**：
1. ✅ 创建目录结构
2. ⬜ 实现 `IEventBus` 接口（EventBusImpl）
3. ⬜ 实现 `IStateManager` 接口（StateManagerImpl）
4. ⬜ 实现 `IApiClient` 接口（ApiClientImpl）
5. ⬜ 实现 `IFunctionLoader` 接口（FunctionLoaderImpl，带防抖和去重）
6. ⬜ 实现 `ICacheManager` 接口（CacheManagerImpl）
7. ⬜ 迁移 WidgetComponentFactory 到 infrastructure/widgetRegistry

**预计时间**：2-3 天

### Phase 2：领域层

**目标**：创建领域层，定义业务逻辑和接口

**任务**：
1. ⬜ 创建 Domain Services（WorkspaceDomainService、FormDomainService、TableDomainService）
2. ⬜ 迁移业务逻辑到 Domain Services
3. ⬜ 确保 Domain Services 依赖接口，不依赖具体实现

**预计时间**：3-4 天

### Phase 3：应用层

**目标**：创建应用层，编排业务流程

**任务**：
1. ⬜ 创建 Application Services（WorkspaceApplicationService、FormApplicationService、TableApplicationService）
2. ⬜ 实现事件监听和业务流程编排
3. ⬜ 连接 Presentation Layer 和 Domain Layer

**预计时间**：2-3 天

### Phase 4：展示层

**目标**：创建展示层，迁移 UI 组件

**任务**：
1. ⬜ 创建 WorkspaceView、FormView、TableView
2. ⬜ 迁移 Widget 组件到 presentation/widgets
3. ⬜ 实现事件通信和状态管理

**预计时间**：3-4 天

### Phase 5：集成和测试

**目标**：集成新架构，测试功能

**任务**：
1. ⬜ 集成新架构到现有页面
2. ⬜ 功能测试
3. ⬜ 性能测试
4. ⬜ 修复问题

**预计时间**：2-3 天

### Phase 6：逐步迁移

**目标**：逐步迁移旧代码到新架构

**任务**：
1. ⬜ 迁移一个功能模块到新架构
2. ⬜ 测试验证
3. ⬜ 继续迁移其他模块
4. ⬜ 最终移除旧代码

**预计时间**：根据模块数量决定

## 五、新旧代码共存策略

### 5.1 目录隔离

- **新架构**：`web/src/architecture/`
- **旧代码**：`web/src/core/`、`web/src/views/` 等

### 5.2 命名规范

- **新架构文件**：使用新命名（如 `WorkspaceView.vue`）
- **旧代码文件**：保持原命名（如 `FormRenderer.vue`）

### 5.3 逐步迁移

1. 先在新架构中实现新功能
2. 测试验证新架构功能
3. 逐步迁移旧功能到新架构
4. 最终移除旧代码

### 5.4 依赖管理

- **新架构**：不依赖旧代码
- **旧代码**：可以继续使用，不受影响
- **共享资源**：类型定义、工具函数等可以共享

## 六、关键设计决策

### 6.1 事件驱动

- 使用事件总线实现组件间通信
- 解耦组件，便于测试和扩展

### 6.2 依赖倒置

- 所有层都依赖接口，不依赖具体实现
- 可以轻松替换实现（例如：从内存事件总线切换到 Redis 事件总线）

### 6.3 单一数据源

- 所有状态都通过 StateManager 管理
- 组件从 StateManager 获取状态，不维护内部状态

### 6.4 防抖和去重

- FunctionLoader 实现防抖和去重，避免重复调用
- 解决当前架构的重复调用问题

## 七、注意事项

1. **不要修改旧代码**：保持旧代码不变，确保现有功能正常运行
2. **新架构独立**：新架构应该可以独立运行，不依赖旧代码
3. **接口优先**：先定义接口，再实现具体逻辑
4. **测试驱动**：每个阶段都要进行测试，确保功能正常
5. **文档同步**：及时更新文档，记录设计决策和变更

## 八、下一步行动

1. ✅ 创建重构方案文档（当前）
2. ⬜ 创建新架构目录结构
3. ⬜ 开始 Phase 1：实现基础设施层

