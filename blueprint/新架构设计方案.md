# 新架构设计方案

## 一、架构设计原则

### 1.1 核心原则

1. **依赖倒置原则（DIP）**：高层模块不依赖低层模块，两者都依赖抽象
2. **单一职责原则（SRP）**：每个模块只负责一个职责
3. **开闭原则（OCP）**：对扩展开放，对修改关闭
4. **单一数据源（SSOT）**：每个数据只有一个来源
5. **事件驱动（Event-Driven）**：使用事件而不是 watch 处理状态变化

### 1.2 设计目标

- ✅ 解决重复调用问题
- ✅ 解决时序问题
- ✅ 解决响应式更新复杂问题
- ✅ 解决状态管理混乱问题
- ✅ 解决性能问题
- ✅ 解决代码重复问题
- ✅ 解决组件耦合问题
- ✅ 解决缺乏抽象层问题

---

## 二、分层架构设计

```
┌─────────────────────────────────────────────────────────┐
│                    Presentation Layer                     │
│                  (UI 组件层 - 纯展示)                      │
│  - WorkspaceView.vue (< 200 行)                          │
│  - FormView.vue (< 150 行)                                │
│  - TableView.vue (< 300 行)                               │
│  - Widget Components (< 300 行/个，Vue 文件)              │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑ (事件通信)
┌─────────────────────────────────────────────────────────┐
│                  Application Layer                        │
│              (应用层 - 业务流程编排)                       │
│  - WorkspaceApplicationService.ts                        │
│  - FormApplicationService.ts                             │
│  - TableApplicationService.ts                            │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑ (接口调用)
┌─────────────────────────────────────────────────────────┐
│                   Domain Layer                            │
│              (领域层 - 业务逻辑)                           │
│  - WorkspaceDomainService.ts                             │
│  - FormDomainService.ts                                  │
│  - TableDomainService.ts                                 │
│  - WidgetDomainService.ts                                │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑ (接口依赖)
┌─────────────────────────────────────────────────────────┐
│                  Infrastructure Layer                     │
│            (基础设施层 - 技术实现)                         │
│  - StateManager (Pinia Stores)                           │
│  - EventBus (事件总线)                                    │
│  - ApiClient (API 客户端)                                │
│  - CacheManager (缓存管理)                                │
└─────────────────────────────────────────────────────────┘
```

---

## 三、核心抽象接口（依赖倒置）

### 3.1 状态管理接口

```typescript
// domain/interfaces/IStateManager.ts
export interface IStateManager<T> {
  getState(): T
  setState(state: T): void
  subscribe(callback: (state: T) => void): () => void
  clear(): void
}
```

### 3.2 事件总线接口

```typescript
// domain/interfaces/IEventBus.ts
export interface IEventBus {
  emit(event: string, payload?: any): void
  on(event: string, handler: (payload?: any) => void): () => void
  off(event: string, handler: (payload?: any) => void): void
  once(event: string, handler: (payload?: any) => void): void
}

// 事件类型定义（使用 camelCase，更易读）
// 命名规范：模块名:动作名，例如 workspace:node-clicked
export enum WorkspaceEvent {
  nodeClicked = 'workspace:node-clicked',           // 节点点击
  appSwitched = 'workspace:app-switched',           // 应用切换
  serviceTreeLoaded = 'workspace:service-tree-loaded', // 服务树加载完成
  functionLoaded = 'workspace:function-loaded',     // 函数加载完成
  tabSwitched = 'workspace:tab-switched'            // 标签切换
}

export enum FormEvent {
  initialized = 'form:initialized',                 // 表单初始化完成
  fieldValueUpdated = 'form:field-value-updated',   // 字段值更新
  validated = 'form:validated',                     // 表单验证完成
  submitted = 'form:submitted',                     // 表单提交
  responseReceived = 'form:response-received'       // 响应数据接收
}

export enum TableEvent {
  dataLoaded = 'table:data-loaded',                 // 表格数据加载完成
  searchChanged = 'table:search-changed',           // 搜索条件变化
  sortChanged = 'table:sort-changed',              // 排序变化
  pageChanged = 'table:page-changed',              // 分页变化
  rowAdded = 'table:row-added',                     // 行新增
  rowUpdated = 'table:row-updated',                // 行更新
  rowDeleted = 'table:row-deleted'                 // 行删除
}
```

### 3.3 API 客户端接口

```typescript
// domain/interfaces/IApiClient.ts
export interface IApiClient {
  get<T>(url: string, params?: any): Promise<T>
  post<T>(url: string, data?: any): Promise<T>
  put<T>(url: string, data?: any): Promise<T>
  delete<T>(url: string): Promise<T>
}
```

### 3.4 函数加载器接口

```typescript
// domain/interfaces/IFunctionLoader.ts
export interface IFunctionLoader {
  loadById(id: number): Promise<FunctionDetail>
  loadByPath(path: string): Promise<FunctionDetail>
  getCached(id?: number, path?: string): FunctionDetail | null
  clearCache(): void
}
```

### 3.5 Widget 渲染接口

```typescript
// domain/interfaces/IWidgetRenderer.ts
export interface IWidgetRenderer {
  render(props: WidgetRenderProps): VNode
  validate(value: FieldValue, field: FieldConfig): ValidationResult[]
  getDefaultValue(field: FieldConfig): FieldValue
}
```

---

## 四、完整调用链路示例

### 4.1 场景：用户点击服务目录节点

```
用户点击节点
    ↓
┌─────────────────────────────────────────────────────────┐
│ Presentation Layer: WorkspaceView.vue                    │
│  - 纯 UI 组件，只负责展示和用户交互                        │
│  - 触发事件：WorkspaceEvent.NODE_CLICKED                  │
└─────────────────────────────────────────────────────────┘
    ↓ (emit event)
┌─────────────────────────────────────────────────────────┐
│ Application Layer: WorkspaceApplicationService           │
│  - 业务流程编排：处理节点点击的业务流程                     │
│  - 调用 Domain Service                                   │
│  - 处理事件：WorkspaceEvent.NODE_CLICKED                 │
└─────────────────────────────────────────────────────────┘
    ↓ (call domain service)
┌─────────────────────────────────────────────────────────┐
│ Domain Layer: WorkspaceDomainService                     │
│  - 业务逻辑：判断是否需要加载函数详情                       │
│  - 调用 Infrastructure：IFunctionLoader                  │
│  - 更新状态：IStateManager                               │
│  - 触发事件：WorkspaceEvent.FUNCTION_LOADED              │
└─────────────────────────────────────────────────────────┘
    ↓ (call infrastructure)
┌─────────────────────────────────────────────────────────┐
│ Infrastructure Layer: FunctionLoaderImpl                 │
│  - 技术实现：调用 API、缓存管理                           │
│  - 实现接口：IFunctionLoader                             │
│  - 防抖和去重逻辑                                         │
│  - 返回结果给 Domain Service                             │
└─────────────────────────────────────────────────────────┘
    ↓ (return result)
┌─────────────────────────────────────────────────────────┐
│ Domain Layer: WorkspaceDomainService                     │
│  - 更新状态：IStateManager.setState()                    │
│  - 触发事件：IEventBus.emit(FUNCTION_LOADED)             │
└─────────────────────────────────────────────────────────┘
    ↓ (emit event)
┌─────────────────────────────────────────────────────────┐
│ Application Layer: FormApplicationService                │
│  - 监听事件：FUNCTION_LOADED                             │
│  - 初始化表单：调用 FormDomainService                    │
└─────────────────────────────────────────────────────────┘
    ↓ (call domain service)
┌─────────────────────────────────────────────────────────┐
│ Domain Layer: FormDomainService                          │
│  - 初始化表单数据：调用 IStateManager                     │
│  - 触发事件：FORM_INITIALIZED                            │
└─────────────────────────────────────────────────────────┘
    ↓ (emit event)
┌─────────────────────────────────────────────────────────┐
│ Presentation Layer: FormView.vue                         │
│  - 监听事件：FORM_INITIALIZED                            │
│  - 从 IStateManager 获取状态并渲染                        │
└─────────────────────────────────────────────────────────┘
```

### 4.2 关键点说明

1. **依赖倒置**：
   - Presentation Layer 依赖 `IEventBus` 接口，不依赖具体实现
   - Application Layer 依赖 Domain Layer 接口，不依赖具体实现
   - Domain Layer 依赖 Infrastructure Layer 接口，不依赖具体实现

2. **事件驱动**：
   - 使用事件通信，而不是直接调用
   - 解耦组件，便于测试和扩展

3. **单一数据源**：
   - 所有状态都通过 `IStateManager` 管理
   - 组件从 `IStateManager` 获取状态，不维护内部状态

---

## 五、具体实现示例

### 5.1 Infrastructure Layer 实现

#### 5.1.1 EventBus 实现

```typescript
// infrastructure/eventBus/EventBusImpl.ts
import type { IEventBus } from '@/domain/interfaces/IEventBus'

export class EventBusImpl implements IEventBus {
  private handlers = new Map<string, Set<Function>>()

  emit(event: string, payload?: any): void {
    const handlers = this.handlers.get(event)
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(payload)
        } catch (error) {
          console.error(`[EventBus] Error in handler for ${event}:`, error)
        }
      })
    }
  }

  on(event: string, handler: (payload?: any) => void): () => void {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Set())
    }
    this.handlers.get(event)!.add(handler)

    // 返回取消订阅函数
    return () => {
      this.off(event, handler)
    }
  }

  off(event: string, handler: (payload?: any) => void): void {
    const handlers = this.handlers.get(event)
    if (handlers) {
      handlers.delete(handler)
    }
  }

  once(event: string, handler: (payload?: any) => void): void {
    const onceHandler = (payload?: any) => {
      handler(payload)
      this.off(event, onceHandler)
    }
    this.on(event, onceHandler)
  }
}

// 单例
export const eventBus = new EventBusImpl()
```

#### 5.1.2 FunctionLoader 实现

```typescript
// infrastructure/functionLoader/FunctionLoaderImpl.ts
import type { IFunctionLoader } from '@/domain/interfaces/IFunctionLoader'
import type { IApiClient } from '@/domain/interfaces/IApiClient'
import type { FunctionDetail } from '@/types'

export class FunctionLoaderImpl implements IFunctionLoader {
  private cache = new Map<string, FunctionDetail>()
  private loadingPromises = new Map<string, Promise<FunctionDetail>>()
  private debounceTimers = new Map<string, NodeJS.Timeout>()

  constructor(private apiClient: IApiClient) {}

  async loadById(id: number): Promise<FunctionDetail> {
    const key = `id:${id}`
    return this.load(key, () => this.apiClient.get(`/api/v1/function/get`, { function_id: id }))
  }

  async loadByPath(path: string): Promise<FunctionDetail> {
    const key = `path:${path}`
    return this.load(key, () => this.apiClient.get(`/api/v1/function/by-path`, { path }))
  }

  private async load(key: string, loader: () => Promise<FunctionDetail>): Promise<FunctionDetail> {
    // 如果正在加载，返回同一个 Promise
    if (this.loadingPromises.has(key)) {
      return this.loadingPromises.get(key)!
    }

    // 如果已缓存，直接返回
    const cached = this.cache.get(key)
    if (cached) {
      return cached
    }

    // 防抖：如果短时间内多次调用，只执行最后一次
    return new Promise((resolve, reject) => {
      if (this.debounceTimers.has(key)) {
        clearTimeout(this.debounceTimers.get(key)!)
      }

      this.debounceTimers.set(key, setTimeout(async () => {
        try {
          const promise = loader()
          this.loadingPromises.set(key, promise)
          const result = await promise
          this.cache.set(key, result)
          this.loadingPromises.delete(key)
          resolve(result)
        } catch (error) {
          this.loadingPromises.delete(key)
          reject(error)
        }
      }, 100)) // 100ms 防抖
    })
  }

  getCached(id?: number, path?: string): FunctionDetail | null {
    if (id) {
      return this.cache.get(`id:${id}`) || null
    }
    if (path) {
      return this.cache.get(`path:${path}`) || null
    }
    return null
  }

  clearCache(): void {
    this.cache.clear()
  }
}
```

#### 5.1.3 StateManager 实现（基于 Pinia）

```typescript
// infrastructure/stateManager/StateManagerImpl.ts
import { defineStore } from 'pinia'
import type { IStateManager } from '@/domain/interfaces/IStateManager'

export interface WorkspaceState {
  currentApp: App | null
  serviceTree: ServiceTree[]
  currentFunction: ServiceTree | null
  functionDetails: Map<string, FunctionDetail>
  tabs: WorkspaceTab[]
  activeTabId: string | null
}

export const useWorkspaceStore = defineStore('workspace', {
  state: (): WorkspaceState => ({
    currentApp: null,
    serviceTree: [],
    currentFunction: null,
    functionDetails: new Map(),
    tabs: [],
    activeTabId: null
  }),

  getters: {
    currentFunctionDetail: (state): FunctionDetail | null => {
      if (!state.currentFunction) return null
      const key = state.currentFunction.ref_id 
        ? `id:${state.currentFunction.ref_id}` 
        : `path:${state.currentFunction.full_code_path}`
      return state.functionDetails.get(key) || null
    }
  },

  actions: {
    setCurrentApp(app: App) {
      this.currentApp = app
    },

    setServiceTree(tree: ServiceTree[]) {
      this.serviceTree = tree
    },

    setCurrentFunction(functionNode: ServiceTree) {
      this.currentFunction = functionNode
    },

    setFunctionDetail(key: string, detail: FunctionDetail) {
      this.functionDetails.set(key, detail)
    },

    addTab(tab: WorkspaceTab) {
      this.tabs.push(tab)
    },

    setActiveTab(tabId: string) {
      this.activeTabId = tabId
    }
  }
})

// 适配器：将 Pinia Store 适配为 IStateManager 接口
export class WorkspaceStateManager implements IStateManager<WorkspaceState> {
  constructor(private store: ReturnType<typeof useWorkspaceStore>) {}

  getState(): WorkspaceState {
    return this.store.$state
  }

  setState(state: Partial<WorkspaceState>): void {
    Object.assign(this.store.$state, state)
  }

  subscribe(callback: (state: WorkspaceState) => void): () => void {
    // 使用 Pinia 的 $subscribe
    return this.store.$subscribe((mutation, state) => {
      callback(state as WorkspaceState)
    })
  }

  clear(): void {
    this.store.$reset()
  }
}
```

### 5.2 Domain Layer 实现

#### 5.2.1 WorkspaceDomainService

```typescript
// domain/services/WorkspaceDomainService.ts
import type { IFunctionLoader } from '../interfaces/IFunctionLoader'
import type { IStateManager } from '../interfaces/IStateManager'
import type { IEventBus } from '../interfaces/IEventBus'
import type { WorkspaceState, ServiceTree, FunctionDetail } from '@/types'

export class WorkspaceDomainService {
  constructor(
    private functionLoader: IFunctionLoader,
    private stateManager: IStateManager<WorkspaceState>,
    private eventBus: IEventBus
  ) {}

  /**
   * 加载函数详情（统一入口，防抖和去重）
   */
  async loadFunction(node: ServiceTree): Promise<FunctionDetail> {
    // 检查是否已加载
    const state = this.stateManager.getState()
    const key = node.ref_id 
      ? `id:${node.ref_id}` 
      : `path:${node.full_code_path}`
    
    const cached = this.functionLoader.getCached(node.ref_id, node.full_code_path)
    if (cached) {
      // 更新状态
      this.stateManager.setState({
        currentFunction: node,
        functionDetails: new Map(state.functionDetails).set(key, cached)
      })
      
      // 触发事件
      this.eventBus.emit(WorkspaceEvent.functionLoaded, { node, detail: cached })
      return cached
    }

    // 加载函数详情
    let detail: FunctionDetail
    if (node.ref_id && node.ref_id > 0) {
      detail = await this.functionLoader.loadById(node.ref_id)
    } else if (node.full_code_path) {
      detail = await this.functionLoader.loadByPath(node.full_code_path)
    } else {
      throw new Error('节点没有 ref_id 和 full_code_path，无法加载函数详情')
    }

    // 更新状态
    this.stateManager.setState({
      currentFunction: node,
      functionDetails: new Map(state.functionDetails).set(key, detail)
    })

      // 触发事件
      this.eventBus.emit(WorkspaceEvent.functionLoaded, { node, detail })

    return detail
  }

  /**
   * 切换应用
   */
  async switchApp(app: App): Promise<void> {
    const state = this.stateManager.getState()
    
    // 更新状态
    this.stateManager.setState({
      currentApp: app,
      currentFunction: null,
      serviceTree: [] // 清空服务树，等待重新加载
    })

    // 触发事件
    this.eventBus.emit(WorkspaceEvent.appSwitched, { app })
  }

  /**
   * 加载服务目录树
   */
  async loadServiceTree(app: App): Promise<ServiceTree[]> {
    // 这里调用 API（通过 Infrastructure Layer）
    // 为了简化，假设有 serviceTreeLoader
    // const tree = await this.serviceTreeLoader.load(app)
    
    // 更新状态
    const state = this.stateManager.getState()
    this.stateManager.setState({
      serviceTree: [] // tree
    })

    // 触发事件
    this.eventBus.emit(WorkspaceEvent.serviceTreeLoaded, { app, tree: [] })

    return []
  }
}
```

#### 5.2.2 FormDomainService

```typescript
// domain/services/FormDomainService.ts
import type { IStateManager } from '../interfaces/IStateManager'
import type { IEventBus } from '../interfaces/IEventBus'
import type { FieldConfig, FieldValue } from '@/types'

export interface FormState {
  data: Map<string, FieldValue>
  errors: Map<string, ValidationResult[]>
  submitting: boolean
}

export class FormDomainService {
  constructor(
    private stateManager: IStateManager<FormState>,
    private eventBus: IEventBus
  ) {}

  /**
   * 初始化表单
   */
  initializeForm(fields: FieldConfig[], initialData?: Record<string, any>): void {
    const state = this.stateManager.getState()
    const newData = new Map<string, FieldValue>()

    fields.forEach(field => {
      const fieldCode = field.code
      
      if (initialData && initialData.hasOwnProperty(fieldCode)) {
        const rawValue = initialData[fieldCode]
        newData.set(fieldCode, {
          raw: rawValue,
          display: typeof rawValue === 'object' ? JSON.stringify(rawValue) : String(rawValue),
          meta: {}
        })
      } else {
        // 使用默认值
        const defaultValue = this.getDefaultValue(field)
        newData.set(fieldCode, defaultValue)
      }
    })

    // 更新状态
    this.stateManager.setState({
      data: newData,
      errors: new Map(),
      submitting: false
    })

    // 触发事件
    this.eventBus.emit(FormEvent.initialized, { fields, data: newData })
  }

  /**
   * 更新字段值
   */
  updateFieldValue(fieldCode: string, value: FieldValue): void {
    const state = this.stateManager.getState()
    const newData = new Map(state.data)
    newData.set(fieldCode, value)

    // 更新状态
    this.stateManager.setState({ data: newData })

    // 处理字段依赖
    this.handleDependency(fieldCode, state.data)

    // 触发事件
    this.eventBus.emit(FormEvent.fieldValueUpdated, { fieldCode, value })
  }

  /**
   * 处理字段依赖
   */
  private handleDependency(fieldCode: string, data: Map<string, FieldValue>): void {
    // 查找依赖该字段的其他字段
    // 这里需要字段配置信息，为了简化，假设有 fields 配置
    // fields.forEach(field => {
    //   if (field.depend_on === fieldCode) {
    //     this.updateFieldValue(field.code, { raw: null, display: '', meta: {} })
    //   }
    // })
  }

  /**
   * 获取默认值
   */
  private getDefaultValue(field: FieldConfig): FieldValue {
    // 这里调用 Widget 的 getDefaultValue 方法
    // 为了简化，返回空值
    return { raw: null, display: '', meta: {} }
  }

  /**
   * 验证表单
   */
  validateForm(fields: FieldConfig[]): boolean {
    const state = this.stateManager.getState()
    const errors = new Map<string, ValidationResult[]>()

    // 验证所有字段
    fields.forEach(field => {
      const value = state.data.get(field.code)
      if (value && field.validation) {
        // 这里调用验证引擎
        // const fieldErrors = validationEngine.validateField(field, value, fields)
        // if (fieldErrors.length > 0) {
        //   errors.set(field.code, fieldErrors)
        // }
      }
    })

    // 更新状态
    this.stateManager.setState({ errors })

    // 触发事件
    this.eventBus.emit(FormEvent.validated, { errors })

    return errors.size === 0
  }
}
```

### 5.3 Application Layer 实现

#### 5.3.1 WorkspaceApplicationService

```typescript
// application/services/WorkspaceApplicationService.ts
import { WorkspaceDomainService } from '@/domain/services/WorkspaceDomainService'
import type { IEventBus } from '@/domain/interfaces/IEventBus'
import type { ServiceTree } from '@/types'

export class WorkspaceApplicationService {
  constructor(
    private domainService: WorkspaceDomainService,
    private eventBus: IEventBus
  ) {
    this.setupEventHandlers()
  }

  /**
   * 设置事件处理器
   */
  private setupEventHandlers(): void {
    // 监听节点点击事件
    this.eventBus.on(WorkspaceEvent.nodeClicked, async (payload: { node: ServiceTree }) => {
      await this.handleNodeClick(payload.node)
    })

    // 监听应用切换事件
    this.eventBus.on(WorkspaceEvent.appSwitched, async (payload: { app: App }) => {
      await this.handleAppSwitch(payload.app)
    })
  }

  /**
   * 处理节点点击
   */
  async handleNodeClick(node: ServiceTree): Promise<void> {
    if (node.type === 'function') {
      // 加载函数详情
      await this.domainService.loadFunction(node)
    } else {
      // 目录节点，不加载函数详情
      // 注意：这里需要添加 setCurrentFunction 方法到 Domain Service
    }
  }

  /**
   * 处理应用切换
   */
  async handleAppSwitch(app: App): Promise<void> {
    // 切换应用
    await this.domainService.switchApp(app)
    
    // 加载服务目录树
    await this.domainService.loadServiceTree(app)
  }
}
```

#### 5.3.2 FormApplicationService

```typescript
// application/services/FormApplicationService.ts
import { FormDomainService } from '@/domain/services/FormDomainService'
import type { IEventBus } from '@/domain/interfaces/IEventBus'
import type { FunctionDetail, FieldConfig } from '@/types'

export class FormApplicationService {
  constructor(
    private domainService: FormDomainService,
    private eventBus: IEventBus
  ) {
    this.setupEventHandlers()
  }

  /**
   * 设置事件处理器
   */
  private setupEventHandlers(): void {
    // 监听函数加载完成事件
    this.eventBus.on(WorkspaceEvent.functionLoaded, async (payload: { detail: FunctionDetail }) => {
      if (payload.detail.template_type === 'form') {
        await this.handleFunctionLoaded(payload.detail)
      }
    })

    // 监听字段值更新事件
    this.eventBus.on(FormEvent.fieldValueUpdated, (payload: { fieldCode: string, value: FieldValue }) => {
      // 可以在这里添加额外的业务逻辑
      // 例如：自动保存、自动验证等
    })
  }

  /**
   * 处理函数加载完成
   */
  async handleFunctionLoaded(detail: FunctionDetail): Promise<void> {
    // 初始化表单
    const fields = detail.request || []
    const initialData = {} // 从 URL 或其他地方获取
    
    this.domainService.initializeForm(fields, initialData)
  }

  /**
   * 提交表单
   */
  async submitForm(functionDetail: FunctionDetail): Promise<any> {
    // 验证表单
    const fields = functionDetail.request || []
    const isValid = this.domainService.validateForm(fields)
    
    if (!isValid) {
      throw new Error('表单验证失败')
    }

    // 获取提交数据
    // 这里需要从 StateManager 获取数据
    // const submitData = this.getSubmitData(fields)
    
    // 调用 API
    // const response = await this.apiClient.post(...)
    
    // 更新响应数据
    // this.domainService.setResponseData(response)
    
    return {}
  }
}
```

### 5.4 Presentation Layer 实现

#### 5.4.1 WorkspaceView.vue

```vue
<!-- presentation/views/WorkspaceView.vue -->
<template>
  <div class="workspace-view">
    <!-- 左侧服务目录树 -->
    <ServiceTreePanel
      :tree-data="serviceTree"
      :current-node="currentFunction"
      @node-click="handleNodeClick"
    />

    <!-- 中间函数渲染区域 -->
    <div class="function-renderer">
      <FormView
        v-if="currentFunctionDetail?.template_type === 'form'"
        :function-detail="currentFunctionDetail"
      />
      <TableView
        v-else-if="currentFunctionDetail?.template_type === 'table'"
        :function-detail="currentFunctionDetail"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, onMounted, onUnmounted } from 'vue'
import { useWorkspaceStore } from '@/infrastructure/stateManager/StateManagerImpl'
import { eventBus } from '@/infrastructure/eventBus/EventBusImpl'
import { WorkspaceApplicationService } from '@/application/services/WorkspaceApplicationService'
import { WorkspaceDomainService } from '@/domain/services/WorkspaceDomainService'
import { FunctionLoaderImpl } from '@/infrastructure/functionLoader/FunctionLoaderImpl'
import { WorkspaceStateManager } from '@/infrastructure/stateManager/StateManagerImpl'
import type { IApiClient } from '@/domain/interfaces/IApiClient'
import FormView from './FormView.vue'
import TableView from './TableView.vue'

// 依赖注入（在实际项目中可以使用依赖注入容器）
const workspaceStore = useWorkspaceStore()
const stateManager = new WorkspaceStateManager(workspaceStore)
const apiClient = {} as IApiClient // 实际实现
const functionLoader = new FunctionLoaderImpl(apiClient)
const domainService = new WorkspaceDomainService(functionLoader, stateManager, eventBus)
const applicationService = new WorkspaceApplicationService(domainService, eventBus)

// 从状态管理器获取状态
const serviceTree = computed(() => workspaceStore.serviceTree)
const currentFunction = computed(() => workspaceStore.currentFunction)
const currentFunctionDetail = computed(() => workspaceStore.currentFunctionDetail)

// 事件处理
const handleNodeClick = (node: ServiceTree) => {
  eventBus.emit(WorkspaceEvent.nodeClicked, { node })
}

// 生命周期
onMounted(() => {
  // 初始化：加载应用列表等
})

onUnmounted(() => {
  // 清理：取消事件监听等
})
</script>
```

#### 5.4.2 FormView.vue

```vue
<!-- presentation/views/FormView.vue -->
<template>
  <div class="form-view">
    <!-- 请求参数表单 -->
    <el-form v-if="requestFields.length > 0" :model="formData">
      <el-form-item
        v-for="field in requestFields"
        :key="field.code"
        :label="field.name"
        :error="getFieldError(field.code)"
      >
        <WidgetComponent
          :field="field"
          :value="getFieldValue(field.code)"
          @update:model-value="(v) => handleFieldUpdate(field.code, v)"
        />
      </el-form-item>
    </el-form>

    <!-- 提交按钮 -->
    <el-button type="primary" @click="handleSubmit">提交</el-button>

    <!-- 响应参数展示 -->
    <div v-if="hasResponseData" class="response-section">
      <div class="section-title">响应参数</div>
      <el-form>
        <el-form-item
          v-for="field in responseFields"
          :key="field.code"
          :label="field.name"
        >
          <WidgetComponent
            :field="field"
            :value="getResponseFieldValue(field.code)"
            mode="response"
          />
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, onMounted, onUnmounted } from 'vue'
import { useFormStore } from '@/infrastructure/stateManager/FormStateManager'
import { eventBus } from '@/infrastructure/eventBus/EventBusImpl'
import { FormApplicationService } from '@/application/services/FormApplicationService'
import { FormDomainService } from '@/domain/services/FormDomainService'
import { FormStateManager } from '@/infrastructure/stateManager/FormStateManager'
import WidgetComponent from '../widgets/WidgetComponent.vue'
import type { FunctionDetail } from '@/types'

const props = defineProps<{
  functionDetail: FunctionDetail
}>()

// 依赖注入
const formStore = useFormStore()
const stateManager = new FormStateManager(formStore)
const domainService = new FormDomainService(stateManager, eventBus)
const applicationService = new FormApplicationService(domainService, eventBus)

// 从状态管理器获取状态
const formData = computed(() => {
  const state = stateManager.getState()
  const data: Record<string, any> = {}
  state.data.forEach((value, key) => {
    data[key] = value.raw
  })
  return data
})

const requestFields = computed(() => props.functionDetail.request || [])
const responseFields = computed(() => props.functionDetail.response || [])

const hasResponseData = computed(() => {
  // 从状态管理器获取响应数据
  return false // 简化
})

// 方法
const getFieldValue = (fieldCode: string) => {
  const state = stateManager.getState()
  return state.data.get(fieldCode) || { raw: null, display: '', meta: {} }
}

const getFieldError = (fieldCode: string) => {
  const state = stateManager.getState()
  const errors = state.errors.get(fieldCode)
  return errors?.[0]?.message || ''
}

const handleFieldUpdate = (fieldCode: string, value: FieldValue) => {
  domainService.updateFieldValue(fieldCode, value)
}

const handleSubmit = async () => {
  await applicationService.submitForm(props.functionDetail)
}

// 生命周期
onMounted(() => {
  // 监听表单初始化事件
  const unsubscribe = eventBus.on(FormEvent.initialized, () => {
    // 表单已初始化，可以渲染
  })
  
  onUnmounted(() => {
    unsubscribe()
  })
})
</script>
```

---

## 六、扩展性分析（重点：新增功能时的影响）

### 6.1 扩展性设计原则

1. **开闭原则（OCP）**：对扩展开放，对修改关闭
   - ✅ 添加新功能时，**不需要修改现有代码**
   - ✅ 只需要添加新的实现和注册

2. **依赖倒置原则（DIP）**：依赖接口，不依赖具体实现
   - ✅ 所有层都依赖接口，可以轻松替换实现
   - ✅ 新功能只需要实现接口即可

3. **单一职责原则（SRP）**：每个模块只负责一个职责
   - ✅ 新功能可以独立添加，不影响现有功能
   - ✅ 模块之间通过接口和事件通信，解耦

4. **事件驱动**：使用事件通信，解耦组件
   - ✅ 新功能可以监听现有事件，不需要修改现有代码
   - ✅ 新功能可以触发新事件，现有代码不受影响

### 6.2 扩展场景分析

#### 场景 1：添加新的 Widget 组件

**需求示例**：添加一个 `DateRangeWidget`（日期范围选择器）

**影响分析**：
- ✅ **不影响现有代码**：只需要创建 Vue 组件文件和注册
- ✅ **不需要修改 FormView 或 TableView**：通过 WidgetRegistry 自动发现
- ✅ **不需要修改 Domain Service**：Widget 逻辑封装在组件内部
- ✅ **不需要修改 Application Service**：Widget 通过事件通信

**扩展步骤**：
1. 创建 Vue 组件文件 `DateRangeWidget.vue`（约 200-300 行代码）
2. 注册到 `WidgetComponentFactory`（1 行代码）
3. 完成（无需修改任何现有代码）

**代码示例**：

**步骤 1：创建 Vue 组件文件**

```vue
<!-- presentation/widgets/DateRangeWidget.vue -->
<template>
  <div class="date-range-widget">
    <!-- 编辑模式：日期范围选择器 -->
    <el-date-picker
      v-if="mode === 'edit'"
      v-model="internalValue"
      type="daterange"
      :disabled="field.widget?.config?.disabled"
      :placeholder="field.desc || `请选择${field.name}`"
      @change="handleChange"
    />
    
    <!-- 响应模式：只读文本 -->
    <span v-else-if="mode === 'response'" class="response-value">
      {{ displayValue }}
    </span>
    
    <!-- 表格单元格模式：简化显示 -->
    <span v-else-if="mode === 'table-cell'" class="table-cell-value">
      {{ displayValue }}
    </span>
    
    <!-- 详情模式：详情展示 -->
    <div v-else-if="mode === 'detail'" class="detail-value">
      <div class="detail-content">{{ displayValue }}</div>
    </div>
    
    <!-- 搜索模式：日期范围搜索 -->
    <el-date-picker
      v-else-if="mode === 'search'"
      v-model="internalValue"
      type="daterange"
      :placeholder="`搜索${field.name}`"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { ElDatePicker } from 'element-plus'
import type { WidgetComponentProps, WidgetComponentEmits } from '@/domain/interfaces/IWidgetRenderer'
import { useFormDataStore } from '@/infrastructure/stateManager/FormStateManager'

const props = withDefaults(defineProps<WidgetComponentProps>(), {
  value: () => ({
    raw: null,
    display: '',
    meta: {}
  })
})
const emit = defineEmits<WidgetComponentEmits>()

const formDataStore = useFormDataStore()

// 内部值（用于 v-model）
const internalValue = computed({
  get: () => {
    if (props.mode === 'edit' || props.mode === 'search') {
      // 从 raw 值解析日期范围
      const rawValue = props.value?.raw
      if (Array.isArray(rawValue) && rawValue.length === 2) {
        return rawValue
      }
      return null
    }
    return null
  },
  set: (newValue: [Date, Date] | null) => {
    if (props.mode === 'edit') {
      const newFieldValue = {
        raw: newValue,
        display: newValue ? `${formatDate(newValue[0])} 至 ${formatDate(newValue[1])}` : '',
        meta: {}
      }
      formDataStore.setValue(props.fieldPath, newFieldValue)
      emit('update:modelValue', newFieldValue)
    }
  }
})

// 显示值
const displayValue = computed(() => {
  const rawValue = props.value?.raw
  if (Array.isArray(rawValue) && rawValue.length === 2) {
    return `${formatDate(rawValue[0])} 至 ${formatDate(rawValue[1])}`
  }
  return props.value?.display || '-'
})

// 格式化日期
function formatDate(date: Date | string): string {
  // 日期格式化逻辑
  return String(date)
}

// 处理变化
function handleChange(value: [Date, Date] | null): void {
  internalValue.value = value
}
</script>

<style scoped>
.date-range-widget {
  width: 100%;
}
</style>
```

**步骤 2：注册组件**

```typescript
// infrastructure/widgetRegistry/WidgetComponentFactory.ts
import DateRangeWidget from '@/presentation/widgets/DateRangeWidget.vue'

// 注册组件（只需要这一行）
widgetComponentFactory.registerRequestComponent('date-range', DateRangeWidget)
```

**关键点说明**：

1. **需要创建 Vue 文件**：
   - ✅ Widget 是 Vue 组件，需要 `.vue` 文件
   - ✅ 可以使用 Vue 的模板、样式、响应式等特性
   - ✅ 可以使用 Element Plus 组件

2. **不需要修改现有代码**：
   - ✅ 不需要修改 FormView 或 TableView
   - ✅ 不需要修改 Domain Service
   - ✅ 不需要修改 Application Service
   - ✅ 只需要注册到 WidgetComponentFactory

3. **遵循统一接口**：
   - ✅ 所有 Widget 都使用 `WidgetComponentProps` 接口
   - ✅ 所有 Widget 都支持相同的 mode（edit、response、table-cell、detail、search）
   - ✅ 所有 Widget 都通过 `formDataStore` 管理数据

**结论**：✅ **完全不影响现有代码**，只需要创建 Vue 文件并注册即可

---

#### 场景 2：添加新的页面功能（例如：批量操作）

**需求示例**：在表格中添加批量删除、批量导出功能

**影响分析**：
- ✅ **不影响现有代码**：通过事件通信，解耦
- ✅ **可以独立开发**：创建新的 Application Service 和 Domain Service
- ✅ **可以独立测试**：mock 接口，便于单元测试
- ✅ **可以独立部署**：如果支持微服务，可以独立部署

**扩展步骤**：
1. 创建 `BatchOperationDomainService`（实现业务逻辑）
2. 创建 `BatchOperationApplicationService`（编排业务流程）
3. 在 Presentation Layer 添加 UI 组件
4. 监听相关事件，触发新功能
5. 完成（无需修改现有代码）

**代码示例**：
```typescript
// 1. Domain Service（业务逻辑）
export class BatchOperationDomainService {
  async batchDelete(ids: number[]): Promise<void> {
    // 批量删除逻辑
    this.eventBus.emit(TableEvent.rowsDeleted, { ids })
  }
}

// 2. Application Service（业务流程）
export class BatchOperationApplicationService {
  constructor(
    private domainService: BatchOperationDomainService,
    private eventBus: IEventBus
  ) {
    // 监听批量删除事件（新事件，不影响现有代码）
    this.eventBus.on('table:batch-delete', async (payload) => {
      await this.domainService.batchDelete(payload.ids)
    })
  }
}

// 3. Presentation Layer（UI）
const handleBatchDelete = () => {
  eventBus.emit('table:batch-delete', { ids: selectedIds.value })
}
```

**结论**：✅ **完全不影响现有代码**，新功能完全独立

---

#### 场景 3：添加新的渲染模式（例如：打印模式）

**需求示例**：添加打印模式，支持打印表单和表格

**影响分析**：
- ✅ **不影响现有 Widget**：Widget 只需要实现新的 render 方法（可选）
- ✅ **不需要修改 FormView**：通过 mode 参数控制
- ✅ **可以渐进式添加**：先支持部分 Widget，逐步扩展
- ✅ **现有功能不受影响**：打印模式是可选的

**扩展步骤**：
1. 在 `WidgetMode` 类型中添加新模式：`'print'`
2. 在 `IWidgetRenderer` 接口中添加 `renderPrint` 方法（可选）
3. 在各个 Widget 中实现打印模式渲染（可选，逐步添加）
4. 在 Presentation Layer 添加打印按钮
5. 完成（现有功能不受影响）

**代码示例**：

```vue
<!-- presentation/widgets/InputWidget.vue -->
<template>
  <div class="input-widget">
    <!-- 编辑模式 -->
    <el-input
      v-if="mode === 'edit'"
      v-model="internalValue"
    />
    
    <!-- 响应模式 -->
    <span v-else-if="mode === 'response'">
      {{ displayValue }}
    </span>
    
    <!-- 打印模式（新增，可选） -->
    <span v-else-if="mode === 'print'" class="print-value">
      {{ displayValue }}
    </span>
    
    <!-- 其他模式 -->
    <!-- ... -->
  </div>
</template>

<script setup lang="ts">
// 现有代码不需要修改
// 只需要在模板中添加 print 模式的处理
</script>
```

**关键点**：
- ✅ Widget 是 Vue 组件，在模板中添加新模式即可
- ✅ 不需要修改现有代码逻辑
- ✅ 可以渐进式添加（先支持部分 Widget，逐步扩展）

**结论**：✅ **不影响现有功能**，可以渐进式添加

---

#### 场景 4：添加新的数据源（例如：WebSocket 实时更新）

**需求示例**：添加 WebSocket 支持，实现实时数据更新

**影响分析**：
- ✅ **不影响现有代码**：通过接口抽象，可以替换实现
- ✅ **可以共存**：HTTP API 和 WebSocket 可以同时存在
- ✅ **可以渐进式迁移**：先支持部分功能，逐步迁移
- ✅ **可以 A/B 测试**：可以同时使用两种实现，对比效果

**扩展步骤**：
1. 创建 `WebSocketEventBus` 实现 `IEventBus` 接口
2. 创建 `WebSocketApiClient` 实现 `IApiClient` 接口
3. 在 Domain Service 中使用接口，不依赖具体实现
4. 通过依赖注入选择使用哪个实现
5. 完成（现有 HTTP API 代码不受影响）

**代码示例**：
```typescript
// 1. 实现 WebSocket EventBus
export class WebSocketEventBus implements IEventBus {
  private ws: WebSocket
  
  constructor(url: string) {
    this.ws = new WebSocket(url)
    this.ws.onmessage = (event) => {
      const { type, payload } = JSON.parse(event.data)
      this.emit(type, payload)
    }
  }
  
  emit(event: string, payload?: any): void {
    this.ws.send(JSON.stringify({ type: event, payload }))
  }
  // ... 其他方法
}

// 2. 在依赖注入时选择实现
const eventBus = useWebSocket 
  ? new WebSocketEventBus('ws://localhost:8080')
  : new EventBusImpl()  // 默认使用内存事件总线

// 3. Domain Service 不需要修改（依赖接口）
export class FormDomainService {
  constructor(
    private eventBus: IEventBus  // 依赖接口，可以是任何实现
  ) {}
}
```

**结论**：✅ **不影响现有代码**，可以轻松替换实现

---

#### 场景 5：添加新的验证规则

**需求示例**：添加自定义验证规则，例如：手机号验证、身份证验证

**影响分析**：
- ✅ **不影响现有验证**：通过策略模式，可以添加新规则
- ✅ **可以独立实现**：创建新的 Validator 类
- ✅ **可以组合使用**：多个验证规则可以组合
- ✅ **可以动态配置**：通过配置启用/禁用验证规则

**扩展步骤**：
1. 创建新的 Validator 类实现 `IValidator` 接口
2. 注册到 `ValidatorRegistry`
3. 在字段配置中使用新规则
4. 完成（现有验证逻辑不受影响）

**代码示例**：
```typescript
// 1. 实现验证器接口
export class PhoneValidator implements IValidator {
  validate(value: any, rule: ValidationRule): ValidationResult[] {
    const phoneRegex = /^1[3-9]\d{9}$/
    if (!phoneRegex.test(value)) {
      return [{ message: '请输入正确的手机号' }]
    }
    return []
  }
}

// 2. 注册
validatorRegistry.register('phone', new PhoneValidator())

// 3. 使用（在字段配置中）
{
  code: 'phone',
  validation: {
    rules: [{ type: 'phone' }]
  }
}
```

**结论**：✅ **不影响现有验证**，可以轻松添加新规则

---

### 6.3 扩展性保证机制

#### 6.3.1 接口抽象

**所有依赖都通过接口**：
- Presentation Layer 依赖 `IEventBus` 接口，不依赖具体实现
- Application Layer 依赖 Domain Service 接口
- Domain Layer 依赖 Infrastructure 接口

**好处**：
- ✅ 可以轻松替换实现（例如：从内存事件总线切换到 Redis 事件总线）
- ✅ 可以添加新实现（例如：添加 WebSocket 事件总线）
- ✅ 现有代码不需要修改

#### 6.3.2 事件驱动

**所有通信都通过事件**：
- 组件之间通过事件通信，不直接调用
- 新功能可以监听现有事件，不需要修改现有代码
- 新功能可以触发新事件，现有代码不受影响

**好处**：
- ✅ 解耦组件，便于维护
- ✅ 新功能可以独立开发
- ✅ 可以轻松添加新的事件监听器

#### 6.3.3 依赖注入

**所有依赖都通过依赖注入**：
- 在 Presentation Layer 注入依赖
- 可以轻松替换实现
- 可以添加新实现

**好处**：
- ✅ 便于测试（可以 mock 依赖）
- ✅ 便于扩展（可以添加新实现）
- ✅ 便于维护（依赖关系清晰）

### 6.4 实际扩展示例

#### 示例 1：添加批量删除功能

**需求**：在表格中添加批量删除功能

**完整实现**：

```typescript
// 1. Domain Service（业务逻辑）
// domain/services/BatchOperationDomainService.ts
export class BatchOperationDomainService {
  constructor(
    private apiClient: IApiClient,
    private eventBus: IEventBus
  ) {}

  async batchDelete(functionDetail: FunctionDetail, ids: number[]): Promise<void> {
    // 批量删除逻辑
    for (const id of ids) {
      await this.apiClient.post(`/api/v1/callback${functionDetail.router}`, {
        _type: 'OnTableDeleteRows',
        ids: [id]
      })
    }

    // 触发事件
    this.eventBus.emit(TableEvent.rowsDeleted, { ids })
  }
}

// 2. Application Service（业务流程编排）
// application/services/BatchOperationApplicationService.ts
export class BatchOperationApplicationService {
  constructor(
    private domainService: BatchOperationDomainService,
    private eventBus: IEventBus
  ) {
    this.setupEventHandlers()
  }

  private setupEventHandlers(): void {
    // 监听批量删除事件（新事件，不影响现有代码）
    this.eventBus.on('table:batch-delete', async (payload: { 
      functionDetail: FunctionDetail, 
      ids: number[] 
    }) => {
      await this.domainService.batchDelete(payload.functionDetail, payload.ids)
    })
  }
}

// 3. Presentation Layer（UI）
// presentation/views/TableView.vue
<template>
  <div class="table-view">
    <!-- 批量操作工具栏 -->
    <div v-if="selectedRows.length > 0" class="batch-toolbar">
      <el-button type="danger" @click="handleBatchDelete">
        批量删除 ({{ selectedRows.length }})
      </el-button>
    </div>

    <!-- 表格 -->
    <el-table :data="tableData" @selection-change="handleSelectionChange">
      <!-- ... -->
    </el-table>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { eventBus } from '@/infrastructure/eventBus/EventBusImpl'

const selectedRows = ref<any[]>([])

const handleSelectionChange = (rows: any[]) => {
  selectedRows.value = rows
}

const handleBatchDelete = () => {
  const ids = selectedRows.value.map(row => row.id)
  eventBus.emit('table:batch-delete', {
    functionDetail: props.functionDetail,
    ids
  })
}
</script>
```

**影响分析**：
- ✅ **不需要修改现有的 TableView**：新功能独立添加
- ✅ **不需要修改 TableDomainService**：新功能通过新 Service 实现
- ✅ **不需要修改 TableApplicationService**：新功能通过新 Service 实现
- ✅ **现有功能不受影响**：批量删除功能完全独立

---

#### 示例 2：添加导出功能

**需求**：在表格中添加导出 Excel 功能

**完整实现**：

```typescript
// 1. Domain Service
// domain/services/ExportDomainService.ts
export class ExportDomainService {
  constructor(
    private apiClient: IApiClient,
    private eventBus: IEventBus
  ) {}

  async exportToExcel(functionDetail: FunctionDetail, data: any[]): Promise<Blob> {
    // 导出逻辑
    const response = await this.apiClient.post(`/api/v1/export/excel`, {
      functionDetail,
      data
    })
    return response
  }
}

// 2. Application Service
// application/services/ExportApplicationService.ts
export class ExportApplicationService {
  constructor(
    private domainService: ExportDomainService,
    private eventBus: IEventBus
  ) {
    this.setupEventHandlers()
  }

  private setupEventHandlers(): void {
    this.eventBus.on('table:export-excel', async (payload: {
      functionDetail: FunctionDetail,
      data: any[]
    }) => {
      const blob = await this.domainService.exportToExcel(
        payload.functionDetail,
        payload.data
      )
      // 下载文件
      this.downloadFile(blob, 'export.xlsx')
    })
  }

  private downloadFile(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }
}

// 3. Presentation Layer
// presentation/views/TableView.vue
<template>
  <div class="table-view">
    <!-- 工具栏 -->
    <div class="toolbar">
      <el-button @click="handleExportExcel">导出 Excel</el-button>
    </div>
    <!-- ... -->
  </div>
</template>

<script setup lang="ts">
import { eventBus } from '@/infrastructure/eventBus/EventBusImpl'

const handleExportExcel = () => {
  eventBus.emit('table:export-excel', {
    functionDetail: props.functionDetail,
    data: tableData.value
  })
}
</script>
```

**影响分析**：
- ✅ **不需要修改现有代码**：新功能完全独立
- ✅ **可以独立开发**：不影响现有功能开发
- ✅ **可以独立测试**：mock 接口，便于测试

---

#### 示例 3：添加实时协作功能

**需求**：添加多人实时协作编辑功能

**完整实现**：

```typescript
// 1. Infrastructure 实现
// infrastructure/collaboration/WebSocketEventBus.ts
export class WebSocketEventBus implements IEventBus {
  private ws: WebSocket
  private handlers = new Map<string, Set<Function>>()

  constructor(url: string) {
    this.ws = new WebSocket(url)
    this.ws.onmessage = (event) => {
      const { type, payload } = JSON.parse(event.data)
      this.emit(type, payload)
    }
  }

  emit(event: string, payload?: any): void {
    // 发送到服务器
    this.ws.send(JSON.stringify({ type: event, payload }))
    // 本地也触发
    const handlers = this.handlers.get(event)
    if (handlers) {
      handlers.forEach(handler => handler(payload))
    }
  }

  on(event: string, handler: Function): () => void {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Set())
    }
    this.handlers.get(event)!.add(handler)
    return () => this.off(event, handler)
  }

  off(event: string, handler: Function): void {
    this.handlers.get(event)?.delete(handler)
  }

  once(event: string, handler: Function): void {
    const onceHandler = (payload?: any) => {
      handler(payload)
      this.off(event, onceHandler)
    }
    this.on(event, onceHandler)
  }
}

// 2. Domain Service（不需要修改，依赖接口）
// domain/services/CollaborationDomainService.ts
export class CollaborationDomainService {
  constructor(
    private eventBus: IEventBus,  // 依赖接口，可以是内存事件总线或 WebSocket 事件总线
    // ...
  ) {}

  async syncFieldValue(fieldCode: string, value: FieldValue): Promise<void> {
    // 同步字段值到服务器
    this.eventBus.emit('collaboration:field-synced', { fieldCode, value })
  }
}

// 3. 在依赖注入时选择实现
// presentation/views/FormView.vue
<script setup lang="ts">
// 根据配置选择使用哪个事件总线实现
const eventBus = useCollaboration 
  ? new WebSocketEventBus('ws://localhost:8080')
  : new EventBusImpl()  // 默认使用内存事件总线

const domainService = new CollaborationDomainService(eventBus, ...)
</script>
```

**影响分析**：
- ✅ **不需要修改现有代码**：通过接口抽象，可以替换实现
- ✅ **可以渐进式迁移**：先支持部分功能，逐步迁移
- ✅ **可以共存**：HTTP API 和 WebSocket 可以同时存在

---

### 6.5 扩展性总结

**新架构的扩展性优势**：

1. ✅ **添加新功能不影响现有代码**
   - 通过接口抽象，新功能可以独立实现
   - 通过事件驱动，新功能可以独立监听和触发事件
   - 通过依赖注入，可以轻松替换实现

2. ✅ **可以独立开发和测试**
   - 新功能可以独立创建 Service
   - 可以 mock 接口，便于单元测试
   - 可以独立部署（如果支持微服务）

3. ✅ **可以渐进式扩展**
   - 可以先支持部分功能，逐步扩展
   - 可以逐步迁移现有功能到新架构
   - 可以保持向后兼容

4. ✅ **便于维护**
   - 代码结构清晰，职责明确
   - 依赖关系清晰，便于理解
   - 可以轻松定位和修复问题

**扩展性对比**：

| 扩展场景 | 旧架构 | 新架构 |
|---------|--------|--------|
| 添加新 Widget | ❌ 需要修改 TableRenderer | ✅ 只需实现接口和注册 |
| 添加新功能 | ❌ 需要修改多个文件 | ✅ 创建新 Service，独立实现 |
| 添加新数据源 | ❌ 需要修改 Domain Service | ✅ 实现接口，替换实现 |
| 添加新验证规则 | ❌ 需要修改验证引擎 | ✅ 实现接口，注册即可 |
| 添加新渲染模式 | ❌ 需要修改所有 Widget | ✅ 可选方法，渐进式添加 |

---

## 七、扩展指南（具体步骤）

### 7.1 添加新的 Widget 组件

**回答**：✅ **是的，需要创建 Vue 文件（`.vue`）**

**原因**：
- Widget 是 Vue 组件，需要使用 Vue 的模板、样式、响应式等特性
- 需要使用 Element Plus 组件（如 `el-input`、`el-select`、`el-date-picker` 等）
- 需要支持 Vue 的生命周期、计算属性、watch 等特性
- 需要支持样式（scoped CSS）

**完整步骤**：

**步骤 1：创建 Vue 组件文件**

```vue
<!-- presentation/widgets/DateRangeWidget.vue -->
<template>
  <div class="date-range-widget">
    <!-- 编辑模式：日期范围选择器 -->
    <el-date-picker
      v-if="mode === 'edit'"
      v-model="internalValue"
      type="daterange"
      :disabled="field.widget?.config?.disabled"
      :placeholder="field.desc || `请选择${field.name}`"
      @change="handleChange"
    />
    
    <!-- 响应模式：只读文本 -->
    <span v-else-if="mode === 'response'" class="response-value">
      {{ displayValue }}
    </span>
    
    <!-- 表格单元格模式：简化显示 -->
    <span v-else-if="mode === 'table-cell'" class="table-cell-value">
      {{ displayValue }}
    </span>
    
    <!-- 详情模式：详情展示 -->
    <div v-else-if="mode === 'detail'" class="detail-value">
      <div class="detail-content">{{ displayValue }}</div>
    </div>
    
    <!-- 搜索模式：日期范围搜索 -->
    <el-date-picker
      v-else-if="mode === 'search'"
      v-model="internalValue"
      type="daterange"
      :placeholder="`搜索${field.name}`"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { ElDatePicker } from 'element-plus'
import type { WidgetComponentProps, WidgetComponentEmits } from '@/domain/interfaces/WidgetComponentProps'
import { useFormDataStore } from '@/infrastructure/stateManager/FormStateManager'

const props = withDefaults(defineProps<WidgetComponentProps>(), {
  value: () => ({
    raw: null,
    display: '',
    meta: {}
  })
})
const emit = defineEmits<WidgetComponentEmits>()

const formDataStore = useFormDataStore()

// 内部值（用于 v-model）
const internalValue = computed({
  get: () => {
    if (props.mode === 'edit' || props.mode === 'search') {
      const rawValue = props.value?.raw
      if (Array.isArray(rawValue) && rawValue.length === 2) {
        return rawValue
      }
      return null
    }
    return null
  },
  set: (newValue: [Date, Date] | null) => {
    if (props.mode === 'edit') {
      const newFieldValue = {
        raw: newValue,
        display: newValue ? `${formatDate(newValue[0])} 至 ${formatDate(newValue[1])}` : '',
        meta: {}
      }
      formDataStore.setValue(props.fieldPath, newFieldValue)
      emit('update:modelValue', newFieldValue)
    }
  }
})

// 显示值
const displayValue = computed(() => {
  const rawValue = props.value?.raw
  if (Array.isArray(rawValue) && rawValue.length === 2) {
    return `${formatDate(rawValue[0])} 至 ${formatDate(rawValue[1])}`
  }
  return props.value?.display || '-'
})

// 格式化日期
function formatDate(date: Date | string): string {
  return String(date)
}

// 处理变化
function handleChange(value: [Date, Date] | null): void {
  internalValue.value = value
}
</script>

<style scoped>
.date-range-widget {
  width: 100%;
}
</style>
```

**步骤 2：注册组件**

```typescript
// infrastructure/widgetRegistry/WidgetComponentFactory.ts
import DateRangeWidget from '@/presentation/widgets/DateRangeWidget.vue'

// 注册组件（只需要这一行）
widgetComponentFactory.registerRequestComponent('date-range', DateRangeWidget)
```

**步骤 3：在 Presentation Layer 使用（自动）**

```vue
<!-- presentation/views/FormView.vue -->
<!-- 不需要修改，自动通过 WidgetComponentFactory 发现 -->
<component
  :is="getWidgetComponent(field.widget?.type || 'input')"
  :field="field"
  :value="getFieldValue(field.code)"
  @update:model-value="(v) => handleFieldUpdate(field.code, v)"
/>
```

**关键点**：
- ✅ **需要创建 Vue 文件**：Widget 是 Vue 组件，需要 `.vue` 文件
- ✅ **不需要修改现有代码**：只需要注册到 WidgetComponentFactory
- ✅ **遵循统一接口**：所有 Widget 都使用 `WidgetComponentProps` 接口
- ✅ **支持多种模式**：edit、response、table-cell、detail、search

**文件结构**：
```
presentation/
  widgets/
    DateRangeWidget.vue          ← 新建（约 200-300 行）
    
infrastructure/
  widgetRegistry/
    WidgetComponentFactory.ts     ← 只需添加 1 行注册代码
```

**总结**：
- ✅ 需要创建 Vue 文件（`.vue`）
- ✅ 不需要修改现有代码
- ✅ 只需要注册即可使用

### 7.1 添加新的 Domain Service

**影响**：✅ **不影响现有代码**，新功能独立实现

**步骤 1：创建 Domain Service**

```typescript
// domain/services/NewDomainService.ts
import type { IStateManager } from '../interfaces/IStateManager'
import type { IEventBus } from '../interfaces/IEventBus'

export class NewDomainService {
  constructor(
    private stateManager: IStateManager<NewState>,
    private eventBus: IEventBus
  ) {}

  async doSomething(): Promise<void> {
    // 业务逻辑
    // 更新状态
    // 触发事件
  }
}
```

**步骤 2：创建 Application Service**

```typescript
// application/services/NewApplicationService.ts
import { NewDomainService } from '@/domain/services/NewDomainService'
import type { IEventBus } from '@/domain/interfaces/IEventBus'

export class NewApplicationService {
  constructor(
    private domainService: NewDomainService,
    private eventBus: IEventBus
  ) {
    this.setupEventHandlers()
  }

  private setupEventHandlers(): void {
    this.eventBus.on('SOME_EVENT', async (payload) => {
      await this.domainService.doSomething()
    })
  }
}
```

**步骤 3：在 Presentation Layer 使用**

```vue
<script setup lang="ts">
import { NewApplicationService } from '@/application/services/NewApplicationService'
import { NewDomainService } from '@/domain/services/NewDomainService'

// 依赖注入
const domainService = new NewDomainService(stateManager, eventBus)
const applicationService = new NewApplicationService(domainService, eventBus)
</script>
```

**关键点**：
- ✅ 遵循依赖倒置原则
- ✅ 使用事件驱动
- ✅ 单一职责

### 7.2 添加新的 Infrastructure 实现

**影响**：✅ **不影响现有代码**，通过接口抽象可以替换实现

**步骤 1：实现接口**

```typescript
// infrastructure/cache/CacheManagerImpl.ts
import type { ICacheManager } from '@/domain/interfaces/ICacheManager'

export class CacheManagerImpl implements ICacheManager {
  private cache = new Map<string, any>()

  get<T>(key: string): T | null {
    return this.cache.get(key) || null
  }

  set<T>(key: string, value: T): void {
    this.cache.set(key, value)
  }

  clear(): void {
    this.cache.clear()
  }
}
```

**步骤 2：在 Domain Service 中使用**

```typescript
// domain/services/SomeDomainService.ts
export class SomeDomainService {
  constructor(
    private cacheManager: ICacheManager,  // 依赖接口，不依赖具体实现
    // ...
  ) {}

  async loadData(key: string): Promise<any> {
    // 先检查缓存
    const cached = this.cacheManager.get(key)
    if (cached) {
      return cached
    }

    // 加载数据
    const data = await this.loader.load(key)
    
    // 缓存数据
    this.cacheManager.set(key, data)
    
    return data
  }
}
```

**关键点**：
- ✅ Domain Service 依赖接口，不依赖具体实现
- ✅ 可以轻松替换实现（例如：从内存缓存切换到 Redis 缓存）
- ✅ 遵循依赖倒置原则

---

## 八、依赖倒置原则的体现

### 7.1 依赖关系图

```
Presentation Layer
    ↓ (依赖接口)
Application Layer
    ↓ (依赖接口)
Domain Layer
    ↓ (依赖接口)
Infrastructure Layer
    ↓ (实现接口)
具体技术实现
```

### 7.2 关键设计

1. **所有层都依赖接口，不依赖具体实现**
   - Presentation Layer 依赖 `IEventBus` 接口
   - Application Layer 依赖 Domain Service 接口
   - Domain Layer 依赖 Infrastructure 接口

2. **Infrastructure Layer 实现接口**
   - `EventBusImpl` 实现 `IEventBus`
   - `FunctionLoaderImpl` 实现 `IFunctionLoader`
   - `StateManagerImpl` 实现 `IStateManager`

3. **可以轻松替换实现**
   - 可以替换 EventBus 实现（例如：从内存事件总线切换到 Redis 事件总线）
   - 可以替换 FunctionLoader 实现（例如：添加缓存层）
   - 可以替换 StateManager 实现（例如：从 Pinia 切换到其他状态管理库）

---

## 九、扩展性保证总结

### 9.1 新增功能时的影响分析

**核心保证**：✅ **新增功能时，现有代码完全不受影响**

**原因**：
1. **接口抽象**：所有依赖都通过接口，新功能只需要实现接口
2. **事件驱动**：新功能通过事件通信，不直接调用现有代码
3. **依赖注入**：新功能可以独立注入，不影响现有功能
4. **单一职责**：每个模块只负责一个职责，新功能可以独立添加

**实际案例**：

| 新增功能 | 需要修改的文件 | 影响范围 |
|---------|--------------|---------|
| 添加新 Widget | 0 个（只需实现接口和注册） | ✅ 无影响 |
| 添加批量操作 | 0 个（创建新 Service） | ✅ 无影响 |
| 添加导出功能 | 0 个（创建新 Service） | ✅ 无影响 |
| 添加实时协作 | 0 个（实现新接口） | ✅ 无影响 |
| 添加新验证规则 | 0 个（实现接口和注册） | ✅ 无影响 |

### 9.2 扩展性对比

**旧架构**：
- ❌ 添加新 Widget 需要修改 TableRenderer（231 行硬编码）
- ❌ 添加新功能需要修改多个文件
- ❌ 添加新数据源需要修改 Domain Service
- ❌ 代码耦合度高，难以扩展

**新架构**：
- ✅ 添加新 Widget 只需实现接口和注册（0 个文件修改）
- ✅ 添加新功能只需创建新 Service（0 个文件修改）
- ✅ 添加新数据源只需实现接口（0 个文件修改）
- ✅ 代码解耦，易于扩展

### 9.3 扩展性保证机制

1. **接口抽象**：所有依赖都通过接口，可以轻松替换实现
2. **事件驱动**：所有通信都通过事件，解耦组件
3. **依赖注入**：所有依赖都通过注入，便于测试和扩展
4. **单一职责**：每个模块只负责一个职责，新功能可以独立添加

---

## 十、优势总结

### 8.1 解决的问题

1. ✅ **重复调用问题**：统一入口，防抖和去重
2. ✅ **时序问题**：事件驱动，不依赖时序
3. ✅ **响应式更新复杂**：统一状态管理，自动更新
4. ✅ **状态管理混乱**：单一数据源，统一管理
5. ✅ **性能问题**：缓存机制，优化计算
6. ✅ **代码重复**：公共逻辑提取，统一接口
7. ✅ **组件耦合**：事件驱动，接口依赖
8. ✅ **缺乏抽象层**：接口抽象，策略模式

### 8.2 架构优势

1. **清晰的分层**：职责明确，易于理解
2. **依赖倒置**：易于测试和扩展
3. **事件驱动**：解耦组件，便于维护
4. **单一数据源**：状态一致，易于追踪
5. **易于扩展**：新功能可以轻松添加
6. **易于测试**：可以 mock 接口，便于单元测试

---

## 十一、迁移计划

### 9.1 第一阶段：基础设施

1. 创建接口定义（IEventBus, IStateManager, IFunctionLoader 等）
2. 实现基础设施层（EventBusImpl, StateManagerImpl, FunctionLoaderImpl）
3. 创建依赖注入容器

### 9.2 第二阶段：领域层

1. 创建 Domain Services（WorkspaceDomainService, FormDomainService）
2. 迁移业务逻辑到 Domain Services
3. 使用接口依赖，不依赖具体实现

### 9.3 第三阶段：应用层

1. 创建 Application Services（WorkspaceApplicationService, FormApplicationService）
2. 迁移业务流程到 Application Services
3. 设置事件处理器

### 9.4 第四阶段：展示层

1. 简化 Presentation Layer 组件（< 300 行）
2. 从状态管理器获取状态
3. 使用事件通信

---

## 十二、总结

这个新架构设计：

1. ✅ **严格遵循依赖倒置原则**：所有层都依赖接口，不依赖具体实现
2. ✅ **清晰的分层架构**：Presentation → Application → Domain → Infrastructure
3. ✅ **事件驱动**：使用事件通信，解耦组件
4. ✅ **单一数据源**：所有状态都通过 StateManager 管理
5. ✅ **易于扩展**：新功能可以轻松添加，不需要修改现有代码
6. ✅ **易于测试**：可以 mock 接口，便于单元测试

通过这个架构，我们可以：
- 解决所有当前的问题和痛点
- 保持代码的可维护性和可扩展性
- 遵循 SOLID 原则，特别是依赖倒置原则

