# 架构总览

## 文档导航

本目录包含新版本前端架构的完整设计文档，请按以下顺序阅读：

### 0. 🔗 后端数据结构对齐.md（必读）
**首先阅读**，理解前后端数据结构对应关系：
- 后端 Field 结构（Go）
- 前端 FieldConfig 结构（TypeScript）
- Widget 类型和配置对应关系
- 数据类型映射
- 条件渲染从 validation 中解析
- 字段联动使用 watch 机制
- 提交数据格式转换

### 0.5. 🔗 架构设计-字段路径增强器.md（基础设施，建议优先阅读）
**基础设施**，为所有字段添加唯一标识：
- 🔥 **核心问题**：为什么需要 field_path
- 🔥 **设计方案**：前端自动增强（后端无需改动）
- 🔥 **路径格式**：`member_card_id`、`products[]`、`products[].product_id`
- 🔥 **使用场景**：FormDataManager、LinkageEngine、Widget 都依赖它
- 💡 **增强前后对比**：清晰展示增强效果

**为什么优先读：**
- field_path 是整个架构的基础
- 后续的数据管理、字段联动都依赖它
- 理解了它，后面的文档会更容易理解

### 1. 📘 新版本架构设计.md（主文档）
**必读**，这是核心架构文档，包含：
- 设计原则和核心理念
- 核心数据结构（`FieldValue`、`FieldConfig`，**已更新对齐后端**）
- OOP 组件继承体系（BaseWidget）
- Widget 工厂模式
- 回调系统设计
- 聚合统计系统

### 2. 🎯 架构设计-事件驱动与组件职责.md（⭐ 核心设计）
**必读**，这是整个系统的核心设计理念，包含：
- 🔥 **事件驱动架构**：组件通过事件通信，避免直接耦合
- 🔥 **职责清晰**：子组件只管自己，父组件协调处理
- 🔥 **BaseWidget 基类**：所有组件的父类，提供通用方法
- 🔥 **SelectWidget**：只管自己的值，发出搜索/变化事件
- 🔥 **MultiSelectWidget**：计算行内聚合，发出变化事件
- 🔥 **ListWidget**：监听子组件事件，调用回调，计算List层聚合
- 🔥 **field_path 的真正作用**：事件的唯一标识符，不是用于跨组件直接更新

**为什么必读：**
- 这是整个架构的核心设计思想
- 理解了"为什么不跨组件直接更新"，就理解了整个系统
- 提供了完整的 BaseWidget、SelectWidget、MultiSelectWidget、ListWidget 实现
- 展示了如何通过事件驱动实现组件解耦

### 3. 🔄 架构设计-响应式数据流与组件联动.md
**详细设计**，基于主文档扩展，解决：
- ✅ 每个组件都能访问全部表单数据（只读）
- ✅ 回调时自动传递完整上下文
- ✅ 字段联动（特殊场景，使用 watch 机制）
- ✅ List 嵌套场景（每行独立管理）
- ✅ 复杂场景（收银台、级联选择等）
- ⚠️ **注意**：避免跨组件直接更新，应使用事件驱动

**核心组件：**
- `ReactiveFormDataManager` - 响应式表单数据管理器（升级版，带事件总线）
- `watchField` - 字段变化监听
- `emit` - 发出事件
- `on` - 监听事件
- 子 `FormDataManager` - List 行级管理

### 4. 🎯 架构设计-条件渲染与动态验证.md
**详细设计**，基于主文档扩展，解决：
- ✅ 从 validation 解析条件（required_if, excluded_if）
- ✅ 条件显示/隐藏
- ✅ 条件必填
- ✅ 自动清空隐藏字段
- ⚠️ **注意**：不在 FieldConfig 中添加 conditions 字段

**核心组件：**
- `ConditionEvaluator` - 从 validation 字符串解析条件
- 旧版本配置自动转换器

### 5. ✅ 架构设计-验证系统（简化版）.md
**详细设计**，渐进式实现验证，解决：
- ✅ **核心验证**：required, min, max, oneof, required_if（覆盖 90% 场景）
- ✅ **后端兜底**：前端验证只是提升体验，不是强依赖
- ✅ **易于扩展**：需要时简单注册新验证器
- 💡 **完整对齐**：后续按需添加 Go validator/v10 的其他验证器

**核心组件：**
- `ValidatorEngine` - 验证引擎（简化版）
- 5 个核心验证器（Phase 1）
- 扩展机制（按需添加）

**实现优先级：**
- 🔥 Phase 1: required, min, max, oneof, required_if
- ⭐ Phase 2: email, url, numeric, eqfield（有需要再做）
- 💡 Phase 3: 其他 60+ 验证器（按需扩展）

### 6. 💼 架构设计-收银台完整场景示例.md（推荐阅读）
**完整示例**，展示最复杂场景的实现方案：
- ✅ 会员卡选择
- ✅ List 嵌套（商品清单）
- ✅ List 内 Select 访问父表单（会员卡）
- ✅ 聚合计算（实时统计商品总价）
- ✅ displayInfo 参与计算
- ✅ 回调自动传递完整表单状态

**为什么要读：**
- 这是最复杂的场景，理解它就理解了整个架构
- 展示了所有核心机制的协同工作
- 提供了完整的代码实现参考

### 7. 📊 架构设计-聚合统计完整场景.md（重要）
**聚合统计专题**，详细说明所有聚合场景：
- ✅ **场景 1**：顶层 MultiSelect 聚合（用户直接多选商品）
- ✅ **场景 2**：Struct 内 MultiSelect 聚合
- ✅ **场景 3**：List 内 Select 聚合（List 层聚合所有行）
- ✅ **场景 4**：List 内 MultiSelect 聚合（🔥 **最复杂，两层聚合**）
  - 第一层：每个 MultiSelect 自己聚合（计算这个用户的商品数、总价）
  - 第二层：ListWidget 聚合所有行（计算所有用户的商品数、总价）

**为什么要读：**
- 聚合计算不仅仅是 List 内才能用
- MultiSelect 在任何位置都可以支持聚合
- 理解四种场景的区别，特别是两层聚合的复杂场景
- 理解职责划分：谁负责哪层聚合
- 数据来源说明（displayInfo + 字段值 + 行内统计结果）
- 表达式解析器支持的函数（行内聚合 + List 层聚合）

### 8. 🎁 架构设计-分享视图系统.md（⭐ 强烈推荐）
**最优雅的分享方案**，解决：
- ✅ **核心思路**：点击分享 → 生成快照 → 保存到后端 → 返回 view_id
- ✅ **极简 URL**：`?view_id=abc123xyz`（只有 view_id，不超过 30 字符）
- ✅ **一次加载**：一次请求获取完整快照（~100ms）
- ✅ **无限制**：支持富文本、大数据、聚合信息、displayInfo
- ✅ **高安全**：数据在后端，不暴露在 URL
- ✅ **可扩展**：历史记录、收藏、权限、二维码等

**为什么要读：**
- 这是最优雅、最强大的分享方案
- 完全取代 URL 回想方案（更简单、更强大）
- 支持富文本、大数据等场景
- 可扩展历史记录、收藏等功能
- 必读！这是生产环境的最佳方案

### 8.1 🔧 架构设计-组件快照机制.md（⭐ 技术实现）
**分享视图系统的技术实现**，详细说明：
- ✅ **快照接口设计**：`captureSnapshot()` / `restoreSnapshot()`
- ✅ **BaseWidget 默认实现**：简化组件开发
- ✅ **各组件的快照实现**：
  - InputWidget：无额外数据，使用默认实现
  - SelectWidget：保存选项列表
  - MultiSelectWidget：保存选项列表 + 行内聚合
  - ListWidget：保存 List 层聚合 + 递归保存所有子组件
- ✅ **递归快照**：ListWidget 递归捕获/恢复子组件
- ✅ **FormRenderer 统一调度**：遍历所有 Widget，调用快照方法
- ✅ **Widget 实例缓存**：必须缓存实例才能快照

**为什么要读：**
- 这是分享视图系统的具体技术实现
- 理解每个组件如何实现快照功能
- 理解递归快照的机制
- 必读！开发分享功能必须理解这个

### 9. 🔗 架构设计-URL回想与缓存策略.md（备选方案）
> ⚠️ 已被分享视图系统取代，作为备选方案保留

**URL 回想方案**（不推荐）：
- ✅ 各自管各自 + 缓存复用
- ❌ 多次请求（10 行 → 2-3 次）
- ❌ URL 长度限制（2-8KB）
- ❌ 无法保存富文本、大数据
- ❌ 需要复杂的缓存管理器

**为什么保留：**
- 作为备选方案参考
- 理解缓存策略的设计思路
- 如果不想后端存储快照，可以考虑

---

## 架构分层

```
┌─────────────────────────────────────────────────────────────┐
│               FormRenderer / TableRenderer                  │  表单/表格渲染器
│                    （Vue 组件）                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    Widget Factory                           │  组件工厂
│  ┌──────────┬──────────┬──────────┬──────────────────┐    │
│  │  Input   │  Select  │  List    │  Checkbox  ...   │    │  各种 Widget
│  └──────────┴──────────┴──────────┴──────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↓
┌─────────────────────────────────────────────────────────────┐
│         ReactiveFormDataManager (核心)                      │  响应式数据管理
│  ┌──────────────────────────────────────────────────┐     │
│  │  - 数据存储（reactive Map）                       │     │
│  │  - 数据读写（getValue/setValue）                 │     │
│  │  - 监听机制（watch/batchUpdate）                 │     │
│  │  - 条件求值（isFieldVisible/isFieldRequired）    │     │
│  │  - 验证管理（validateField/validateAll）         │     │
│  └──────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────┘
                              │
            ┌─────────────────┼─────────────────┬─────────────┐
            ↓                 ↓                 ↓             ↓
┌────────────────┐ ┌─────────────────┐ ┌──────────────┐ ┌─────────────┐
│ConditionEval.  │ │ ValidatorEngine │ │CallbackMgr.  │ │ExpressionPar│
│ 条件求值器     │ │  验证引擎       │ │ 回调管理器   │ │ 表达式解析  │
│                │ │                 │ │              │ │             │
│• visible       │ │• 70+ 验证器     │ │• OnSelectFuz │ │• 聚合统计   │
│• enabled       │ │• 跨字段验证     │ │• OnInputVal. │ │• sum/avg    │
│• required      │ │• 国际化消息     │ │• Table CRUD  │ │• 表达式计算 │
│• readonly      │ │• 对齐Go v10     │ │• 自动上下文  │ │             │
└────────────────┘ └─────────────────┘ └──────────────┘ └─────────────┘
```

---

## 核心概念

### 1. FieldValue - 字段值的统一表示

```typescript
{
  raw: any,              // 提交值（后端需要的）
  display: string,       // 显示值（UI展示的）
  meta?: {               // 元数据（额外信息）
    displayInfo?: {...}, // select的详细信息
    dataType: string,    // 数据类型
    fromCallback: bool   // 是否来自回调
  }
}
```

**解决问题：**
- 旧版本中 `raw`、`display`、`displayInfo` 分散存储，容易混乱
- 新版本统一管理，结构清晰

### 2. ReactiveFormDataManager - 响应式数据中心

**核心能力：**
- ✅ 所有数据集中存储
- ✅ 响应式更新（基于 Vue reactive）
- ✅ 任意组件访问任意数据
- ✅ 任意组件更新任意数据
- ✅ 数据变化可监听

**解决问题：**
- 旧版本数据分散，组件间传递复杂
- 回调时需要手动收集上下文数据
- 字段联动需要手动处理

### 3. ConditionEvaluator - 条件求值器

**支持的条件：**
- `visible` - 控制显示/隐藏
- `enabled` - 控制启用/禁用
- `required` - 控制必填/非必填
- `readonly` - 控制只读/可编辑

**支持的操作符：**
- `eq`/`ne` - 等于/不等于
- `gt`/`lt`/`gte`/`lte` - 大于/小于/大于等于/小于等于
- `in`/`not_in` - 在集合中/不在集合中
- `contains`/`not_contains` - 包含/不包含
- `empty`/`not_empty` - 为空/不为空

**解决问题：**
- 旧版本只支持 `required_if` 等简单条件
- 新版本支持复杂条件组合（`and`/`or`）

### 4. Widget Factory - 组件工厂

**核心特性：**
- 统一的组件接口（`IWidget`）
- 统一的渲染属性（`WidgetRenderProps`）
- 递归渲染支持（List 嵌套）
- 扩展性强（新增组件只需实现接口）

**Widget 接收的 Props：**
```typescript
{
  field: FieldConfig,           // 字段配置
  value: FieldValue,            // 当前值
  onChange: Function,           // 更新当前字段
  formManager: Manager,         // 🔥 数据管理器（核心）
  getFieldValue: Function,      // 获取其他字段
  updateField: Function,        // 更新其他字段
  watchField: Function,         // 监听其他字段
  disabled/readonly/required    // 状态
}
```

**解决问题：**
- 旧版本组件间耦合严重，难以复用
- 新版本组件独立，易于测试和维护

---

## 数据流示例

### 场景1：用户选择省份，城市字段自动清空

```typescript
// 1. 用户选择省份
SelectWidget.handleSelect('广东省')

// 2. 更新省份字段
onChange({
  raw: '广东省',
  display: '广东省',
  meta: { dataType: 'string' }
})

// 3. FormDataManager 自动触发监听器
formManager.setValue('province', newValue)
  → notifyWatchers('province', newValue, oldValue)

// 4. 城市字段的监听器被触发
watchField('province', (newVal, oldVal) => {
  if (newVal?.raw !== oldVal?.raw) {
    updateField('city', null)  // 🔥 自动清空城市
  }
})
```

### 场景2：选择商品时，回调传递会员信息

```typescript
// 1. 用户在 List 中选择商品
ListWidget → row[0] → SelectWidget.openDialog()

// 2. SelectWidget 获取完整上下文
const rowContext = rowManager.getAllRawValues()
// { product_id: null, quantity: 1 }

const formContext = parentFormManager.getAllRawValues()
// { member_id: 1, product_quantities: [...] }

// 3. 调用回调，传递完整上下文
callbackManager.executeSelectFuzzy(
  field,
  searchValue,
  formContext  // 🔥 包含会员信息
)

// 4. 后端根据会员信息返回会员价
response: {
  values: [...],
  statistics: { "总金额": "sum(会员价,*数量)" }
}
```

### 场景3：工单类型变化，显示/隐藏相关字段

```typescript
// 1. 用户选择工单类型 = "硬件故障"
formManager.setValue('工单类型', '硬件故障')

// 2. FormRenderer 重新计算字段状态
fieldStates = computed(() => {
  return {
    '是否需要上门': {
      visible: conditionEvaluator.evaluate(
        field.conditions.visible,  // { field: '工单类型', operator: 'eq', value: '硬件故障' }
        formManager.getAllRawValues()
      )  // → true ✅
    },
    '上门地址': {
      visible: conditionEvaluator.evaluate(
        { logic: 'and', conditions: [...] },
        formManager.getAllRawValues()
      )  // → false ❌ (因为还没勾选"是否需要上门")
    }
  }
})

// 3. Vue 自动重新渲染
<el-form-item v-if="fieldStates['是否需要上门'].visible">
  <!-- 显示 -->
</el-form-item>

<el-form-item v-if="fieldStates['上门地址'].visible">
  <!-- 隐藏 -->
</el-form-item>
```

---

## 与旧版本对比

| 特性 | 旧版本 | 新版本 | 改进 |
|-----|-------|-------|------|
| **数据管理** | 分散存储，手动传递 | 集中管理，自动响应 | ⭐⭐⭐⭐⭐ |
| **组件互联** | 难以访问其他字段 | 任意访问和更新 | ⭐⭐⭐⭐⭐ |
| **条件渲染** | 只支持 `required_if` | 支持复杂条件表达式 | ⭐⭐⭐⭐⭐ |
| **回调上下文** | 手动构建 | 自动传递完整数据 | ⭐⭐⭐⭐⭐ |
| **字段联动** | 分散在各处 | 统一管理（声明式 + 监听） | ⭐⭐⭐⭐⭐ |
| **List 嵌套** | 递归查找，复杂 | 每行独立 manager | ⭐⭐⭐⭐ |
| **代码量** | 8000+ 行 | 预计 2000-3000 行 | ⭐⭐⭐⭐⭐ |
| **可维护性** | 难以理解和修改 | 结构清晰，易于扩展 | ⭐⭐⭐⭐⭐ |

---

## 实现路线图

### Phase 1: 核心基础（优先级：🔥 最高）
- [ ] `FieldValue` 类型定义
- [ ] `FieldConfig` 类型定义（包含 validation、conditions、linkage）
- [ ] `ReactiveFormDataManager` 基础实现
  - 数据存储（reactive Map）
  - 数据读写（getValue/setValue）
  - 监听机制（watch/batchUpdate）
- [ ] 基础 Widget（Input、Textarea、Number、Checkbox）

**预计时间：** 1-1.5周  
**为什么最重要：** 这是整个架构的基础，没有这个啥都做不了

### Phase 2: 条件渲染与核心验证（优先级：🔥 最高）
- [ ] `ConditionEvaluator` 实现
  - 条件显示/隐藏（`conditions.visible`）
  - 条件必填（`conditions.required`）
  - 支持 `eq`, `ne`, `in` 等操作符
- [ ] `ValidatorEngine` 核心实现（简化版）
  - `required` - 必填 🔥
  - `min` / `max` - 长度/值限制 🔥
  - `oneof` - 枚举值 🔥
  - `required_if` - 条件必填 🔥
- [ ] 字段联动配置（基础版）
- [ ] 自动清空隐藏字段

**预计时间：** 1周  
**为什么最重要：** 
- 条件渲染影响用户体验（字段显示/隐藏）
- 核心验证覆盖 90% 场景（后端会兜底）

### Phase 3: Select 组件与回调（优先级：⭐ 高）
- [ ] `SelectWidget` 实现（最重要的 Widget）
- [ ] `CallbackManager` 基础实现
- [ ] `OnSelectFuzzy` 回调（自动传递完整上下文）
- [ ] 模糊搜索对话框组件
- [ ] displayInfo 显示

**预计时间：** 1周  
**为什么重要：** 
- Select 是最常用的组件
- 回调是与后端交互的核心
- 级联选择依赖 OnSelectFuzzy

### Phase 4: Table 渲染与 CRUD（优先级：⭐ 高）
- [ ] `TableRenderer` 优化（已有基础）
- [ ] Table CRUD 回调（OnTableAddRow, OnTableUpdateRow, OnTableDeleteRows）
- [ ] FormDialog 优化（集成验证和条件渲染）
- [ ] table_permission 权限控制

**预计时间：** 0.5周  
**为什么重要：** Table 是另一个核心模板类型

### Phase 5: List 与嵌套（优先级：⭐ 中）
- [ ] `ListWidget` 实现
- [ ] 子 FormDataManager（每行独立管理）
- [ ] 递归渲染支持
- [ ] List 内回调支持（Select 等）

**预计时间：** 1-1.5周  
**为什么重要：** 收银台等复杂场景需要 List 嵌套

### Phase 6: 聚合统计（优先级：⭐ 中）
- [ ] `ExpressionParser` 实现
- [ ] 统计表达式解析（sum, avg, count）
- [ ] 实时计算和显示
- [ ] 支持嵌套计算（sum(价格,*数量,*0.9)）

**预计时间：** 1周  
**为什么重要：** 订单、收银台场景需要实时计算

### Phase 7: 扩展验证器（优先级：💡 低，按需）
- [ ] `email` / `url` 验证器
- [ ] `numeric` 验证器
- [ ] 跨字段验证（`eqfield`, `gtfield`）
- [ ] 其他 Go validator/v10 验证器

**预计时间：** 按需添加，每个验证器 0.1-0.2 天  
**为什么较低：** 后端会兜底，前端验证不急

### Phase 8: 高级 Widget（优先级：💡 低，按需）
- [ ] DatePicker / DateTimePicker
- [ ] FileUpload（简化版）
- [ ] Switch / Radio / CheckboxGroup
- [ ] RichText（如果需要）

**预计时间：** 按需添加，每个 Widget 0.5-1 天  
**为什么较低：** 不是核心功能，需要时再做

---

## 总时间预估

- **Phase 1-4（核心功能）**：约 3.5-4 周
- **Phase 5-6（重要功能）**：约 2-2.5 周
- **Phase 7-8（扩展功能）**：按需添加

**预计 6-8 周完成核心功能 + 重要功能**

---

## 技术栈

- **Vue 3** - 框架
- **TypeScript** - 类型系统
- **Element Plus** - UI 组件库
- **Axios** - HTTP 请求
- **Pinia** - 状态管理（如果需要全局状态）

---

## 注意事项

### ⚠️ 不要做的事情

1. **不要**在 Widget 中直接修改 `formData`
   - ✅ 使用 `onChange` / `updateField`
   - ❌ 直接操作 `formData[field.code] = value`

2. **不要**在回调中手动构建上下文数据
   - ✅ 使用 `formManager.getAllRawValues()`
   - ❌ 手动收集 `{ field1: value1, field2: value2 }`

3. **不要**在验证规则中混入条件逻辑
   - ✅ 使用 `conditions.required`
   - ❌ 在 `validation` 中写 `required_if=...`

4. **不要**为了兼容旧版本而妥协架构
   - ✅ 全新设计，不留债务
   - ❌ 保留旧版本的混乱逻辑

### ✅ 最佳实践

1. **始终使用 FieldValue** - 所有字段值都应该是 `FieldValue` 结构
2. **响应式优先** - 使用 `computed`/`watch` 而不是手动触发更新
3. **声明式配置** - 优先使用配置（`conditions`、`linkage`），而不是命令式代码
4. **类型安全** - 禁止使用 `any`，所有类型严格定义
5. **单元测试** - 每个模块都应该有单元测试

---

## 总结

### ✅ 架构优势

| 特性 | 优势 | 说明 |
|-----|-----|-----|
| **简单为主** | ⭐⭐⭐⭐⭐ | 核心功能够用就行，不过度设计 |
| **后端兜底** | ⭐⭐⭐⭐⭐ | 前端验证只是提升体验，不是强依赖 |
| **渐进式实现** | ⭐⭐⭐⭐⭐ | 先做核心，后续按需扩展 |
| **易于扩展** | ⭐⭐⭐⭐⭐ | 新增验证器/Widget 简单注册即可 |
| **代码量** | ⭐⭐⭐⭐⭐ | 从 8000 行降到 2000-3000 行 |
| **可维护性** | ⭐⭐⭐⭐⭐ | 结构清晰，职责明确 |

### 🎯 核心设计理念

1. **简单够用** - 核心功能覆盖 90% 场景，不实现用不到的功能
2. **后端兜底** - 前端验证失败不影响后端验证，放心简化
3. **留扩展空间** - 架构支持扩展，需要时简单添加
4. **快速上线** - 核心功能 3-4 周即可完成

### 📊 与旧版本对比

| 维度 | 旧版本 | 新版本 | 说明 |
|-----|-------|-------|-----|
| **代码量** | 8000+ 行 | 2000-3000 行 | ⬇️ 70% |
| **验证系统** | 不完整 | 核心 5 个 + 扩展 | 够用就行 |
| **实现时间** | 未知 | 6-8 周 | 可控 |
| **可维护性** | 差 | 优秀 | 结构清晰 |
| **扩展性** | 难 | 易 | 简单注册 |

### 🚀 准备开始实现？

**架构设计已经完成，并且已经简化到"简单够用"！**

- ✅ 核心数据结构清晰
- ✅ 响应式数据管理完善
- ✅ 条件渲染系统强大
- ✅ 验证系统实用（5 个核心验证器）
- ✅ Widget 工厂可扩展
- ✅ 回调系统灵活

**现在可以开始 Phase 1 的实现了！** 🎉

