# 用户信息缓存优化策略

## 概述

用户信息缓存 Store 实现了两个重要的优化策略，以提升用户体验和系统性能：

1. **懒加载刷新**：不过期缓存不会主动刷新，只有真正使用时发现过期才刷新
2. **降级策略**：如果接口响应慢或失败，先使用过期缓存值，不阻塞用户

## 1. 懒加载刷新策略

### 问题背景

在大量用户信息缓存的情况下（例如1000个用户），如果所有缓存同时过期，定时批量刷新会导致：
- 一次性发起大量请求，对服务器造成巨大压力
- 用户等待时间长，体验差
- 资源浪费（很多用户信息可能不会被使用）

### 解决方案

**懒加载刷新**：不过期缓存不会主动刷新，只有真正使用时发现过期才刷新。

#### 实现方式

1. **移除定时批量刷新**：不再定时清除所有过期缓存
2. **按需刷新**：只有在 `batchGetUserInfo()` 被调用时，才检查并刷新本次查询涉及的用户
3. **保留过期缓存**：过期缓存不会立即删除，保留在缓存中作为降级值

#### 代码实现

```typescript
// 🔥 懒加载：只清除本次查询涉及的过期缓存，不批量清除所有过期缓存
clearExpiredCacheForUsernames(uniqueUsernames)

// 过期缓存不会立即删除，而是作为降级值使用
if (cacheItem && isCacheExpired(cacheItem)) {
  // 🔥 缓存过期，先收集起来，作为降级值
  expiredUsers.push({ username, user: cacheItem.user })
  // 也需要刷新
  if (!loadingUsernames.value.has(username)) {
    uncachedUsernames.push(username)
  }
}
```

#### 优势

- ✅ **减少服务器压力**：只刷新真正使用的用户信息
- ✅ **提升性能**：避免不必要的批量刷新
- ✅ **节省资源**：不使用的用户信息不会刷新

## 2. 降级策略

### 问题背景

用户信息接口可能出现以下情况：
- 响应慢（网络延迟、服务器负载高）
- 接口挂掉（服务器故障、网络问题）
- 超时（超过合理等待时间）

如果接口慢或失败，用户会看到：
- 加载时间长，体验差
- 显示错误或空白，影响使用
- 阻塞其他操作

### 解决方案

**降级策略**：如果接口响应慢（超过300ms）或失败，先使用过期缓存值，不阻塞用户，后台异步刷新。

#### 实现方式

1. **超时机制**：接口超过 300ms 未返回，立即使用过期缓存
2. **后台刷新**：使用过期缓存后，后台继续等待接口返回，更新缓存
3. **失败降级**：接口失败时，使用过期缓存，不报错

#### 代码实现

```typescript
// 🔥 超时降级：如果接口超过300ms未返回，先返回过期缓存，后台继续刷新
const timeoutPromise = new Promise<UserInfo[]>((resolve) => {
  setTimeout(() => {
    console.log(`[UserInfoStore] 接口超时（${API_TIMEOUT}ms），使用过期缓存（降级策略）`)
    // 返回过期缓存，不阻塞用户
    resolve(expiredResult)
    // 后台继续等待接口返回（不阻塞）
    fetchPromise.then(users => {
      console.log(`[UserInfoStore] 后台刷新完成，更新缓存`)
      // 缓存已更新，下次获取时会使用新值
    }).catch(() => {
      // 刷新失败不影响，继续使用过期缓存
    })
  }, API_TIMEOUT)
})

try {
  // 如果接口在超时时间内返回，使用新数据
  return await Promise.race([fetchPromise, timeoutPromise])
} catch (error) {
  // 🔥 降级策略：如果接口失败，返回过期缓存
  console.warn('[UserInfoStore] 接口失败，使用过期缓存（降级策略）')
  return expiredResult
}
```

#### 优势

- ✅ **提升用户体验**：不阻塞用户，快速显示内容
- ✅ **容错性强**：接口失败不影响使用
- ✅ **后台更新**：接口返回后自动更新，下次使用新值

## 3. 缓存过期时间

- **默认过期时间**：5 分钟
- **超时时间**：300ms（超过此时间使用过期缓存）

## 4. 使用场景示例

### 场景1：正常情况（缓存未过期）

```
用户请求 → 检查缓存 → 缓存有效 → 直接返回（不调用接口）
```

### 场景2：缓存过期，接口正常

```
用户请求 → 检查缓存 → 缓存过期 → 调用接口 → 返回新数据 → 更新缓存
```

### 场景3：缓存过期，接口慢（超过300ms）

```
用户请求 → 检查缓存 → 缓存过期 → 调用接口
  ↓
300ms 超时 → 立即返回过期缓存（不阻塞用户）
  ↓
后台继续等待 → 接口返回 → 更新缓存 → 下次使用新值
```

### 场景4：缓存过期，接口失败

```
用户请求 → 检查缓存 → 缓存过期 → 调用接口 → 接口失败
  ↓
降级策略 → 返回过期缓存（不报错，不阻塞用户）
```

### 场景5：大量用户信息过期，但只使用部分

```
1000个用户信息过期
  ↓
用户只查看10个用户
  ↓
只刷新这10个用户（懒加载刷新）
  ↓
其他990个用户不刷新（节省资源）
```

## 5. 配置参数

可以在 `web/src/stores/userInfo.ts` 中修改：

```typescript
// 缓存过期时间（毫秒），默认5分钟
const CACHE_EXPIRY_TIME = 5 * 60 * 1000  // 5分钟

// 🔥 降级策略：接口超时时间（毫秒），超过此时间使用过期缓存
const API_TIMEOUT = 300  // 300ms
```

## 6. 监控和调试

### 查看缓存统计

```javascript
// 在控制台查看缓存统计
window.__stores__.userInfoStore.getCacheStats()
// 返回：{ total: 4, valid: 4, expired: 0, loading: 0 }
```

### 手动刷新缓存

```javascript
// 刷新所有缓存
window.__stores__.userInfoStore.refreshCache()

// 刷新指定用户
window.__stores__.userInfoStore.refreshCache(['luobei', 'sina'])
```

### 清除缓存

```javascript
// 清除所有缓存
window.__stores__.userInfoStore.clearCache()

// 清除指定用户
window.__stores__.userInfoStore.clearUserCache(['luobei'])
```

## 7. 注意事项

1. **过期缓存不是洪水猛兽**：过期缓存仍然有用，可以作为降级值使用
2. **后台刷新不阻塞**：接口慢时，先返回过期值，后台继续刷新
3. **持久化包括过期项**：localStorage 中会保存过期缓存，用于降级策略
4. **懒加载减少压力**：只刷新真正使用的用户信息，避免批量刷新

## 8. 性能优化效果

### 优化前
- 定时批量刷新所有过期缓存
- 接口慢时阻塞用户
- 接口失败时显示错误

### 优化后
- ✅ 只刷新真正使用的用户信息（懒加载）
- ✅ 接口慢时使用过期缓存，不阻塞用户（降级策略）
- ✅ 接口失败时使用过期缓存，不报错（降级策略）
- ✅ 后台异步刷新，下次使用新值

## 9. 总结

通过**懒加载刷新**和**降级策略**，用户信息缓存 Store 实现了：
- 🚀 **性能优化**：减少不必要的刷新，降低服务器压力
- 💪 **容错性强**：接口慢或失败不影响用户体验
- ⚡ **响应快速**：超时后立即返回，不阻塞用户
- 🔄 **后台更新**：接口返回后自动更新，保证数据新鲜度

