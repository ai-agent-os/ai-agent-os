# 服务地址发现方案分析

## 📋 需求背景

SDK 在运行时需要知道各个服务的地址（特别是存储服务），以便进行文件上传等操作。

## 🔍 方案对比

### 方案 1：读取 configs 文件夹（你的方案）

**实现方式**：
- 每个程序启动时读取 `configs/api-gateway.yaml`
- 解析路由配置，提取服务地址
- 直接使用配置中的地址

**优点**：
- ✅ 配置集中，易于管理
- ✅ 无需网络请求，启动快
- ✅ 配置来源明确

**缺点**：
- ❌ **容器化部署问题**：SDK 运行在容器内，可能无法访问宿主机 `configs` 文件夹
- ❌ **路径依赖**：不同部署场景，`configs` 路径可能不同（开发环境 vs 生产环境）
- ❌ **配置更新问题**：如果网关配置变更，需要重启所有服务才能生效
- ❌ **耦合度高**：所有服务都依赖网关配置文件，增加了耦合
- ❌ **权限问题**：容器内可能没有读取权限

**适用场景**：
- 单机部署（所有服务在同一台机器）
- 开发环境
- 配置文件路径固定

---

### 方案 2：通过网关配置接口获取（推荐）⭐

**实现方式**：
- 网关提供 `/api/v1/config` 接口（已实现）
- SDK/Runtime 启动时调用该接口获取服务地址
- 缓存配置，定期刷新

**优点**：
- ✅ **解耦合**：服务不依赖配置文件路径
- ✅ **容器化友好**：通过 HTTP 接口，无需文件系统访问
- ✅ **动态更新**：配置变更后，服务下次刷新时自动获取新配置
- ✅ **统一入口**：所有服务都通过网关地址，无需知道具体端口
- ✅ **部署灵活**：适合各种部署场景（单机、容器、K8s）

**缺点**：
- ⚠️ 需要网络请求（可在启动时缓存）
- ⚠️ 网关必须启动后才能获取配置（但这是合理的依赖）

**实现示例**：
```go
// SDK 启动时
gatewayURL := os.Getenv("GATEWAY_URL") // 或从配置读取
if gatewayURL == "" {
    gatewayURL = "http://localhost:9090" // 默认值
}

// 获取服务配置
config, err := fetchServiceConfig(gatewayURL)
if err != nil {
    // 降级方案：使用环境变量或默认值
}

// 缓存配置
storageURL := config["storage"] // http://localhost:9090
```

---

### 方案 3：环境变量注入

**实现方式**：
- 通过环境变量注入服务地址
- SDK 从环境变量读取

**优点**：
- ✅ 容器化友好（K8s、Docker 都支持）
- ✅ 配置灵活，不同环境不同配置
- ✅ 无需网络请求

**缺点**：
- ❌ 需要手动配置环境变量
- ❌ 配置分散，不易管理
- ❌ 容器启动时需要知道所有服务地址

**适用场景**：
- 容器化部署（K8s、Docker Compose）
- CI/CD 环境

---

### 方案 4：混合方案（推荐用于生产）⭐

**实现方式**：
1. **优先**：通过网关配置接口获取（方案 2）
2. **降级**：如果网关不可用，使用环境变量
3. **默认值**：如果都没有，使用硬编码默认值（仅开发环境）

**优点**：
- ✅ 结合了方案 2 和 3 的优点
- ✅ 容错性强，有降级方案
- ✅ 适合各种部署场景

**实现示例**：
```go
func GetServiceURL(serviceName string) string {
    // 1. 优先从网关配置接口获取
    if gatewayURL := os.Getenv("GATEWAY_URL"); gatewayURL != "" {
        if config, err := fetchServiceConfig(gatewayURL); err == nil {
            if url, ok := config[serviceName]; ok {
                return url
            }
        }
    }
    
    // 2. 降级：使用环境变量
    if envURL := os.Getenv(fmt.Sprintf("%s_URL", strings.ToUpper(serviceName))); envURL != "" {
        return envURL
    }
    
    // 3. 默认值（仅开发环境）
    return getDefaultURL(serviceName)
}
```

---

## 🎯 推荐方案

### 开发环境：方案 2（网关配置接口）
- 简单直接，无需配置环境变量
- 网关统一管理配置

### 生产环境：方案 4（混合方案）
- 优先使用网关配置接口
- 环境变量作为降级方案
- 保证高可用性

---

## 📝 实现建议

### 1. 增强网关配置接口

**当前接口** (`/api/v1/config`)：
```json
{
  "api": "http://localhost:9090",
  "storage": "http://localhost:9090",
  "version": "v1.0.0"
}
```

**建议增强**：
```json
{
  "gateway": "http://localhost:9090",
  "services": {
    "storage": {
      "url": "http://localhost:9090",
      "path": "/api/v1/storage",
      "direct_url": "http://localhost:9092"  // 直接地址（用于 SDK 内部调用）
    },
    "app": {
      "url": "http://localhost:9090",
      "path": "/api",
      "direct_url": "http://localhost:9091"
    }
  },
  "version": "v1.0.0"
}
```

### 2. SDK 配置获取库

创建一个统一的配置获取库：

```go
// pkg/serviceconfig/service_config.go
package serviceconfig

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "os"
    "sync"
    "time"
)

var (
    configCache *ServiceConfig
    configMu    sync.RWMutex
    lastUpdate  time.Time
    cacheTTL    = 5 * time.Minute
)

type ServiceConfig struct {
    Gateway  string             `json:"gateway"`
    Services map[string]Service `json:"services"`
    Version  string             `json:"version"`
}

type Service struct {
    URL       string `json:"url"`        // 通过网关的地址
    Path      string `json:"path"`       // 路径前缀
    DirectURL string `json:"direct_url"` // 直接地址（可选）
}

// GetServiceURL 获取服务地址
// 优先返回直接地址（如果可用），否则返回网关地址
func GetServiceURL(serviceName string) (string, error) {
    config, err := GetConfig()
    if err != nil {
        return "", err
    }
    
    service, ok := config.Services[serviceName]
    if !ok {
        return "", fmt.Errorf("service %s not found", serviceName)
    }
    
    // 优先使用直接地址（SDK 内部调用）
    if service.DirectURL != "" {
        return service.DirectURL, nil
    }
    
    // 降级：使用网关地址
    return service.URL, nil
}

// GetConfig 获取服务配置（带缓存）
func GetConfig() (*ServiceConfig, error) {
    configMu.RLock()
    if configCache != nil && time.Since(lastUpdate) < cacheTTL {
        configMu.RUnlock()
        return configCache, nil
    }
    configMu.RUnlock()
    
    // 刷新配置
    return refreshConfig()
}

func refreshConfig() (*ServiceConfig, error) {
    // 1. 优先从网关获取
    gatewayURL := getGatewayURL()
    if gatewayURL != "" {
        config, err := fetchFromGateway(gatewayURL)
        if err == nil {
            configMu.Lock()
            configCache = config
            lastUpdate = time.Now()
            configMu.Unlock()
            return config, nil
        }
    }
    
    // 2. 降级：从环境变量构建
    return buildFromEnv()
}

func getGatewayURL() string {
    // 优先环境变量
    if url := os.Getenv("GATEWAY_URL"); url != "" {
        return url
    }
    
    // 默认值
    return "http://localhost:9090"
}

func fetchFromGateway(gatewayURL string) (*ServiceConfig, error) {
    url := fmt.Sprintf("%s/api/v1/config", gatewayURL)
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var config ServiceConfig
    if err := json.NewDecoder(resp.Body).Decode(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

func buildFromEnv() (*ServiceConfig, error) {
    // 从环境变量构建配置
    gatewayURL := getGatewayURL()
    config := &ServiceConfig{
        Gateway: gatewayURL,
        Services: make(map[string]Service),
    }
    
    // 存储服务
    if storageURL := os.Getenv("STORAGE_URL"); storageURL != "" {
        config.Services["storage"] = Service{
            URL:       gatewayURL,
            Path:      "/api/v1/storage",
            DirectURL: storageURL,
        }
    }
    
    return config, nil
}
```

### 3. SDK 使用示例

```go
// SDK 中调用存储服务
import "github.com/ai-agent-os/ai-agent-os/pkg/serviceconfig"

func uploadFile(filePath string) error {
    // 获取存储服务地址
    storageURL, err := serviceconfig.GetServiceURL("storage")
    if err != nil {
        return fmt.Errorf("failed to get storage URL: %w", err)
    }
    
    // 调用存储服务
    uploadURL := fmt.Sprintf("%s/api/v1/storage/upload", storageURL)
    // ... 上传文件
}
```

---

## 🔄 迁移路径

1. **第一阶段**：增强网关配置接口，返回详细服务信息
2. **第二阶段**：创建 `serviceconfig` 包，实现配置获取逻辑
3. **第三阶段**：SDK 集成 `serviceconfig` 包
4. **第四阶段**：添加环境变量降级支持（生产环境）

---

## 📊 方案对比总结

| 方案 | 容器化友好 | 配置灵活性 | 动态更新 | 实现复杂度 | 推荐度 |
|------|-----------|-----------|---------|-----------|--------|
| 读取 configs | ❌ | ⭐⭐ | ❌ | ⭐ | ⭐⭐ |
| 网关接口 | ✅ | ⭐⭐⭐ | ✅ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 环境变量 | ✅ | ⭐⭐⭐ | ❌ | ⭐ | ⭐⭐⭐ |
| 混合方案 | ✅ | ⭐⭐⭐ | ✅ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## 💡 最终建议

**推荐使用方案 4（混合方案）**：

1. **开发环境**：优先从网关配置接口获取（简单，无需配置）
2. **生产环境**：优先网关接口，环境变量降级（高可用）
3. **SDK 内部调用**：使用 `direct_url`（绕过网关，性能更好）
4. **外部调用**：使用网关地址（统一入口，安全）

这样既保证了灵活性，又保证了高可用性，适合各种部署场景。

