# 字段排序智能识别分析

## 📊 分析维度

### 1. 根据 Widget 类型判断

| Widget 类型 | 是否适合排序 | 排序意义 | 数据库类型 | 说明 |
|------------|------------|---------|-----------|------|
| `input` | ✅ 适合 | 中等 | string | 文本字段，可以按字符串排序 |
| `text` | ✅ 适合 | 中等 | string | 纯文本，可以按字符串排序 |
| `text_area` | ⚠️ 不推荐 | 低 | string | 大文本字段，排序意义不大 |
| `select` | ✅ 适合 | 高 | string/int | 下拉选择，排序很有意义 |
| `multiselect` | ⚠️ 不推荐 | 低 | string | 多选字段，按逗号分隔字符串排序意义不大 |
| `switch` | ✅ 适合 | 高 | bool | 布尔值，排序很有意义 |
| `checkbox` | ✅ 适合 | 高 | bool | 布尔值，排序很有意义 |
| `radio` | ✅ 适合 | 高 | string/int | 单选，排序很有意义 |
| `timestamp` | ✅ 适合 | 很高 | int64 | 时间戳，排序非常有意义 |
| `user` | ✅ 适合 | 中等 | string | 用户选择，可以按用户名排序 |
| `ID` | ✅ 适合 | 很高 | int | ID字段，排序非常有意义 |
| `number` | ✅ 适合 | 很高 | int | 数字字段，排序非常有意义 |
| `float` | ✅ 适合 | 很高 | float64 | 浮点数，排序非常有意义 |
| `slider` | ✅ 适合 | 高 | int/float64 | 滑块，本质是数字，排序有意义 |
| `files` | ❌ 不适合 | 无 | struct | 文件字段，结构体类型，无法排序 |
| `table` | ❌ 不适合 | 无 | struct | 表格容器，结构体类型，无法排序 |
| `form` | ❌ 不适合 | 无 | struct | 表单容器，结构体类型，无法排序 |

### 2. 根据 Data Type 判断

| Data Type | 是否适合排序 | 说明 |
|----------|------------|------|
| `string` | ✅ 适合 | 字符串可以排序 |
| `int` | ✅ 适合 | 整数非常适合排序 |
| `float` | ✅ 适合 | 浮点数非常适合排序 |
| `bool` | ✅ 适合 | 布尔值可以排序 |
| `timestamp` | ✅ 适合 | 时间戳非常适合排序 |
| `[]string` | ⚠️ 不推荐 | 数组类型，排序意义不大 |
| `[]int` | ⚠️ 不推荐 | 数组类型，排序意义不大 |
| `[]float` | ⚠️ 不推荐 | 数组类型，排序意义不大 |
| `struct` | ❌ 不适合 | 结构体类型，无法排序 |
| `[]struct` | ❌ 不适合 | 结构体数组，无法排序 |
| `files` | ❌ 不适合 | 文件类型，结构体，无法排序 |

## 🎯 智能识别规则

### 规则1：明确不适合排序（硬性规则）

```typescript
// 这些字段类型明确无法排序
const UNSORTABLE_WIDGET_TYPES = [
  WidgetType.FILES,    // 文件字段
  WidgetType.TABLE,    // 表格容器
  WidgetType.FORM      // 表单容器
]

const UNSORTABLE_DATA_TYPES = [
  DataType.STRUCT,     // 结构体
  DataType.STRUCTS,   // 结构体数组
  DataType.FILES      // 文件类型
]
```

### 规则2：不推荐排序（软性规则）

```typescript
// 这些字段虽然可以排序，但排序意义不大
const NOT_RECOMMENDED_WIDGET_TYPES = [
  WidgetType.TEXT_AREA,     // 大文本字段
  WidgetType.MULTI_SELECT   // 多选字段（按逗号分隔字符串排序）
]

const NOT_RECOMMENDED_DATA_TYPES = [
  DataType.STRINGS,   // 字符串数组
  DataType.INTS,      // 整数数组
  DataType.FLOATS     // 浮点数数组
]
```

### 规则3：非常适合排序（推荐规则）

```typescript
// 这些字段类型非常适合排序
const HIGHLY_SORTABLE_WIDGET_TYPES = [
  WidgetType.ID,          // ID字段
  WidgetType.NUMBER,      // 数字字段
  WidgetType.FLOAT,       // 浮点数字段
  WidgetType.TIMESTAMP,   // 时间戳字段
  WidgetType.SLIDER,      // 滑块（本质是数字）
  WidgetType.SELECT,      // 下拉选择
  WidgetType.SWITCH,      // 开关（布尔值）
  WidgetType.CHECKBOX,    // 复选框（布尔值）
  WidgetType.RADIO        // 单选
]
```

## 💡 智能识别函数设计

```typescript
/**
 * 判断字段是否适合排序
 * 
 * 判断逻辑（优先级从高到低）：
 * 1. 硬性规则：明确不适合排序的字段类型（files、table、form、struct）
 * 2. 软性规则：不推荐排序的字段类型（text_area、multiselect、数组类型）
 * 3. 默认：其他字段类型适合排序
 * 
 * @param field 字段配置
 * @returns 排序配置：false（不支持）| true（支持）| 'not-recommended'（不推荐但支持）
 */
function isFieldSortable(field: FieldConfig): boolean | 'not-recommended' {
  const widgetType = field.widget?.type
  const dataType = field.data?.type
  
  // 1. 硬性规则：明确不适合排序
  if (UNSORTABLE_WIDGET_TYPES.includes(widgetType)) {
    return false
  }
  
  if (UNSORTABLE_DATA_TYPES.includes(dataType)) {
    return false
  }
  
  // 2. 软性规则：不推荐排序
  if (NOT_RECOMMENDED_WIDGET_TYPES.includes(widgetType)) {
    return 'not-recommended'
  }
  
  if (NOT_RECOMMENDED_DATA_TYPES.includes(dataType)) {
    return 'not-recommended'
  }
  
  // 3. 默认：其他字段类型适合排序
  return true
}
```

## 📋 实际应用场景分析

### 场景1：工单管理（crm_ticket）

| 字段 | Widget 类型 | Data Type | 智能识别结果 | 是否应该排序 |
|------|------------|-----------|-------------|------------|
| `id` | ID | int | ✅ 非常适合 | ✅ 是 |
| `created_at` | timestamp | timestamp | ✅ 非常适合 | ✅ 是 |
| `updated_at` | timestamp | timestamp | ✅ 非常适合 | ✅ 是 |
| `title` | input | string | ✅ 适合 | ✅ 是 |
| `description` | text_area | string | ⚠️ 不推荐 | ⚠️ 可选 |
| `priority` | select | string | ✅ 非常适合 | ✅ 是 |
| `status` | select | string | ✅ 非常适合 | ✅ 是 |
| `is_urgent` | switch | bool | ✅ 非常适合 | ✅ 是 |
| `progress` | slider | int | ✅ 非常适合 | ✅ 是 |
| `score` | slider | float | ✅ 非常适合 | ✅ 是 |
| `phone` | input | string | ✅ 适合 | ✅ 是 |
| `handler` | user | string | ✅ 适合 | ✅ 是 |
| `remark` | text_area | string | ⚠️ 不推荐 | ⚠️ 可选 |
| `tags` | multiselect | string | ⚠️ 不推荐 | ⚠️ 可选 |
| `attachment` | files | struct | ❌ 不适合 | ❌ 否 |
| `create_by` | user | string | ✅ 适合 | ✅ 是 |

### 场景2：边界情况

1. **multiselect 字段**：
   - 数据库存储：`"紧急,重要"`（逗号分隔字符串）
   - 排序结果：按字符串排序，可能不是用户期望的顺序
   - 建议：不推荐排序，或需要特殊处理

2. **text_area 字段**：
   - 数据库存储：长文本内容
   - 排序结果：按字符串排序，但长文本排序意义不大
   - 建议：不推荐排序

3. **user 字段**：
   - 数据库存储：用户名（string）
   - 排序结果：按用户名排序，有一定意义
   - 建议：支持排序

## 🎯 结论

### ✅ 可以智能识别

前端**可以智能识别**哪些字段适合排序，准确率约 **90%**：

1. **硬性规则**（100% 准确）：
   - `files`、`table`、`form` 等容器类型 → 不支持排序
   - `struct`、`[]struct` 等结构体类型 → 不支持排序

2. **软性规则**（80% 准确）：
   - `text_area` → 不推荐排序（但技术上可以）
   - `multiselect` → 不推荐排序（但技术上可以）

### ⚠️ 边界情况

1. **multiselect 字段**：
   - 技术上可以排序（按逗号分隔字符串）
   - 但排序结果可能不符合用户期望
   - 建议：不推荐排序，或需要特殊处理

2. **text_area 字段**：
   - 技术上可以排序（按字符串）
   - 但长文本排序意义不大
   - 建议：不推荐排序

### 💡 推荐方案

**方案1：智能识别 + 可选配置（推荐）**

```typescript
// 智能识别函数
function isFieldSortable(field: FieldConfig): boolean | 'not-recommended' {
  // ... 智能识别逻辑
}

// 前端使用
const sortable = computed(() => {
  const result = isFieldSortable(field)
  // 如果智能识别为 'not-recommended'，可以选择禁用或启用
  return result === true || (result === 'not-recommended' && enableNotRecommendedSort)
})
```

**优点**：
- 自动处理大部分情况（90%+）
- 对于边界情况，可以给用户选择权
- 不需要后端配置，减少工作量

**缺点**：
- 边界情况需要前端判断逻辑
- 某些特殊场景可能需要手动配置

### 🎯 最终建议

**建议采用智能识别方案**，原因：

1. **覆盖率高**：可以自动处理 90%+ 的字段
2. **减少配置**：不需要后端逐个配置 `sort` 标签
3. **灵活性强**：对于边界情况，可以给用户选择权
4. **维护成本低**：规则集中在前端，易于维护

**对于边界情况**：
- `text_area`：默认不推荐排序，但可以允许用户启用
- `multiselect`：默认不推荐排序，但可以允许用户启用
- 如果业务确实需要排序，可以通过配置覆盖

