# 路由系统代码重构分析

## 概述

在改造路由 URL 唯一化的同时，进行代码重构和优化，提升代码质量、可维护性和可测试性。

## 当前代码问题分析

### 1. 代码重复问题 🔴 严重

#### 1.1 GET/POST/PUT/DELETE 函数重复

**位置**：`sdk/agent-app/app/register.go:131-169`

**问题**：
```go
func GET(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    register(router, "GET", handleFunc, templater, opts)
}

func POST(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    register(router, "POST", handleFunc, templater, opts)
}
// ... PUT、DELETE 完全一样
```

**重构方案**：
- 使用泛型或统一函数，通过 method 参数区分
- 或者使用函数工厂模式

#### 1.2 RouterGroup 的 GET/POST/PUT/DELETE 重复

**位置**：`sdk/agent-app/app/register.go:75-89`

**问题**：4 个函数只是 method 不同，逻辑完全一样

**重构方案**：
- 合并为一个 `Register` 方法，接受 method 参数
- 或者使用函数工厂

#### 1.3 initRouter 中 /_callback 注册重复

**位置**：`sdk/agent-app/app/register.go:186-213`

**问题**：同一个路由注册了 4 次，只是 method 不同

**重构方案**：
- 只注册一次，method 设为 "ANY"
- 使用循环注册（但改造后 URL 唯一，只能注册一次）

#### 1.4 CallbackRouter 中错误处理重复

**位置**：`sdk/agent-app/app/register.go:242-327`

**问题**：每个 case 都有相似的错误处理和日志记录

**重构方案**：
- 提取公共的错误处理函数
- 使用策略模式或映射表

### 2. 职责不清问题 🟡 中等

#### 2.1 register.go 文件职责过多

**当前包含**：
- RouterGroup 相关逻辑
- 路由注册逻辑
- CallbackRouter 处理逻辑
- 系统路由初始化

**重构方案**：
- 拆分文件：
  - `router_group.go` - RouterGroup 相关
  - `router_registry.go` - 路由注册逻辑
  - `callback_handler.go` - CallbackRouter 处理
  - `system_router.go` - 系统路由初始化

#### 2.2 app.go 文件职责过多

**当前包含**：
- App 结构体定义
- NATS 连接管理
- 路由管理
- 生命周期管理
- 消息处理

**重构方案**：
- 拆分职责：
  - `app.go` - App 核心结构
  - `nats_manager.go` - NATS 连接管理
  - `lifecycle.go` - 生命周期管理
  - `message_handler.go` - 消息处理

#### 2.3 router.go 文件太小

**当前**：只有 routerInfo 结构体和几个方法

**重构方案**：
- 合并到 `router_registry.go`
- 或者扩展 router.go，包含所有路由相关逻辑

### 3. 全局变量依赖问题 🔴 严重

#### 3.1 全局 app 变量

**位置**：`sdk/agent-app/app/app.go:25`

**问题**：
```go
var (
    app      *App
    initOnce sync.Once
    initErr  error
)
```

**影响**：
- 难以测试（无法 mock）
- 并发安全问题（虽然用了 sync.Once，但增加了复杂度）
- 依赖注入困难

**重构方案**：
- 使用依赖注入，将 App 实例作为参数传递
- 或者使用接口，便于测试和 mock

#### 3.2 register 函数依赖全局 app

**位置**：`sdk/agent-app/app/register.go:110`

**问题**：
```go
func register(router string, method string, ...) {
    if app == nil {
        initApp()
    }
    app.routerInfo[...] = ...
}
```

**重构方案**：
- 改为 `(a *App) register(...)` 方法
- 或者通过参数传递 App 实例

### 4. 命名问题 🟡 中等

#### 4.1 routerInfo 接收者命名

**位置**：`sdk/agent-app/app/router.go:24`

**问题**：
```go
func (a *routerInfo) BuildSourceCodeFilePath() string {
    // 接收者用 a，容易和 App 混淆
}
```

**重构方案**：
- 改为 `r` 或 `ri`：`func (r *routerInfo) ...`

#### 4.2 函数命名不够清晰

**问题**：
- `getCode()` - 应该叫 `GetFunctionCode()` 或 `GetCode()`
- `register()` - 应该叫 `registerRoute()` 或改为方法
- `routerKey()` - 应该叫 `buildRouterKey()` 或 `normalizeRouterKey()`

### 5. 错误处理不一致 🟡 中等

#### 5.1 错误处理方式混乱

**问题**：
- 有些返回 error
- 有些直接 panic
- 有些只记录日志，不返回错误
- 有些返回 nil，有些返回错误

**示例**：
```go
// register.go:118 - 只记录日志，不返回错误
if app == nil {
    logger.Errorf(...)
    return  // 静默失败
}

// register.go:230 - 返回错误
router, err := a.getRouter(req.Router, req.Method)
if err != nil {
    return err
}
```

**重构方案**：
- 统一错误处理策略
- 定义错误类型
- 使用错误包装

### 6. 代码组织问题 🟡 中等

#### 6.1 文件组织混乱

**当前结构**：
```
app/
  - app.go (太大，职责不清)
  - register.go (太大，职责不清)
  - router.go (太小，应该合并)
  - handle.go
  - context.go
  - ...
```

**重构方案**：
```
app/
  - app.go (App 核心结构)
  - router/
    - registry.go (路由注册)
    - router_info.go (routerInfo 定义和方法)
    - system.go (系统路由)
  - router_group/
    - router_group.go (RouterGroup 定义)
    - register.go (注册方法)
  - callback/
    - handler.go (CallbackRouter)
    - types.go (回调类型定义)
  - handler/
    - message.go (消息处理)
    - request.go (请求处理)
  - context/
    - context.go (Context 定义)
    - bind.go (ShouldBind 相关)
  - ...
```

### 7. 魔法值和硬编码 🟡 中等

#### 7.1 HTTP Method 常量使用不一致

**位置**：多处

**问题**：
```go
// 有些地方用常量
case MethodPost:

// 有些地方用字符串
case "POST":
switch method {
case "GET":
case "POST":
```

**重构方案**：
- 统一使用常量
- 定义 Method 类型

#### 7.2 路径拼接硬编码

**位置**：多处

**问题**：
```go
fullRouter := fmt.Sprintf("/%s/%s", packagePath, strings.Trim(router, "/"))
filePath := fmt.Sprintf("/app/code/api/%s.go", groupCode)
```

**重构方案**：
- 提取为常量或配置
- 使用 path.Join

### 8. 类型安全问题 🟡 中等

#### 8.1 Method 类型

**问题**：Method 是 string，容易拼写错误

**重构方案**：
```go
type HTTPMethod string

const (
    MethodGet    HTTPMethod = "GET"
    MethodPost   HTTPMethod = "POST"
    MethodPut    HTTPMethod = "PUT"
    MethodDelete HTTPMethod = "DELETE"
    MethodAny    HTTPMethod = "ANY"  // 新增，用于 /_callback
)
```

#### 8.2 CallbackType 类型

**问题**：CallbackType 是 string，容易拼写错误

**重构方案**：
- 定义类型和常量

### 9. 可测试性问题 🔴 严重

#### 9.1 全局变量导致无法测试

**问题**：依赖全局 `app` 变量，无法 mock

**重构方案**：
- 使用依赖注入
- 定义接口

#### 9.2 函数耦合度高

**问题**：函数之间耦合度高，难以单独测试

**重构方案**：
- 提取接口
- 依赖注入
- 减少副作用

### 10. 代码注释和文档 🟢 轻微

#### 10.1 缺少文档注释

**问题**：很多函数没有文档注释

**重构方案**：
- 为所有公共函数添加文档注释
- 使用 godoc 格式

#### 10.2 注释过时

**问题**：有些注释已经过时或不准确

**重构方案**：
- 更新所有注释
- 删除无用注释

## 重构方案

### 阶段 1：核心改造 + 基础重构

#### 1.1 路由 URL 唯一化改造
- ✅ 修改 `routerKey` 函数
- ✅ 修改 `getRouter` 函数
- ✅ 修改 `register` 函数
- ✅ 修改 `initRouter` 函数

#### 1.2 消除代码重复
- ✅ 合并 GET/POST/PUT/DELETE 函数
- ✅ 合并 RouterGroup 的 GET/POST/PUT/DELETE 方法
- ✅ 简化 initRouter（/_callback 只注册一次）
- ✅ 提取 CallbackRouter 公共错误处理

#### 1.3 改进命名
- ✅ routerInfo 接收者改为 `r`
- ✅ 函数命名更清晰
- ✅ 统一常量使用

### 阶段 2：职责分离

#### 2.1 文件拆分
- ✅ 拆分 `register.go`
- ✅ 拆分 `app.go`（如果需要）
- ✅ 合并或扩展 `router.go`

#### 2.2 类型定义
- ✅ 定义 HTTPMethod 类型
- ✅ 定义 CallbackType 类型
- ✅ 提取公共接口

### 阶段 3：依赖注入和可测试性

#### 3.1 消除全局变量
- ✅ 将 `register` 改为 App 方法
- ✅ 通过参数传递 App 实例
- ✅ 使用依赖注入

#### 3.2 接口定义
- ✅ 定义 RouterRegistry 接口
- ✅ 定义 RouterHandler 接口
- ✅ 便于测试和 mock

### 阶段 4：错误处理和文档

#### 4.1 统一错误处理
- ✅ 定义错误类型
- ✅ 统一错误处理策略
- ✅ 使用错误包装

#### 4.2 文档完善
- ✅ 添加函数文档注释
- ✅ 更新过时注释
- ✅ 添加示例代码

## 详细重构清单

### 文件：`sdk/agent-app/app/register.go`

#### 问题 1：GET/POST/PUT/DELETE 函数重复

**重构前**：
```go
func GET(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    register(router, "GET", handleFunc, templater, opts)
}
// ... POST、PUT、DELETE 完全一样
```

**重构后**：
```go
// 方案 A：统一函数
func RegisterRoute(method string, router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    register(router, method, handleFunc, templater, opts)
}

// 保留便捷函数（内部调用 RegisterRoute）
func GET(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    RegisterRoute("GET", router, handleFunc, templater, options...)
}
// ... POST、PUT、DELETE 类似
```

#### 问题 2：RouterGroup 方法重复

**重构前**：
```go
func (p *RouterGroup) GET(router string, handleFunc HandleFunc, templater Templater) {
    p.registerWithGroup("GET", router, handleFunc, templater)
}
// ... POST、PUT、DELETE 完全一样
```

**重构后**：
```go
// 方案 A：统一方法
func (p *RouterGroup) Register(method string, router string, handleFunc HandleFunc, templater Templater) {
    p.registerWithGroup(method, router, handleFunc, templater)
}

// 保留便捷方法（内部调用 Register）
func (p *RouterGroup) GET(router string, handleFunc HandleFunc, templater Templater) {
    p.Register("GET", router, handleFunc, templater)
}
// ... POST、PUT、DELETE 类似
```

#### 问题 3：initRouter 重复注册

**重构前**：
```go
func initRouter(a *App) {
    a.routerInfo[routerKey("/_callback", MethodPost)] = &routerInfo{...}
    a.routerInfo[routerKey("/_callback", MethodGet)] = &routerInfo{...}
    a.routerInfo[routerKey("/_callback", MethodDelete)] = &routerInfo{...}
    a.routerInfo[routerKey("/_callback", MethodPut)] = &routerInfo{...}
}
```

**重构后**：
```go
func initRouter(a *App) {
    // 只注册一次，method 设为 "ANY"
    key := routerKey("/_callback")
    if _, exists := a.routerInfo[key]; exists {
        panic(fmt.Errorf("路由 /_callback 已存在，不允许重复注册"))
    }
    
    a.routerInfo[key] = &routerInfo{
        HandleFunc: a.CallbackRouter,
        Router:     "/_callback",
        Method:     "ANY",  // 支持所有 method
        Options:    nil,
        Template:   &FormTemplate{},
    }
}
```

#### 问题 4：CallbackRouter 错误处理重复

**重构前**：
```go
switch req.Type {
case CallbackTypeOnTableAddRow:
    v, ok := router.Template.(*TableTemplate)
    if !ok {
        return errors.New("invalid type of TableTemplate")
    }
    var onTableReq callback.OnTableAddRowReq
    onTableResp, err := v.OnTableAddRow(ctx, &onTableReq)
    if err != nil {
        logger.Errorf(ctx, "callback onTableAddRow router:%s call error:%s", req.Type, err.Error())
        return err
    }
    err = resp.Form(onTableResp).Build()
    if err != nil {
        logger.Errorf(ctx, "callback onTableAddRow  router:%s Build error:%s", req.Type, err.Error())
        return err
    }
    logger.Infof(ctx, "CallbackRouter onTableAddRow success")
    return nil
// ... 其他 case 类似
```

**重构后**：
```go
// 提取公共处理函数
func (a *App) handleTableCallback(
    ctx *Context,
    resp response.Response,
    callbackType string,
    handler func(*Context, *TableTemplate) (interface{}, error),
) error {
    router := ctx.routerInfo
    v, ok := router.Template.(*TableTemplate)
    if !ok {
        return fmt.Errorf("invalid template type for %s: expected TableTemplate", callbackType)
    }
    
    result, err := handler(ctx, v)
    if err != nil {
        logger.Errorf(ctx, "callback %s router:%s call error:%s", callbackType, router.Router, err.Error())
        return err
    }
    
    err = resp.Form(result).Build()
    if err != nil {
        logger.Errorf(ctx, "callback %s router:%s Build error:%s", callbackType, router.Router, err.Error())
        return err
    }
    
    logger.Infof(ctx, "CallbackRouter %s success", callbackType)
    return nil
}

// 使用
switch req.Type {
case CallbackTypeOnTableAddRow:
    return a.handleTableCallback(ctx, resp, CallbackTypeOnTableAddRow, func(ctx *Context, t *TableTemplate) (interface{}, error) {
        var req callback.OnTableAddRowReq
        return t.OnTableAddRow(ctx, &req)
    })
case CallbackTypeOnTableUpdateRow:
    return a.handleTableCallback(ctx, resp, CallbackTypeOnTableUpdateRow, func(ctx *Context, t *TableTemplate) (interface{}, error) {
        var req callback.OnTableUpdateRowReq
        if err := json.Unmarshal(ctx.body, &req); err != nil {
            return nil, err
        }
        return t.OnTableUpdateRow(ctx, &req)
    })
// ...
}
```

### 文件：`sdk/agent-app/app/router.go`

#### 问题 1：接收者命名

**重构前**：
```go
func (a *routerInfo) BuildSourceCodeFilePath() string {
    // ...
}
```

**重构后**：
```go
func (r *routerInfo) BuildSourceCodeFilePath() string {
    if r.Options == nil || r.Options.RouterGroup == nil {
        return ""
    }
    // ...
}
```

#### 问题 2：函数命名

**重构前**：
```go
func (a *routerInfo) getCode() string {
    // ...
}
```

**重构后**：
```go
func (r *routerInfo) GetCode() string {
    // 或者 GetFunctionCode()
    // ...
}
```

### 文件：`sdk/agent-app/app/app.go`

#### 问题 1：register 函数依赖全局变量

**重构前**：
```go
func register(router string, method string, handleFunc HandleFunc, templater Templater, options *RegisterOptions) {
    if app == nil {
        initApp()
    }
    if app == nil {
        logger.Errorf(context.Background(), "Cannot register router %s %s: app initialization failed", method, router)
        return
    }
    app.routerInfo[routerKey(router, method)] = &routerInfo{...}
}
```

**重构后**：
```go
// 改为 App 的方法
func (a *App) registerRoute(router string, method string, handleFunc HandleFunc, templater Templater, options *RegisterOptions) error {
    key := routerKey(router)
    
    // 检查 URL 唯一性
    if existing, exists := a.routerInfo[key]; exists {
        return fmt.Errorf("路由 %s 已存在，不允许重复注册。已存在的路由信息: Router=%s, Method=%s", 
            router, existing.Router, existing.Method)
    }
    
    a.routerInfo[key] = &routerInfo{
        HandleFunc: handleFunc,
        Router:     router,
        Method:     method,
        Options:    options,
        Template:   templater,
    }
    return nil
}
```

#### 问题 2：getRouter 改为方法

**重构前**：
```go
func (a *App) getRouter(router string, method string) (*routerInfo, error) {
    // ...
}
```

**重构后**：
```go
func (a *App) getRouter(router string) (*routerInfo, error) {
    // 移除 method 参数
    // ...
}
```

### 文件：`sdk/agent-app/app/register.go`

#### 问题：register 函数调用改为方法调用

**重构前**：
```go
func GET(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    register(router, "GET", handleFunc, templater, opts)
}
```

**重构后**：
```go
func GET(router string, handleFunc HandleFunc, templater Templater, options ...*RegisterOptions) {
    var opts *RegisterOptions
    if len(options) > 0 {
        opts = options[0]
    }
    // 需要获取 app 实例
    if app == nil {
        initApp()
    }
    if app == nil {
        logger.Errorf(context.Background(), "Cannot register router GET %s: app initialization failed", router)
        return
    }
    if err := app.registerRoute(router, "GET", handleFunc, templater, opts); err != nil {
        logger.Errorf(context.Background(), "Failed to register router GET %s: %v", router, err)
        panic(err)  // 或者返回错误
    }
}
```

### 新增文件：`sdk/agent-app/app/router/types.go`

**目的**：定义路由相关的类型和常量

```go
package app

// HTTPMethod HTTP 方法类型
type HTTPMethod string

const (
    MethodGet    HTTPMethod = "GET"
    MethodPost   HTTPMethod = "POST"
    MethodPut    HTTPMethod = "PUT"
    MethodDelete HTTPMethod = "DELETE"
    MethodAny    HTTPMethod = "ANY"  // 用于支持所有 method 的路由（如 /_callback）
)

// String 返回 HTTP 方法的字符串表示
func (m HTTPMethod) String() string {
    return string(m)
}

// IsValid 检查 HTTP 方法是否有效
func (m HTTPMethod) IsValid() bool {
    return m == MethodGet || m == MethodPost || m == MethodPut || m == MethodDelete || m == MethodAny
}
```

## 重构优先级

### 🔴 高优先级（必须做）

1. **路由 URL 唯一化改造** - 核心功能改造
2. **消除 GET/POST/PUT/DELETE 重复** - 代码重复严重
3. **消除 initRouter 重复注册** - 与改造相关
4. **改进 register 函数** - 消除全局变量依赖

### 🟡 中优先级（建议做）

1. **提取 CallbackRouter 公共处理** - 减少重复代码
2. **改进命名** - 提高可读性
3. **定义 HTTPMethod 类型** - 类型安全
4. **文件拆分** - 职责分离

### 🟢 低优先级（可选）

1. **接口定义** - 提高可测试性
2. **文档完善** - 提高可维护性
3. **错误处理统一** - 代码规范

## 重构风险

### 高风险

1. **全局变量改造** - 可能影响现有代码
   - **缓解**：逐步改造，保持向后兼容

2. **函数签名变更** - 可能影响调用方
   - **缓解**：保留旧函数，标记为 deprecated

### 中风险

1. **文件拆分** - 可能影响导入
   - **缓解**：保持包名不变，只是文件拆分

2. **类型定义** - 可能影响现有代码
   - **缓解**：使用类型别名，保持兼容

## 重构步骤建议

### 第一步：核心改造（必须）

1. ✅ 路由 URL 唯一化
2. ✅ 消除 initRouter 重复
3. ✅ 修改所有调用点

### 第二步：消除重复（高优先级）

1. ✅ 合并 GET/POST/PUT/DELETE
2. ✅ 合并 RouterGroup 方法
3. ✅ 提取 CallbackRouter 公共处理

### 第三步：改进命名和类型（中优先级）

1. ✅ 改进函数命名
2. ✅ 定义 HTTPMethod 类型
3. ✅ 改进接收者命名

### 第四步：依赖注入（中优先级）

1. ✅ register 改为方法
2. ✅ 减少全局变量依赖

### 第五步：文件拆分（低优先级）

1. ✅ 拆分 register.go
2. ✅ 拆分 app.go（如果需要）

### 第六步：文档和测试（低优先级）

1. ✅ 添加文档注释
2. ✅ 添加单元测试

## 总结

### 重构收益

1. ✅ **代码质量提升**：消除重复，职责清晰
2. ✅ **可维护性提升**：代码组织更合理
3. ✅ **可测试性提升**：减少全局变量，便于测试
4. ✅ **类型安全**：使用类型定义，减少错误

### 重构成本

1. ⚠️ **时间成本**：需要仔细测试
2. ⚠️ **风险成本**：可能引入 bug
3. ⚠️ **学习成本**：团队需要适应新结构

### 建议

**建议分阶段进行**：
1. 先完成核心改造（路由 URL 唯一化）
2. 再消除明显的代码重复
3. 最后进行文件拆分和架构优化

这样可以**降低风险**，**逐步改进**，**保证稳定性**。

