# 前端指标看板集成方案

## 需求分析

### 目标
- ✅ **前端应用内看板**：在现有前端应用中添加指标看板
- ✅ **应用级别指标**：查看整个应用的指标概览
- ✅ **函数级别指标**：点击函数时，查看该函数的详细指标
- ✅ **无需跳转 Grafana**：在前端应用内直接查看，体验更好

### 用户场景

1. **应用概览页面**
   - 显示应用列表
   - 每个应用显示关键指标（QPS、错误率、平均耗时）
   - 点击应用，查看应用详情和所有函数的指标

2. **函数详情页面**
   - 显示函数基本信息
   - 显示该函数的详细指标：
     - QPS 趋势图
     - 耗时分布（P50、P95、P99）
     - 错误率趋势
     - 错误类型分布

3. **实时监控**
   - 指标实时更新（每 5-10 秒刷新）
   - 支持时间范围选择（最近 1 小时、6 小时、24 小时）

## 技术方案分析

### 方案对比

#### 方案 A：后端封装 Prometheus API（推荐）✅

**架构**：
```
前端应用
    ↓ 调用后端 API
后端 API Gateway / app-server
    ↓ 封装 Prometheus 查询
Prometheus Server
    ↓ 返回指标数据
前端应用（展示）
```

**优点**：
- ✅ **安全性好**：Prometheus 不直接暴露给前端
- ✅ **统一认证**：复用现有的 JWT 认证
- ✅ **数据格式友好**：后端转换为前端需要的格式
- ✅ **多租户隔离**：后端自动过滤租户数据
- ✅ **易于扩展**：可以添加缓存、聚合等逻辑

**缺点**：
- ⚠️ 需要后端开发工作量

**实现复杂度**：⭐⭐（中等）

#### 方案 B：前端直接调用 Prometheus API

**架构**：
```
前端应用
    ↓ 直接调用 Prometheus API
Prometheus Server
    ↓ 返回指标数据
前端应用（展示）
```

**优点**：
- ✅ 实现简单，无需后端开发

**缺点**：
- ❌ **安全性差**：Prometheus 需要暴露给前端
- ❌ **认证复杂**：需要单独处理 Prometheus 认证
- ❌ **跨域问题**：需要配置 CORS
- ❌ **数据格式复杂**：需要前端解析 PromQL 结果
- ❌ **多租户隔离难**：前端需要处理租户过滤

**实现复杂度**：⭐⭐⭐（较高，主要是安全和认证问题）

#### 方案 C：通过 Grafana API

**架构**：
```
前端应用
    ↓ 调用 Grafana API
Grafana Server
    ↓ 查询 Prometheus
Prometheus Server
    ↓ 返回指标数据
前端应用（展示）
```

**优点**：
- ✅ 复用 Grafana 的查询能力

**缺点**：
- ❌ **依赖 Grafana**：必须部署 Grafana
- ❌ **API 复杂**：Grafana API 不是为前端集成设计的
- ❌ **性能差**：多一层转发

**实现复杂度**：⭐⭐⭐⭐（高）

### 推荐方案：后端封装 Prometheus API

## 详细设计

### 1. 后端 API 设计

#### API 端点设计

```
GET /api/v1/metrics/app/{user}/{app}           # 应用级别指标
GET /api/v1/metrics/function/{user}/{app}/{route}  # 函数级别指标
GET /api/v1/metrics/system/{user}/{app}       # 系统指标
```

#### 请求参数

```typescript
// 应用级别指标
GET /api/v1/metrics/app/beiluo/test777?time_range=1h&metrics=qps,latency,error_rate

// 函数级别指标
GET /api/v1/metrics/function/beiluo/test777?route=/api/user&method=POST&time_range=1h
```

#### 响应格式

```typescript
// 应用级别指标响应
{
  "app": "test777",
  "user": "beiluo",
  "version": "v15",
  "time_range": "1h",
  "metrics": {
    "qps": {
      "current": 123.45,           // 当前 QPS
      "trend": [                    // QPS 趋势（时间序列）
        { "time": "2024-01-01T10:00:00Z", "value": 100 },
        { "time": "2024-01-01T10:05:00Z", "value": 120 },
        { "time": "2024-01-01T10:10:00Z", "value": 150 }
      ]
    },
    "latency": {
      "avg": 0.123,                // 平均耗时（秒）
      "p50": 0.100,                 // P50 耗时
      "p95": 0.200,                 // P95 耗时
      "p99": 0.300                  // P99 耗时
    },
    "error_rate": {
      "current": 0.05,              // 当前错误率（5%）
      "trend": [                    // 错误率趋势
        { "time": "2024-01-01T10:00:00Z", "value": 0.03 },
        { "time": "2024-01-01T10:05:00Z", "value": 0.04 },
        { "time": "2024-01-01T10:10:00Z", "value": 0.05 }
      ]
    },
    "concurrent": 5,                 // 当前并发数
    "total_requests": 10000          // 总请求数
  },
  "functions": [                    // 函数列表（带指标）
    {
      "route": "/api/user",
      "method": "POST",
      "qps": 50.0,
      "avg_latency": 0.100,
      "error_rate": 0.02
    },
    {
      "route": "/api/order",
      "method": "GET",
      "qps": 30.0,
      "avg_latency": 0.150,
      "error_rate": 0.01
    }
  ]
}

// 函数级别指标响应
{
  "route": "/api/user",
  "method": "POST",
  "app": "test777",
  "user": "beiluo",
  "time_range": "1h",
  "metrics": {
    "qps": {
      "current": 50.0,
      "trend": [
        { "time": "2024-01-01T10:00:00Z", "value": 45 },
        { "time": "2024-01-01T10:05:00Z", "value": 48 },
        { "time": "2024-01-01T10:10:00Z", "value": 50 }
      ]
    },
    "latency": {
      "avg": 0.100,
      "p50": 0.080,
      "p95": 0.150,
      "p99": 0.200,
      "distribution": [             // 耗时分布
        { "bucket": "0-50ms", "count": 1000 },
        { "bucket": "50-100ms", "count": 500 },
        { "bucket": "100-200ms", "count": 200 },
        { "bucket": "200ms+", "count": 50 }
      ]
    },
    "errors": {
      "total": 10,
      "by_type": [                  // 按错误类型统计
        { "type": "validation", "count": 5 },
        { "type": "panic", "count": 2 },
        { "type": "timeout", "count": 3 }
      ],
      "trend": [                     // 错误趋势
        { "time": "2024-01-01T10:00:00Z", "count": 2 },
        { "time": "2024-01-01T10:05:00Z", "count": 3 },
        { "time": "2024-01-01T10:10:00Z", "count": 5 }
      ]
    },
    "requests": {
      "total": 1000,
      "success": 990,
      "failed": 10
    }
  }
}
```

### 2. 后端实现

#### 2.1 创建 Metrics Service

**文件结构**：
```
core/app-server/
  ├── service/
  │   └── metrics_service.go      # Metrics 服务
  ├── api/v1/
  │   └── metrics.go               # Metrics API 处理器
  └── server/
      └── router.go                 # 添加 metrics 路由
```

#### 2.2 Metrics Service 实现

```go
// service/metrics_service.go
package service

import (
    "context"
    "fmt"
    "time"
    
    "github.com/prometheus/client_golang/api"
    v1 "github.com/prometheus/client_golang/api/prometheus/v1"
)

type MetricsService struct {
    prometheusClient v1.API
}

func NewMetricsService(prometheusURL string) (*MetricsService, error) {
    client, err := api.NewClient(api.Config{
        Address: prometheusURL,
    })
    if err != nil {
        return nil, err
    }
    
    return &MetricsService{
        prometheusClient: v1.NewAPI(client),
    }, nil
}

// GetAppMetrics 获取应用级别指标
func (s *MetricsService) GetAppMetrics(ctx context.Context, user, app, timeRange string) (*AppMetrics, error) {
    // 构建 PromQL 查询
    // QPS 查询
    qpsQuery := fmt.Sprintf(
        `sum(rate(http_requests_total{tenant="%s",application="%s"}[5m]))`,
        user, app,
    )
    
    // 耗时查询
    latencyQuery := fmt.Sprintf(
        `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{tenant="%s",application="%s"}[5m]))`,
        user, app,
    )
    
    // 错误率查询
    errorRateQuery := fmt.Sprintf(
        `sum(rate(http_errors_total{tenant="%s",application="%s"}[5m])) / sum(rate(http_requests_total{tenant="%s",application="%s"}[5m])) * 100`,
        user, app, user, app,
    )
    
    // 执行查询
    // ... 查询逻辑 ...
    
    // 转换为前端需要的格式
    // ... 转换逻辑 ...
    
    return &AppMetrics{...}, nil
}

// GetFunctionMetrics 获取函数级别指标
func (s *MetricsService) GetFunctionMetrics(ctx context.Context, user, app, route, method, timeRange string) (*FunctionMetrics, error) {
    // 构建 PromQL 查询（包含 route 和 method 标签）
    // ... 查询逻辑 ...
    
    return &FunctionMetrics{...}, nil
}
```

#### 2.3 API 处理器实现

```go
// api/v1/metrics.go
package v1

import (
    "github.com/gin-gonic/gin"
    "github.com/ai-agent-os/ai-agent-os/core/app-server/service"
)

type MetricsHandler struct {
    metricsService *service.MetricsService
}

func NewMetrics(metricsService *service.MetricsService) *MetricsHandler {
    return &MetricsHandler{
        metricsService: metricsService,
    }
}

// GetAppMetrics 获取应用级别指标
// @Summary 获取应用指标
// @Description 获取指定应用的指标数据
// @Tags metrics
// @Accept json
// @Produce json
// @Param user path string true "租户标识"
// @Param app path string true "应用标识"
// @Param time_range query string false "时间范围" default(1h)
// @Success 200 {object} dto.AppMetricsResponse
// @Router /api/v1/metrics/app/{user}/{app} [get]
func (h *MetricsHandler) GetAppMetrics(c *gin.Context) {
    user := c.Param("user")
    app := c.Param("app")
    timeRange := c.DefaultQuery("time_range", "1h")
    
    // 从 JWT 中获取当前用户，验证权限
    currentUser := contextx.GetRequestUser(c.Request.Context())
    if currentUser != user {
        c.JSON(403, gin.H{"error": "无权访问该租户的数据"})
        return
    }
    
    metrics, err := h.metricsService.GetAppMetrics(c.Request.Context(), user, app, timeRange)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, metrics)
}

// GetFunctionMetrics 获取函数级别指标
// @Summary 获取函数指标
// @Description 获取指定函数的指标数据
// @Tags metrics
// @Accept json
// @Produce json
// @Param user path string true "租户标识"
// @Param app path string true "应用标识"
// @Param route query string true "路由路径"
// @Param method query string true "HTTP 方法"
// @Param time_range query string false "时间范围" default(1h)
// @Success 200 {object} dto.FunctionMetricsResponse
// @Router /api/v1/metrics/function/{user}/{app} [get]
func (h *MetricsHandler) GetFunctionMetrics(c *gin.Context) {
    user := c.Param("user")
    app := c.Param("app")
    route := c.Query("route")
    method := c.Query("method")
    timeRange := c.DefaultQuery("time_range", "1h")
    
    // 权限验证
    currentUser := contextx.GetRequestUser(c.Request.Context())
    if currentUser != user {
        c.JSON(403, gin.H{"error": "无权访问该租户的数据"})
        return
    }
    
    metrics, err := h.metricsService.GetFunctionMetrics(c.Request.Context(), user, app, route, method, timeRange)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, metrics)
}
```

### 3. 前端实现

#### 3.1 API 封装

```typescript
// web/src/api/metrics.ts
import { get } from '@/utils/request'

// 应用级别指标
export interface AppMetrics {
  app: string
  user: string
  version: string
  time_range: string
  metrics: {
    qps: {
      current: number
      trend: Array<{ time: string; value: number }>
    }
    latency: {
      avg: number
      p50: number
      p95: number
      p99: number
    }
    error_rate: {
      current: number
      trend: Array<{ time: string; value: number }>
    }
    concurrent: number
    total_requests: number
  }
  functions: Array<{
    route: string
    method: string
    qps: number
    avg_latency: number
    error_rate: number
  }>
}

export function getAppMetrics(user: string, app: string, timeRange: string = '1h'): Promise<AppMetrics> {
  return get<AppMetrics>(`/api/v1/metrics/app/${user}/${app}`, { time_range: timeRange })
}

// 函数级别指标
export interface FunctionMetrics {
  route: string
  method: string
  app: string
  user: string
  time_range: string
  metrics: {
    qps: {
      current: number
      trend: Array<{ time: string; value: number }>
    }
    latency: {
      avg: number
      p50: number
      p95: number
      p99: number
      distribution: Array<{ bucket: string; count: number }>
    }
    errors: {
      total: number
      by_type: Array<{ type: string; count: number }>
      trend: Array<{ time: string; count: number }>
    }
    requests: {
      total: number
      success: number
      failed: number
    }
  }
}

export function getFunctionMetrics(
  user: string,
  app: string,
  route: string,
  method: string,
  timeRange: string = '1h'
): Promise<FunctionMetrics> {
  return get<FunctionMetrics>(`/api/v1/metrics/function/${user}/${app}`, {
    route,
    method,
    time_range: timeRange
  })
}
```

#### 3.2 组件实现

```vue
<!-- web/src/components/Metrics/AppMetricsPanel.vue -->
<template>
  <div class="app-metrics-panel">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>应用指标 - {{ app }}</span>
          <el-select v-model="timeRange" @change="loadMetrics">
            <el-option label="最近1小时" value="1h" />
            <el-option label="最近6小时" value="6h" />
            <el-option label="最近24小时" value="24h" />
          </el-select>
        </div>
      </template>
      
      <!-- QPS 图表 -->
      <div class="metric-section">
        <h3>QPS (每秒请求数)</h3>
        <div class="metric-value">{{ metrics.metrics.qps.current.toFixed(2) }}</div>
        <LineChart :data="metrics.metrics.qps.trend" />
      </div>
      
      <!-- 耗时图表 -->
      <div class="metric-section">
        <h3>平均耗时</h3>
        <div class="metric-row">
          <div class="metric-item">
            <span>平均</span>
            <span>{{ (metrics.metrics.latency.avg * 1000).toFixed(2) }}ms</span>
          </div>
          <div class="metric-item">
            <span>P95</span>
            <span>{{ (metrics.metrics.latency.p95 * 1000).toFixed(2) }}ms</span>
          </div>
          <div class="metric-item">
            <span>P99</span>
            <span>{{ (metrics.metrics.latency.p99 * 1000).toFixed(2) }}ms</span>
          </div>
        </div>
      </div>
      
      <!-- 错误率图表 -->
      <div class="metric-section">
        <h3>错误率</h3>
        <div class="metric-value">{{ (metrics.metrics.error_rate.current * 100).toFixed(2) }}%</div>
        <LineChart :data="metrics.metrics.error_rate.trend" />
      </div>
      
      <!-- 函数列表 -->
      <div class="metric-section">
        <h3>函数列表</h3>
        <el-table :data="metrics.functions">
          <el-table-column prop="route" label="路由" />
          <el-table-column prop="method" label="方法" />
          <el-table-column prop="qps" label="QPS" />
          <el-table-column prop="avg_latency" label="平均耗时(ms)" :formatter="formatLatency" />
          <el-table-column prop="error_rate" label="错误率" :formatter="formatErrorRate" />
          <el-table-column label="操作">
            <template #default="{ row }">
              <el-button @click="viewFunctionMetrics(row)">查看详情</el-button>
            </template>
          </el-table-column>
        </el-table>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { getAppMetrics, type AppMetrics } from '@/api/metrics'
import LineChart from './LineChart.vue'

const props = defineProps<{
  user: string
  app: string
}>()

const timeRange = ref('1h')
const metrics = ref<AppMetrics | null>(null)
const loading = ref(false)

async function loadMetrics() {
  loading.value = true
  try {
    metrics.value = await getAppMetrics(props.user, props.app, timeRange.value)
  } finally {
    loading.value = false
  }
}

function viewFunctionMetrics(functionInfo: any) {
  // 打开函数指标详情对话框
  emit('view-function', functionInfo)
}

onMounted(() => {
  loadMetrics()
  // 每 10 秒自动刷新
  setInterval(loadMetrics, 10000)
})
</script>
```

```vue
<!-- web/src/components/Metrics/FunctionMetricsDialog.vue -->
<template>
  <el-dialog v-model="visible" title="函数指标详情" width="80%">
    <div v-if="metrics">
      <!-- QPS 图表 -->
      <div class="metric-section">
        <h3>QPS 趋势</h3>
        <LineChart :data="metrics.metrics.qps.trend" />
      </div>
      
      <!-- 耗时分布 -->
      <div class="metric-section">
        <h3>耗时分布</h3>
        <BarChart :data="metrics.metrics.latency.distribution" />
        <div class="latency-stats">
          <span>平均: {{ (metrics.metrics.latency.avg * 1000).toFixed(2) }}ms</span>
          <span>P50: {{ (metrics.metrics.latency.p50 * 1000).toFixed(2) }}ms</span>
          <span>P95: {{ (metrics.metrics.latency.p95 * 1000).toFixed(2) }}ms</span>
          <span>P99: {{ (metrics.metrics.latency.p99 * 1000).toFixed(2) }}ms</span>
        </div>
      </div>
      
      <!-- 错误统计 -->
      <div class="metric-section">
        <h3>错误统计</h3>
        <PieChart :data="metrics.metrics.errors.by_type" />
        <LineChart :data="metrics.metrics.errors.trend" />
      </div>
    </div>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue'
import { getFunctionMetrics, type FunctionMetrics } from '@/api/metrics'
import LineChart from './LineChart.vue'
import BarChart from './BarChart.vue'
import PieChart from './PieChart.vue'

const props = defineProps<{
  visible: boolean
  user: string
  app: string
  route: string
  method: string
}>()

const metrics = ref<FunctionMetrics | null>(null)

watch(() => props.visible, async (newVal) => {
  if (newVal) {
    metrics.value = await getFunctionMetrics(
      props.user,
      props.app,
      props.route,
      props.method
    )
  }
})
</script>
```

#### 3.3 集成到现有页面

```vue
<!-- web/src/views/Workspace/index.vue -->
<template>
  <div class="workspace">
    <!-- 应用列表 -->
    <el-table :data="apps">
      <el-table-column prop="name" label="应用名称" />
      <el-table-column label="指标">
        <template #default="{ row }">
          <el-button @click="viewAppMetrics(row)">查看指标</el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 函数列表 -->
    <el-table :data="functions">
      <el-table-column prop="router" label="路由" />
      <el-table-column prop="method" label="方法" />
      <el-table-column label="指标">
        <template #default="{ row }">
          <el-button @click="viewFunctionMetrics(row)">查看指标</el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 应用指标面板 -->
    <AppMetricsPanel
      v-if="selectedApp"
      :user="selectedApp.user"
      :app="selectedApp.code"
      @view-function="handleViewFunction"
    />
    
    <!-- 函数指标对话框 -->
    <FunctionMetricsDialog
      v-model="functionMetricsVisible"
      :user="selectedFunction?.user"
      :app="selectedFunction?.app"
      :route="selectedFunction?.route"
      :method="selectedFunction?.method"
    />
  </div>
</template>
```

### 4. 图表库选择

#### 推荐：ECharts（Vue-ECharts）

**优点**：
- ✅ 功能强大，图表类型丰富
- ✅ 性能好，支持大数据量
- ✅ 中文文档完善
- ✅ Vue 集成简单

**安装**：
```bash
npm install echarts vue-echarts
```

**使用示例**：
```vue
<template>
  <v-chart :option="chartOption" />
</template>

<script setup>
import { use } from 'echarts/core'
import { CanvasRenderer } from 'echarts/renderers'
import { LineChart } from 'echarts/charts'
import { TitleComponent, TooltipComponent, LegendComponent } from 'echarts/components'
import VChart from 'vue-echarts'

use([
  CanvasRenderer,
  LineChart,
  TitleComponent,
  TooltipComponent,
  LegendComponent
])

const chartOption = {
  xAxis: { type: 'time' },
  yAxis: { type: 'value' },
  series: [{
    type: 'line',
    data: metrics.value.metrics.qps.trend
  }]
}
</script>
```

## 实施步骤

### 阶段一：后端 API 开发（2-3 天）

1. **创建 Metrics Service**
   - 集成 Prometheus Client
   - 实现 PromQL 查询封装
   - 实现数据转换（Prometheus 格式 → 前端格式）

2. **创建 Metrics API**
   - 实现应用级别指标 API
   - 实现函数级别指标 API
   - 添加权限验证

3. **测试验证**
   - 测试 API 功能
   - 测试多租户隔离
   - 测试性能

### 阶段二：前端组件开发（2-3 天）

1. **API 封装**
   - 创建 metrics API 文件
   - 定义 TypeScript 类型

2. **组件开发**
   - 应用指标面板
   - 函数指标对话框
   - 图表组件（使用 ECharts）

3. **集成到现有页面**
   - 在应用列表添加指标入口
   - 在函数列表添加指标入口

### 阶段三：优化和完善（1-2 天）

1. **性能优化**
   - 添加数据缓存
   - 优化查询性能

2. **用户体验优化**
   - 添加加载状态
   - 添加错误处理
   - 优化图表展示

## 总结

### 方案优势

1. ✅ **完全可行**：前端可以完美集成指标看板
2. ✅ **用户体验好**：无需跳转 Grafana，在应用内直接查看
3. ✅ **安全性好**：通过后端 API，不直接暴露 Prometheus
4. ✅ **多租户支持**：后端自动过滤，前端无需处理
5. ✅ **易于扩展**：可以轻松添加新指标和功能

### 关键点

1. **后端封装**：后端封装 Prometheus 查询，提供友好的 RESTful API
2. **数据格式**：后端转换为前端需要的格式，前端无需处理 PromQL
3. **权限控制**：复用现有 JWT 认证，确保多租户隔离
4. **实时更新**：前端定时刷新，保持数据实时性

### 预期效果

- ✅ 用户可以在前端应用内直接查看指标
- ✅ 点击应用/函数，可以查看详细指标
- ✅ 支持时间范围选择
- ✅ 支持实时刷新
- ✅ 完全集成到现有 UI，体验流畅

**结论**：完全可以实现前端指标看板，不需要依赖 Grafana！







