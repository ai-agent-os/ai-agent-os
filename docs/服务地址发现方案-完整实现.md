# 服务地址发现方案 - 完整实现

## 🎯 问题

**"先有鸡还是先有蛋"的问题**：
- SDK 需要知道服务地址（如 storage）
- 要获取服务地址，需要先调用网关的配置接口
- 调用网关接口需要先知道**网关地址**

## ✅ 解决方案：分层配置策略

### 配置优先级（从高到低）

1. **网关配置接口**（最灵活，动态更新）
2. **环境变量**（容器化友好，降级方案）
3. **默认值**（开发环境，兜底方案）

---

## 📋 实现方案

### 1. 网关地址获取

**方式**：
```bash
# 环境变量（生产环境）
export GATEWAY_URL=http://localhost:9090

# 或使用默认值（开发环境）
# 默认：http://localhost:9090
```

**代码实现**：
```go
func getGatewayURL() string {
    // 优先环境变量
    if url := os.Getenv("GATEWAY_URL"); url != "" {
        return url
    }
    
    // 默认值（开发环境）
    return "http://localhost:9090"
}
```

### 2. 服务地址获取流程

```
1. 尝试从网关配置接口获取（需要知道网关地址）
   ↓ 失败
2. 降级：从环境变量获取（STORAGE_URL, APP_SERVER_URL）
   ↓ 失败
3. 使用默认值（开发环境）
```

### 3. 完整使用示例

#### SDK 中使用

```go
import "github.com/ai-agent-os/ai-agent-os/pkg/serviceconfig"

func uploadFile(filePath string) error {
    // 获取存储服务地址（自动处理降级）
    storageURL, err := serviceconfig.GetServiceURL("storage")
    if err != nil {
        return fmt.Errorf("failed to get storage URL: %w", err)
    }
    
    // 调用存储服务
    uploadURL := fmt.Sprintf("%s/api/v1/storage/upload", storageURL)
    // ... 上传文件
}
```

#### 环境变量配置（生产环境）

```bash
# 必需：网关地址（用于获取配置）
export GATEWAY_URL=http://api-gateway:9090

# 可选：直接服务地址（降级方案）
export STORAGE_URL=http://storage-service:9092
export APP_SERVER_URL=http://app-server:9091
```

#### Docker Compose 示例

```yaml
services:
  sdk:
    environment:
      # 网关地址（必需）
      - GATEWAY_URL=http://api-gateway:9090
      # 直接地址（可选，降级方案）
      - STORAGE_URL=http://app-storage:9092
      - APP_SERVER_URL=http://app-server:9091
```

#### Kubernetes 示例

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-config
data:
  GATEWAY_URL: "http://api-gateway:9090"
  STORAGE_URL: "http://app-storage:9092"
  APP_SERVER_URL: "http://app-server:9091"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sdk
spec:
  template:
    spec:
      containers:
      - name: sdk
        envFrom:
        - configMapRef:
            name: service-config
```

---

## 🔄 工作流程

### 场景 1：开发环境（最简单）

```
1. 使用默认网关地址：http://localhost:9090
2. 调用网关配置接口获取服务地址
3. 使用 direct_url 直接调用服务
```

**无需任何配置** ✅

### 场景 2：生产环境（容器化）

```
1. 通过环境变量获取网关地址：GATEWAY_URL
2. 调用网关配置接口获取服务地址
3. 如果网关不可用，降级使用环境变量（STORAGE_URL）
```

**只需配置网关地址** ✅

### 场景 3：网关不可用（降级）

```
1. 网关地址不可用或网关接口失败
2. 自动降级：从环境变量获取（STORAGE_URL）
3. 如果环境变量也没有，使用默认值
```

**高可用性保证** ✅

---

## 📊 配置对比

| 配置方式 | 网关地址 | 存储地址 | 灵活性 | 适用场景 |
|---------|---------|---------|--------|---------|
| **网关接口** | 环境变量 | 自动获取 | ⭐⭐⭐⭐⭐ | 推荐 |
| **环境变量** | 环境变量 | 环境变量 | ⭐⭐⭐ | 降级方案 |
| **默认值** | 硬编码 | 硬编码 | ⭐ | 仅开发环境 |

---

## 💡 最佳实践

### 开发环境
```bash
# 无需配置，使用默认值
# 网关：http://localhost:9090
# 存储：http://localhost:9092
```

### 生产环境
```bash
# 只需配置网关地址
export GATEWAY_URL=http://api-gateway:9090

# 可选：配置直接地址作为降级方案
export STORAGE_URL=http://storage-service:9092
```

### 容器化部署
```yaml
# Docker Compose / Kubernetes
environment:
  GATEWAY_URL: http://api-gateway:9090  # 必需
  STORAGE_URL: http://storage:9092      # 可选（降级）
```

---

## 🎯 总结

**问题**：需要知道网关地址才能获取服务配置

**解决方案**：
1. ✅ **网关地址**：通过环境变量 `GATEWAY_URL`（生产）或默认值（开发）
2. ✅ **服务地址**：优先从网关接口获取，降级使用环境变量
3. ✅ **高可用**：多层降级方案，确保服务可用

**配置复杂度**：
- 开发环境：**零配置**（使用默认值）
- 生产环境：**只需配置网关地址**（一个环境变量）

这样既解决了"先有鸡还是先有蛋"的问题，又保持了配置的简单性！

