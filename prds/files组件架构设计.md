# Files ç»„ä»¶æ¶æ„è®¾è®¡

## ä¸€ã€æ ¸å¿ƒé—®é¢˜åˆ†æ

### å½“å‰ç—›ç‚¹

1. **æ—§ç‰ˆæœ¬ä¸ä¸ƒç‰›äº‘å¼ºè€¦åˆ** âŒ
   - æ— æ³•æ”¯æŒç§æœ‰åŒ–éƒ¨ç½²
   - æ— æ³•åˆ‡æ¢å­˜å‚¨æœåŠ¡å•†
   - æ•°æ®å¿…é¡»å‡ºåŸŸ

2. **ç§æœ‰åŒ–éƒ¨ç½²éœ€æ±‚** âœ…
   - ä¼ä¸šå®¢æˆ·æ•°æ®ä¸èƒ½å‡ºåŸŸ
   - éœ€è¦æ”¯æŒè‡ªå»ºå­˜å‚¨
   - éœ€è¦æ”¯æŒå¤šç§å­˜å‚¨åç«¯

3. **ä¸¤ç§ä½¿ç”¨åœºæ™¯æ··æ‚** âš ï¸
   - åœºæ™¯1ï¼šåç«¯éœ€è¦å¤„ç†æ–‡ä»¶ï¼ˆè§†é¢‘è½¬æ¢ã€OCR ç­‰ï¼‰
   - åœºæ™¯2ï¼šåç«¯åªå­˜å‚¨å…ƒæ•°æ®ï¼ˆå·¥å•é™„ä»¶ï¼‰

---

## äºŒã€æ¶æ„è®¾è®¡ï¼ˆæ ¸å¿ƒæ–¹æ¡ˆï¼‰

### ğŸ¯ è®¾è®¡åŸåˆ™

1. **å­˜å‚¨æŠ½è±¡** - æ”¯æŒå¤šç§å­˜å‚¨åç«¯ï¼ˆMinIOã€ä¸ƒç‰›äº‘ã€é˜¿é‡Œäº‘ OSSã€AWS S3ï¼‰
2. **èŒè´£åˆ†ç¦»** - å‰ç«¯ä¸Šä¼ ã€åç«¯å¤„ç†ã€å­˜å‚¨æœåŠ¡ç‹¬ç«‹
3. **å®‰å…¨ç¬¬ä¸€** - ç­¾åä¸Šä¼ ã€æƒé™æ§åˆ¶ã€ç—…æ¯’æ‰«æ
4. **çµæ´»é…ç½®** - æ”¯æŒäº‘ç«¯å’Œç§æœ‰åŒ–éƒ¨ç½²

---

### ğŸ—ï¸ æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Files ç»„ä»¶æ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    å‰ç«¯ (Vue)                             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚   â”‚
â”‚  â”‚  â”‚ FileUpload â”‚  â”‚ FileList   â”‚  â”‚ FilePreviewâ”‚         â”‚   â”‚
â”‚  â”‚  â”‚  Widget    â”‚  â”‚  Widget    â”‚  â”‚   Widget   â”‚         â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚   â”‚
â”‚  â”‚        â”‚                â”‚                â”‚                 â”‚   â”‚
â”‚  â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
â”‚  â”‚                         â”‚                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â”‚                                     â”‚
â”‚                            â”‚ HTTP API                            â”‚
â”‚                            â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  App Server (Go)                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚           Storage Manager (æŠ½è±¡å±‚)                  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  MinIO   â”‚  â”‚  Qiniu   â”‚  â”‚  Local   â”‚  ...    â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ Provider â”‚  â”‚ Provider â”‚  â”‚ Provider â”‚         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              å®é™…å­˜å‚¨ (å¯æ’æ‹”)                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚  â”‚  MinIO   â”‚  â”‚ ä¸ƒç‰›äº‘   â”‚  â”‚ æœ¬åœ°ç£ç›˜ â”‚  ...         â”‚   â”‚
â”‚  â”‚  â”‚  é›†ç¾¤    â”‚  â”‚   OSS    â”‚  â”‚  /data   â”‚              â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€åç«¯å­˜å‚¨æŠ½è±¡å±‚è®¾è®¡

### ğŸ“¦ Storage Provider æ¥å£

```go
// pkg/storage/provider.go

package storage

import (
    "context"
    "io"
    "time"
)

// Provider å­˜å‚¨æä¾›è€…æ¥å£ï¼ˆæ ¸å¿ƒæŠ½è±¡ï¼‰
type Provider interface {
    // GetUploadToken è·å–ä¸Šä¼ å‡­è¯ï¼ˆå‰ç«¯ç›´ä¼ éœ€è¦ï¼‰
    GetUploadToken(ctx context.Context, opts *UploadOptions) (*UploadToken, error)
    
    // Upload ä¸Šä¼ æ–‡ä»¶ï¼ˆåç«¯å¤„ç†æ–‡ä»¶æ—¶éœ€è¦ï¼‰
    Upload(ctx context.Context, reader io.Reader, opts *UploadOptions) (*FileInfo, error)
    
    // Download ä¸‹è½½æ–‡ä»¶
    Download(ctx context.Context, key string) (io.ReadCloser, error)
    
    // GetURL è·å–æ–‡ä»¶è®¿é—® URLï¼ˆæ”¯æŒä¸´æ—¶ç­¾åï¼‰
    GetURL(ctx context.Context, key string, expire time.Duration) (string, error)
    
    // Delete åˆ é™¤æ–‡ä»¶
    Delete(ctx context.Context, key string) error
    
    // Exists æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    Exists(ctx context.Context, key string) (bool, error)
    
    // GetMetadata è·å–æ–‡ä»¶å…ƒæ•°æ®
    GetMetadata(ctx context.Context, key string) (*FileMetadata, error)
}

// UploadOptions ä¸Šä¼ é€‰é¡¹
type UploadOptions struct {
    Key         string            // æ–‡ä»¶å­˜å‚¨è·¯å¾„ï¼ˆå¦‚ "users/123/avatar.jpg"ï¼‰
    Bucket      string            // å­˜å‚¨æ¡¶åç§°
    ContentType string            // æ–‡ä»¶ç±»å‹
    MaxSize     int64             // æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    Expire      time.Duration     // ä¸Šä¼ å‡­è¯è¿‡æœŸæ—¶é—´
    Metadata    map[string]string // è‡ªå®šä¹‰å…ƒæ•°æ®
    Public      bool              // æ˜¯å¦å…¬å¼€è®¿é—®
}

// UploadToken ä¸Šä¼ å‡­è¯
type UploadToken struct {
    Token      string            // ä¸Šä¼ å‡­è¯
    URL        string            // ä¸Šä¼ åœ°å€
    Key        string            // æ–‡ä»¶å­˜å‚¨è·¯å¾„
    Expire     time.Time         // è¿‡æœŸæ—¶é—´
    Method     string            // ä¸Šä¼ æ–¹å¼ï¼ˆPUT/POST/FORMï¼‰
    Headers    map[string]string // éœ€è¦çš„ HTTP å¤´
    FormFields map[string]string // è¡¨å•å­—æ®µï¼ˆPOST ä¸Šä¼ æ—¶éœ€è¦ï¼‰
}

// FileInfo æ–‡ä»¶ä¿¡æ¯
type FileInfo struct {
    Key         string            // æ–‡ä»¶å­˜å‚¨è·¯å¾„
    URL         string            // è®¿é—® URL
    Size        int64             // æ–‡ä»¶å¤§å°
    ContentType string            // æ–‡ä»¶ç±»å‹
    Hash        string            // æ–‡ä»¶å“ˆå¸Œï¼ˆMD5/SHA256ï¼‰
    UploadedAt  time.Time         // ä¸Šä¼ æ—¶é—´
    Metadata    map[string]string // å…ƒæ•°æ®
}

// FileMetadata æ–‡ä»¶å…ƒæ•°æ®
type FileMetadata struct {
    Key         string
    Size        int64
    ContentType string
    Hash        string
    CreatedAt   time.Time
    ModifiedAt  time.Time
}
```

---

### ğŸ”Œ å…·ä½“å®ç°ï¼ˆMinIO Providerï¼‰

```go
// pkg/storage/minio/provider.go

package minio

import (
    "context"
    "fmt"
    "io"
    "time"
    
    "github.com/minio/minio-go/v7"
    "github.com/minio/minio-go/v7/pkg/credentials"
    "github.com/ai-agent-os/ai-agent-os/pkg/storage"
)

type MinIOProvider struct {
    client *minio.Client
    bucket string
    region string
}

func NewMinIOProvider(endpoint, accessKey, secretKey, bucket, region string, useSSL bool) (*MinIOProvider, error) {
    client, err := minio.New(endpoint, &minio.Options{
        Creds:  credentials.NewStaticV4(accessKey, secretKey, ""),
        Secure: useSSL,
        Region: region,
    })
    if err != nil {
        return nil, err
    }
    
    return &MinIOProvider{
        client: client,
        bucket: bucket,
        region: region,
    }, nil
}

// GetUploadToken ç”Ÿæˆé¢„ç­¾åä¸Šä¼  URL
func (p *MinIOProvider) GetUploadToken(ctx context.Context, opts *storage.UploadOptions) (*storage.UploadToken, error) {
    // MinIO ä½¿ç”¨é¢„ç­¾å URL æ–¹å¼ä¸Šä¼ 
    presignedURL, err := p.client.PresignedPutObject(ctx, 
        opts.Bucket, 
        opts.Key, 
        opts.Expire,
    )
    if err != nil {
        return nil, err
    }
    
    return &storage.UploadToken{
        URL:    presignedURL.String(),
        Key:    opts.Key,
        Method: "PUT",
        Expire: time.Now().Add(opts.Expire),
        Headers: map[string]string{
            "Content-Type": opts.ContentType,
        },
    }, nil
}

// Upload ç›´æ¥ä¸Šä¼ æ–‡ä»¶ï¼ˆåç«¯ä½¿ç”¨ï¼‰
func (p *MinIOProvider) Upload(ctx context.Context, reader io.Reader, opts *storage.UploadOptions) (*storage.FileInfo, error) {
    info, err := p.client.PutObject(ctx,
        opts.Bucket,
        opts.Key,
        reader,
        opts.MaxSize,
        minio.PutObjectOptions{
            ContentType: opts.ContentType,
            UserMetadata: opts.Metadata,
        },
    )
    if err != nil {
        return nil, err
    }
    
    return &storage.FileInfo{
        Key:         opts.Key,
        URL:         p.getPublicURL(opts.Bucket, opts.Key),
        Size:        info.Size,
        ContentType: opts.ContentType,
        Hash:        info.ETag,
        UploadedAt:  time.Now(),
        Metadata:    opts.Metadata,
    }, nil
}

// Download ä¸‹è½½æ–‡ä»¶
func (p *MinIOProvider) Download(ctx context.Context, key string) (io.ReadCloser, error) {
    object, err := p.client.GetObject(ctx, p.bucket, key, minio.GetObjectOptions{})
    if err != nil {
        return nil, err
    }
    return object, nil
}

// GetURL è·å–è®¿é—® URLï¼ˆæ”¯æŒä¸´æ—¶ç­¾åï¼‰
func (p *MinIOProvider) GetURL(ctx context.Context, key string, expire time.Duration) (string, error) {
    if expire > 0 {
        // è¿”å›ä¸´æ—¶ç­¾å URL
        presignedURL, err := p.client.PresignedGetObject(ctx, p.bucket, key, expire, nil)
        if err != nil {
            return "", err
        }
        return presignedURL.String(), nil
    }
    
    // è¿”å›å…¬å¼€ URL
    return p.getPublicURL(p.bucket, key), nil
}

// å…¶ä»–æ–¹æ³•å®ç°...
```

---

### ğŸ”Œ ä¸ƒç‰›äº‘ Provider

```go
// pkg/storage/qiniu/provider.go

package qiniu

import (
    "context"
    "io"
    "time"
    
    "github.com/qiniu/go-sdk/v7/auth"
    "github.com/qiniu/go-sdk/v7/storage"
    "github.com/ai-agent-os/ai-agent-os/pkg/storage"
)

type QiniuProvider struct {
    mac    *auth.Credentials
    bucket string
    domain string // CDN åŸŸå
}

func NewQiniuProvider(accessKey, secretKey, bucket, domain string) *QiniuProvider {
    return &QiniuProvider{
        mac:    auth.New(accessKey, secretKey),
        bucket: bucket,
        domain: domain,
    }
}

// GetUploadToken ç”Ÿæˆä¸Šä¼ å‡­è¯
func (p *QiniuProvider) GetUploadToken(ctx context.Context, opts *storage.UploadOptions) (*storage.UploadToken, error) {
    putPolicy := storage.PutPolicy{
        Scope:      fmt.Sprintf("%s:%s", p.bucket, opts.Key),
        Expires:    uint64(opts.Expire.Seconds()),
        ReturnBody: `{"key":"$(key)","hash":"$(etag)","size":$(fsize)}`,
    }
    
    token := putPolicy.UploadToken(p.mac)
    
    return &storage.UploadToken{
        Token:  token,
        URL:    "https://upload.qiniup.com", // ä¸ƒç‰›äº‘ä¸Šä¼ åœ°å€
        Key:    opts.Key,
        Method: "POST",
        Expire: time.Now().Add(opts.Expire),
        FormFields: map[string]string{
            "token": token,
            "key":   opts.Key,
        },
    }, nil
}

// å…¶ä»–æ–¹æ³•å®ç°...
```

---

### ğŸ”Œ æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ Providerï¼ˆç§æœ‰åŒ–éƒ¨ç½²ï¼‰

```go
// pkg/storage/local/provider.go

package local

import (
    "context"
    "crypto/md5"
    "fmt"
    "io"
    "os"
    "path/filepath"
    "time"
    
    "github.com/ai-agent-os/ai-agent-os/pkg/storage"
)

type LocalProvider struct {
    basePath  string // åŸºç¡€è·¯å¾„ï¼ˆå¦‚ "/data/uploads"ï¼‰
    baseURL   string // è®¿é—®åŸºç¡€ URLï¼ˆå¦‚ "http://localhost:8080/files"ï¼‰
}

func NewLocalProvider(basePath, baseURL string) (*LocalProvider, error) {
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(basePath, 0755); err != nil {
        return nil, err
    }
    
    return &LocalProvider{
        basePath: basePath,
        baseURL:  baseURL,
    }, nil
}

// GetUploadToken æœ¬åœ°å­˜å‚¨ä¸éœ€è¦ tokenï¼Œè¿”å›ä¸Šä¼  API åœ°å€
func (p *LocalProvider) GetUploadToken(ctx context.Context, opts *storage.UploadOptions) (*storage.UploadToken, error) {
    return &storage.UploadToken{
        URL:    fmt.Sprintf("%s/upload", p.baseURL),
        Key:    opts.Key,
        Method: "POST",
        Expire: time.Now().Add(opts.Expire),
    }, nil
}

// Upload ä¸Šä¼ æ–‡ä»¶åˆ°æœ¬åœ°ç£ç›˜
func (p *LocalProvider) Upload(ctx context.Context, reader io.Reader, opts *storage.UploadOptions) (*storage.FileInfo, error) {
    filePath := filepath.Join(p.basePath, opts.Key)
    
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    dir := filepath.Dir(filePath)
    if err := os.MkdirAll(dir, 0755); err != nil {
        return nil, err
    }
    
    // åˆ›å»ºæ–‡ä»¶
    file, err := os.Create(filePath)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    // å¤åˆ¶æ•°æ®å¹¶è®¡ç®—å“ˆå¸Œ
    hash := md5.New()
    written, err := io.Copy(io.MultiWriter(file, hash), reader)
    if err != nil {
        os.Remove(filePath) // æ¸…ç†å¤±è´¥çš„æ–‡ä»¶
        return nil, err
    }
    
    return &storage.FileInfo{
        Key:         opts.Key,
        URL:         fmt.Sprintf("%s/%s", p.baseURL, opts.Key),
        Size:        written,
        ContentType: opts.ContentType,
        Hash:        fmt.Sprintf("%x", hash.Sum(nil)),
        UploadedAt:  time.Now(),
        Metadata:    opts.Metadata,
    }, nil
}

// Download ä»æœ¬åœ°ç£ç›˜ä¸‹è½½æ–‡ä»¶
func (p *LocalProvider) Download(ctx context.Context, key string) (io.ReadCloser, error) {
    filePath := filepath.Join(p.basePath, key)
    return os.Open(filePath)
}

// å…¶ä»–æ–¹æ³•å®ç°...
```

---

### ğŸ”§ Storage Managerï¼ˆç»Ÿä¸€ç®¡ç†ï¼‰

```go
// pkg/storage/manager.go

package storage

import (
    "context"
    "fmt"
    "sync"
)

// Manager å­˜å‚¨ç®¡ç†å™¨ï¼ˆæ”¯æŒå¤šä¸ªå­˜å‚¨åç«¯ï¼‰
type Manager struct {
    providers map[string]Provider
    default   string
    mu        sync.RWMutex
}

func NewManager() *Manager {
    return &Manager{
        providers: make(map[string]Provider),
    }
}

// Register æ³¨å†Œå­˜å‚¨æä¾›è€…
func (m *Manager) Register(name string, provider Provider, isDefault bool) {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.providers[name] = provider
    if isDefault {
        m.default = name
    }
}

// GetProvider è·å–å­˜å‚¨æä¾›è€…
func (m *Manager) GetProvider(name string) (Provider, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    if name == "" {
        name = m.default
    }
    
    provider, ok := m.providers[name]
    if !ok {
        return nil, fmt.Errorf("storage provider %s not found", name)
    }
    
    return provider, nil
}

// GetUploadToken è·å–ä¸Šä¼ å‡­è¯
func (m *Manager) GetUploadToken(ctx context.Context, providerName string, opts *UploadOptions) (*UploadToken, error) {
    provider, err := m.GetProvider(providerName)
    if err != nil {
        return nil, err
    }
    
    return provider.GetUploadToken(ctx, opts)
}

// Upload ä¸Šä¼ æ–‡ä»¶
func (m *Manager) Upload(ctx context.Context, providerName string, reader io.Reader, opts *UploadOptions) (*FileInfo, error) {
    provider, err := m.GetProvider(providerName)
    if err != nil {
        return nil, err
    }
    
    return provider.Upload(ctx, reader, opts)
}

// å…¶ä»–æ–¹æ³•ä»£ç†...
```

---

## å››ã€å‰ç«¯ç»„ä»¶è®¾è®¡

### ğŸ“¦ FileUpload Widget

```typescript
// web/src/core/widgets/FileUploadWidget.ts

import { h } from 'vue'
import { ElUpload, ElButton, ElIcon, ElMessage } from 'element-plus'
import { Upload, Delete, Download } from '@element-plus/icons-vue'
import type { UploadFile, UploadRawFile } from 'element-plus'
import { BaseWidget } from './BaseWidget'
import type { FieldConfig } from '../types/field'
import { ReactiveFormDataManager } from '../managers/ReactiveFormDataManager'
import { api } from '@/api'

export interface FileItem {
  uid: string
  name: string
  size: number
  url: string
  type: string
  hash?: string
  uploadedAt?: string
}

export interface FileUploadConfig {
  accept?: string           // æ¥å—çš„æ–‡ä»¶ç±»å‹ï¼ˆå¦‚ "image/*", ".pdf"ï¼‰
  multiple?: boolean        // æ˜¯å¦æ”¯æŒå¤šæ–‡ä»¶ä¸Šä¼ 
  max_count?: number        // æœ€å¤§æ–‡ä»¶æ•°é‡
  max_size?: number         // æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆMBï¼‰
  storage_provider?: string // å­˜å‚¨æä¾›è€…ï¼ˆminio/qiniu/localï¼‰
  list_type?: 'text' | 'picture' | 'picture-card'
  drag?: boolean            // æ˜¯å¦æ”¯æŒæ‹–æ‹½ä¸Šä¼ 
}

export class FileUploadWidget extends BaseWidget {
  private config: FileUploadConfig
  private uploadToken: any = null
  private tokenExpire: Date | null = null

  constructor(
    field: FieldConfig,
    formManager: ReactiveFormDataManager | null,
    fieldPath: string
  ) {
    super(field, formManager, fieldPath)
    this.config = (field.widget?.config || {}) as FileUploadConfig
  }

  render() {
    const currentValue = this.getCurrentValue()
    const fileList = Array.isArray(currentValue?.raw) ? currentValue.raw : []

    return h('div', { class: 'file-upload-widget' }, [
      h(
        ElUpload,
        {
          action: '#', // ä¸ä½¿ç”¨é»˜è®¤ä¸Šä¼ 
          fileList: this.convertToElFileList(fileList),
          accept: this.config.accept,
          multiple: this.config.multiple,
          limit: this.config.max_count,
          listType: this.config.list_type || 'text',
          drag: this.config.drag,
          httpRequest: this.handleUpload.bind(this),
          beforeUpload: this.beforeUpload.bind(this),
          onRemove: this.handleRemove.bind(this),
          onPreview: this.handlePreview.bind(this),
          onExceed: () => {
            ElMessage.warning(`æœ€å¤šåªèƒ½ä¸Šä¼  ${this.config.max_count} ä¸ªæ–‡ä»¶`)
          }
        },
        {
          default: () => this.renderUploadButton(),
          tip: () => this.renderTip()
        }
      )
    ])
  }

  private renderUploadButton() {
    if (this.config.list_type === 'picture-card') {
      return h(ElIcon, { class: 'el-icon--upload' }, () => h(Upload))
    }
    
    if (this.config.drag) {
      return h('div', { class: 'el-upload__text' }, [
        h(ElIcon, { class: 'el-icon--upload' }, () => h(Upload)),
        h('div', 'å°†æ–‡ä»¶æ‹–åˆ°æ­¤å¤„ï¼Œæˆ–'),
        h('em', 'ç‚¹å‡»ä¸Šä¼ ')
      ])
    }
    
    return h(
      ElButton,
      { type: 'primary', icon: Upload },
      () => 'é€‰æ‹©æ–‡ä»¶'
    )
  }

  private renderTip() {
    const tips: string[] = []
    
    if (this.config.accept) {
      tips.push(`æ”¯æŒæ ¼å¼ï¼š${this.config.accept}`)
    }
    if (this.config.max_size) {
      tips.push(`å•ä¸ªæ–‡ä»¶ä¸è¶…è¿‡ ${this.config.max_size}MB`)
    }
    if (this.config.max_count) {
      tips.push(`æœ€å¤šä¸Šä¼  ${this.config.max_count} ä¸ªæ–‡ä»¶`)
    }
    
    if (tips.length === 0) return null
    
    return h('div', { class: 'el-upload__tip' }, tips.join('ï¼Œ'))
  }

  // ä¸Šä¼ å‰æ ¡éªŒ
  private async beforeUpload(file: UploadRawFile): Promise<boolean> {
    // æ ¡éªŒæ–‡ä»¶å¤§å°
    if (this.config.max_size) {
      const maxSizeBytes = this.config.max_size * 1024 * 1024
      if (file.size > maxSizeBytes) {
        ElMessage.error(`æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ ${this.config.max_size}MB`)
        return false
      }
    }
    
    // æ ¡éªŒæ–‡ä»¶ç±»å‹
    if (this.config.accept) {
      const accept = this.config.accept.split(',').map(s => s.trim())
      const fileType = file.type
      const fileName = file.name
      
      const isAccepted = accept.some(type => {
        if (type.startsWith('.')) {
          // æ‰©å±•ååŒ¹é…ï¼ˆå¦‚ ".pdf"ï¼‰
          return fileName.toLowerCase().endsWith(type.toLowerCase())
        } else if (type.endsWith('/*')) {
          // MIME ç±»å‹é€šé…ç¬¦ï¼ˆå¦‚ "image/*"ï¼‰
          const prefix = type.slice(0, -2)
          return fileType.startsWith(prefix)
        } else {
          // ç²¾ç¡® MIME ç±»å‹åŒ¹é…
          return fileType === type
        }
      })
      
      if (!isAccepted) {
        ElMessage.error(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼š${fileName}`)
        return false
      }
    }
    
    return true
  }

  // è‡ªå®šä¹‰ä¸Šä¼ 
  private async handleUpload(options: any) {
    const { file, onProgress, onSuccess, onError } = options
    
    try {
      // 1. è·å–ä¸Šä¼ å‡­è¯
      const token = await this.getUploadToken(file)
      
      // 2. ä¸Šä¼ æ–‡ä»¶
      const fileInfo = await this.uploadFile(file, token, onProgress)
      
      // 3. æ›´æ–°è¡¨å•æ•°æ®
      const currentFiles = this.getCurrentFileList()
      currentFiles.push({
        uid: file.uid,
        name: file.name,
        size: file.size,
        url: fileInfo.url,
        type: file.type,
        hash: fileInfo.hash,
        uploadedAt: new Date().toISOString()
      })
      
      this.updateValue(currentFiles)
      onSuccess(fileInfo)
      
      ElMessage.success('ä¸Šä¼ æˆåŠŸ')
    } catch (error: any) {
      onError(error)
      ElMessage.error(`ä¸Šä¼ å¤±è´¥ï¼š${error.message}`)
    }
  }

  // è·å–ä¸Šä¼ å‡­è¯
  private async getUploadToken(file: File) {
    // æ£€æŸ¥ token æ˜¯å¦è¿‡æœŸ
    if (this.uploadToken && this.tokenExpire && new Date() < this.tokenExpire) {
      return this.uploadToken
    }
    
    // è¯·æ±‚æ–°çš„ token
    const response = await api.post('/storage/upload-token', {
      provider: this.config.storage_provider || 'minio',
      key: this.generateFileKey(file),
      content_type: file.type,
      max_size: file.size,
      expire: 3600 // 1 å°æ—¶
    })
    
    this.uploadToken = response.data
    this.tokenExpire = new Date(response.data.expire)
    
    return this.uploadToken
  }

  // ä¸Šä¼ æ–‡ä»¶ï¼ˆæ ¹æ®ä¸åŒçš„å­˜å‚¨æä¾›è€…ä½¿ç”¨ä¸åŒçš„ä¸Šä¼ æ–¹å¼ï¼‰
  private async uploadFile(file: File, token: any, onProgress: (percent: number) => void) {
    if (token.method === 'PUT') {
      // MinIO é¢„ç­¾å URL ä¸Šä¼ 
      return this.uploadViaPut(file, token, onProgress)
    } else if (token.method === 'POST') {
      // ä¸ƒç‰›äº‘è¡¨å•ä¸Šä¼ 
      return this.uploadViaPost(file, token, onProgress)
    } else {
      throw new Error(`Unsupported upload method: ${token.method}`)
    }
  }

  // PUT æ–¹å¼ä¸Šä¼ ï¼ˆMinIOï¼‰
  private async uploadViaPut(file: File, token: any, onProgress: (percent: number) => void) {
    return new Promise<any>((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100)
          onProgress(percent)
        }
      })
      
      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          resolve({
            url: token.url.split('?')[0], // å»æ‰ç­¾åå‚æ•°
            hash: xhr.getResponseHeader('ETag') || '',
            key: token.key
          })
        } else {
          reject(new Error(`Upload failed: ${xhr.statusText}`))
        }
      })
      
      xhr.addEventListener('error', () => {
        reject(new Error('Upload failed'))
      })
      
      xhr.open('PUT', token.url)
      
      // è®¾ç½®è‡ªå®šä¹‰å¤´
      if (token.headers) {
        Object.entries(token.headers).forEach(([key, value]) => {
          xhr.setRequestHeader(key, value as string)
        })
      }
      
      xhr.send(file)
    })
  }

  // POST æ–¹å¼ä¸Šä¼ ï¼ˆä¸ƒç‰›äº‘ï¼‰
  private async uploadViaPost(file: File, token: any, onProgress: (percent: number) => void) {
    const formData = new FormData()
    
    // æ·»åŠ è¡¨å•å­—æ®µ
    if (token.form_fields) {
      Object.entries(token.form_fields).forEach(([key, value]) => {
        formData.append(key, value as string)
      })
    }
    
    formData.append('file', file)
    
    return new Promise<any>((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100)
          onProgress(percent)
        }
      })
      
      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const response = JSON.parse(xhr.responseText)
          resolve({
            url: `${token.cdn_url}/${response.key}`,
            hash: response.hash,
            key: response.key
          })
        } else {
          reject(new Error(`Upload failed: ${xhr.statusText}`))
        }
      })
      
      xhr.addEventListener('error', () => {
        reject(new Error('Upload failed'))
      })
      
      xhr.open('POST', token.url)
      xhr.send(formData)
    })
  }

  // ç§»é™¤æ–‡ä»¶
  private handleRemove(file: UploadFile) {
    const currentFiles = this.getCurrentFileList()
    const index = currentFiles.findIndex(f => f.uid === file.uid)
    if (index > -1) {
      currentFiles.splice(index, 1)
      this.updateValue(currentFiles)
    }
  }

  // é¢„è§ˆæ–‡ä»¶
  private handlePreview(file: UploadFile) {
    const fileItem = this.getCurrentFileList().find(f => f.uid === file.uid)
    if (fileItem?.url) {
      window.open(fileItem.url, '_blank')
    }
  }

  // ç”Ÿæˆæ–‡ä»¶å­˜å‚¨è·¯å¾„
  private generateFileKey(file: File): string {
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 8)
    const ext = file.name.split('.').pop()
    return `uploads/${this.fieldPath}/${timestamp}_${random}.${ext}`
  }

  // è·å–å½“å‰æ–‡ä»¶åˆ—è¡¨
  private getCurrentFileList(): FileItem[] {
    const value = this.getCurrentValue()
    return Array.isArray(value?.raw) ? value.raw : []
  }

  // æ›´æ–°å€¼
  private updateValue(files: FileItem[]) {
    this.setValue({
      raw: files,
      display: files.map(f => f.name).join(', '),
      meta: {}
    })
  }

  // è½¬æ¢ä¸º Element Plus çš„æ–‡ä»¶åˆ—è¡¨æ ¼å¼
  private convertToElFileList(files: FileItem[]): UploadFile[] {
    return files.map(file => ({
      uid: file.uid,
      name: file.name,
      url: file.url,
      status: 'success'
    }))
  }
}
```

---

## äº”ã€åç«¯ SDK è®¾è®¡

### ğŸ“¦ Files ç±»å‹å®šä¹‰

```go
// sdk/agent-app/model/files.go

package model

import (
    "context"
    "database/sql/driver"
    "encoding/json"
    "fmt"
    "io"
    "time"
)

// Files æ–‡ä»¶é›†åˆç±»å‹
type Files struct {
    items []FileItem
    storage StorageClient // å­˜å‚¨å®¢æˆ·ç«¯ï¼ˆç”¨äºè‡ªåŠ¨ä¸Šä¼ ï¼‰
}

// FileItem å•ä¸ªæ–‡ä»¶ä¿¡æ¯
type FileItem struct {
    UID        string            `json:"uid"`
    Name       string            `json:"name"`
    Size       int64             `json:"size"`
    URL        string            `json:"url"`
    Type       string            `json:"type"`
    Hash       string            `json:"hash,omitempty"`
    UploadedAt string            `json:"uploaded_at,omitempty"`
    Metadata   map[string]string `json:"metadata,omitempty"`
}

// NewFiles åˆ›å»º Files å®ä¾‹
func NewFiles(storage StorageClient) *Files {
    return &Files{
        items:   make([]FileItem, 0),
        storage: storage,
    }
}

// Add æ·»åŠ æ–‡ä»¶
func (f *Files) Add(item FileItem) {
    f.items = append(f.items, item)
}

// Get è·å–æ‰€æœ‰æ–‡ä»¶
func (f *Files) Get() []FileItem {
    return f.items
}

// First è·å–ç¬¬ä¸€ä¸ªæ–‡ä»¶
func (f *Files) First() *FileItem {
    if len(f.items) == 0 {
        return nil
    }
    return &f.items[0]
}

// Count æ–‡ä»¶æ•°é‡
func (f *Files) Count() int {
    return len(f.items)
}

// IsEmpty æ˜¯å¦ä¸ºç©º
func (f *Files) IsEmpty() bool {
    return len(f.items) == 0
}

// DownloadFirst ä¸‹è½½ç¬¬ä¸€ä¸ªæ–‡ä»¶åˆ°æœ¬åœ°ï¼ˆç”¨äºåç«¯å¤„ç†ï¼‰
func (f *Files) DownloadFirst(ctx context.Context, localPath string) error {
    if f.IsEmpty() {
        return fmt.Errorf("no files to download")
    }
    
    first := f.items[0]
    reader, err := f.storage.Download(ctx, first.URL)
    if err != nil {
        return err
    }
    defer reader.Close()
    
    // å†™å…¥æœ¬åœ°æ–‡ä»¶
    file, err := os.Create(localPath)
    if err != nil {
        return err
    }
    defer file.Close()
    
    _, err = io.Copy(file, reader)
    return err
}

// UploadFile ä¸Šä¼ æ–‡ä»¶ï¼ˆç”¨äºåç«¯ç”Ÿæˆæ–‡ä»¶åä¸Šä¼ ï¼‰
func (f *Files) UploadFile(ctx context.Context, localPath string, filename string) error {
    file, err := os.Open(localPath)
    if err != nil {
        return err
    }
    defer file.Close()
    
    stat, err := file.Stat()
    if err != nil {
        return err
    }
    
    // ä¸Šä¼ æ–‡ä»¶
    fileInfo, err := f.storage.Upload(ctx, file, &storage.UploadOptions{
        Key:         generateFileKey(filename),
        ContentType: getContentType(filename),
        MaxSize:     stat.Size(),
    })
    if err != nil {
        return err
    }
    
    // æ·»åŠ åˆ°åˆ—è¡¨
    f.Add(FileItem{
        UID:        generateUID(),
        Name:       filename,
        Size:       fileInfo.Size,
        URL:        fileInfo.URL,
        Type:       fileInfo.ContentType,
        Hash:       fileInfo.Hash,
        UploadedAt: fileInfo.UploadedAt.Format(time.RFC3339),
    })
    
    return nil
}

// Scan å®ç° sql.Scanner æ¥å£ï¼ˆä»æ•°æ®åº“è¯»å–ï¼‰
func (f *Files) Scan(value interface{}) error {
    if value == nil {
        f.items = make([]FileItem, 0)
        return nil
    }
    
    bytes, ok := value.([]byte)
    if !ok {
        return fmt.Errorf("failed to unmarshal Files value: %v", value)
    }
    
    return json.Unmarshal(bytes, &f.items)
}

// Value å®ç° driver.Valuer æ¥å£ï¼ˆå†™å…¥æ•°æ®åº“ï¼‰
func (f Files) Value() (driver.Value, error) {
    if len(f.items) == 0 {
        return "[]", nil
    }
    
    bytes, err := json.Marshal(f.items)
    if err != nil {
        return nil, err
    }
    
    return string(bytes), nil
}

// MarshalJSON å®ç° JSON åºåˆ—åŒ–
func (f Files) MarshalJSON() ([]byte, error) {
    return json.Marshal(f.items)
}

// UnmarshalJSON å®ç° JSON ååºåˆ—åŒ–
func (f *Files) UnmarshalJSON(data []byte) error {
    return json.Unmarshal(data, &f.items)
}
```

---

### ä½¿ç”¨ç¤ºä¾‹

```go
// åœºæ™¯1ï¼šåç«¯å¤„ç†æ–‡ä»¶ï¼ˆå¦‚è§†é¢‘è½¬æ¢ï¼‰

package tools

import (
    "context"
    "github.com/ai-agent-os/ai-agent-os/sdk/agent-app/app"
    "github.com/ai-agent-os/ai-agent-os/sdk/agent-app/model"
)

type VideoTranscode struct {
    InputVideo  *model.Files `json:"input_video" runner:"name:è¾“å…¥è§†é¢‘" widget:"type:file_upload;accept:video/*"`
    Format      string       `json:"format" runner:"name:è¾“å‡ºæ ¼å¼" widget:"type:select;options:mp4,avi,mkv,mov"`
    OutputVideo *model.Files `json:"output_video" runner:"name:è¾“å‡ºè§†é¢‘" permission:"read"`
}

func (VideoTranscode) TableName() string { return "video_transcode" }

func init() {
    app.Register(&app.Function{
        Code: "video_transcode",
        Name: "è§†é¢‘è½¬ç ",
        OnSubmit: func(ctx context.Context, req *VideoTranscode) (*VideoTranscode, error) {
            // 1. ä¸‹è½½è¾“å…¥è§†é¢‘
            inputPath := "/tmp/input.mp4"
            if err := req.InputVideo.DownloadFirst(ctx, inputPath); err != nil {
                return nil, err
            }
            
            // 2. è°ƒç”¨ FFmpeg è½¬ç 
            outputPath := "/tmp/output." + req.Format
            if err := transcode(inputPath, outputPath, req.Format); err != nil {
                return nil, err
            }
            
            // 3. ä¸Šä¼ è¾“å‡ºè§†é¢‘
            req.OutputVideo = model.NewFiles(app.GetStorage())
            if err := req.OutputVideo.UploadFile(ctx, outputPath, "output."+req.Format); err != nil {
                return nil, err
            }
            
            return req, nil
        },
    })
}
```

```go
// åœºæ™¯2ï¼šåç«¯åªå­˜å‚¨å…ƒæ•°æ®ï¼ˆå¦‚å·¥å•é™„ä»¶ï¼‰

type Ticket struct {
    ID          int          `json:"id" gorm:"primaryKey"`
    Title       string       `json:"title" runner:"name:æ ‡é¢˜" widget:"type:input"`
    Description string       `json:"description" runner:"name:æè¿°" widget:"type:textarea"`
    Attachments *model.Files `json:"attachments" runner:"name:é™„ä»¶" widget:"type:file_upload;multiple:true;max_count:5"`
}

func (Ticket) TableName() string { return "tickets" }

// åç«¯æ— éœ€å¤„ç†æ–‡ä»¶ï¼ŒFiles ä¼šè‡ªåŠ¨åºåˆ—åŒ–/ååºåˆ—åŒ–
```

---

## å…­ã€éƒ¨ç½²é…ç½®

### ğŸ”§ é…ç½®æ–‡ä»¶ç¤ºä¾‹

```yaml
# configs/storage.yaml

storage:
  # é»˜è®¤å­˜å‚¨æä¾›è€…
  default: minio
  
  # MinIO é…ç½®ï¼ˆæ¨èç”¨äºç§æœ‰åŒ–éƒ¨ç½²ï¼‰
  minio:
    endpoint: localhost:9000
    access_key: minioadmin
    secret_key: minioadmin
    bucket: ai-agent-os
    region: us-east-1
    use_ssl: false
    
  # ä¸ƒç‰›äº‘é…ç½®ï¼ˆæ¨èç”¨äºäº‘ç«¯éƒ¨ç½²ï¼‰
  qiniu:
    access_key: your_access_key
    secret_key: your_secret_key
    bucket: ai-agent-os
    domain: https://cdn.yourdomain.com
    
  # æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆå¼€å‘ç¯å¢ƒï¼‰
  local:
    base_path: /data/uploads
    base_url: http://localhost:8080/files
```

---

## ä¸ƒã€å®‰å…¨æ€§è®¾è®¡

### ğŸ›¡ï¸ æ ¸å¿ƒå®‰å…¨æªæ–½

#### 1. ä¸Šä¼ å‡­è¯ç­¾å
```go
// é˜²æ­¢æ¶æ„ä¸Šä¼ ï¼Œæ‰€æœ‰ä¸Šä¼ å¿…é¡»å…ˆè·å–ç­¾åå‡­è¯
token, err := storage.GetUploadToken(ctx, &storage.UploadOptions{
    Key:     generateSecureKey(), // æœåŠ¡ç«¯ç”Ÿæˆ key
    Expire:  time.Hour,            // é™åˆ¶æœ‰æ•ˆæœŸ
    MaxSize: 100 * 1024 * 1024,   // é™åˆ¶æ–‡ä»¶å¤§å°
})
```

#### 2. æ–‡ä»¶ç±»å‹æ ¡éªŒ
```go
// å‰ç«¯æ ¡éªŒï¼ˆç”¨æˆ·ä½“éªŒï¼‰
if !isAcceptedType(file.type, acceptTypes) {
    return error("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹")
}

// åç«¯æ ¡éªŒï¼ˆå®‰å…¨ï¼‰
if !isValidFileType(uploadedFile) {
    return error("æ–‡ä»¶ç±»å‹æ ¡éªŒå¤±è´¥")
}
```

#### 3. ç—…æ¯’æ‰«æï¼ˆå¯é€‰ï¼Œä¼ä¸šç‰ˆï¼‰
```go
// ä¸Šä¼ åè‡ªåŠ¨æ‰«æ
if config.EnableVirusScan {
    if infected, err := virusScanner.Scan(filePath); infected {
        storage.Delete(ctx, fileKey)
        return error("æ£€æµ‹åˆ°æ¶æ„æ–‡ä»¶")
    }
}
```

#### 4. è®¿é—®æƒé™æ§åˆ¶
```go
// ä¸´æ—¶ç­¾å URLï¼ˆç§æœ‰æ–‡ä»¶ï¼‰
url, err := storage.GetURL(ctx, fileKey, time.Hour)

// å…¬å¼€ URLï¼ˆå…¬å…±æ–‡ä»¶ï¼‰
url, err := storage.GetURL(ctx, fileKey, 0)
```

---

## å…«ã€æ¨èæ–¹æ¡ˆæ€»ç»“

### âœ… æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|----------|------|
| **ç§æœ‰åŒ–éƒ¨ç½²** | MinIO | å¼€æºã€å…¼å®¹ S3ã€æ˜“éƒ¨ç½² |
| **äº‘ç«¯éƒ¨ç½²** | ä¸ƒç‰›äº‘/é˜¿é‡Œäº‘ OSS | CDN åŠ é€Ÿã€ç¨³å®šå¯é  |
| **å¼€å‘ç¯å¢ƒ** | æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ | ç®€å•å¿«é€Ÿ |
| **ä¼ä¸šç‰ˆ** | æ”¯æŒå¤šç§å­˜å‚¨ | çµæ´»é…ç½® |

---

### ğŸ“‹ å®æ–½ä¼˜å…ˆçº§

1. **Phase 1**ï¼ˆæ ¸å¿ƒï¼Œ2-3 å‘¨ï¼‰
   - âœ… å®ç°å­˜å‚¨æŠ½è±¡å±‚ï¼ˆProvider æ¥å£ï¼‰
   - âœ… å®ç° MinIO Providerï¼ˆç§æœ‰åŒ–éƒ¨ç½²ï¼‰
   - âœ… å®ç°æœ¬åœ° Providerï¼ˆå¼€å‘ç¯å¢ƒï¼‰
   - âœ… å®ç° FileUpload Widgetï¼ˆå‰ç«¯ï¼‰
   - âœ… å®ç° Files ç±»å‹ï¼ˆåç«¯ SDKï¼‰

2. **Phase 2**ï¼ˆæ‰©å±•ï¼Œ1-2 å‘¨ï¼‰
   - âœ… å®ç°ä¸ƒç‰›äº‘ Provider
   - âœ… å®ç°é˜¿é‡Œäº‘ OSS Provider
   - âœ… æ·»åŠ æ–‡ä»¶é¢„è§ˆåŠŸèƒ½
   - âœ… æ·»åŠ å›¾ç‰‡è£å‰ªåŠŸèƒ½

3. **Phase 3**ï¼ˆä¼˜åŒ–ï¼ŒæŒ‰éœ€ï¼‰
   - âœ… ç—…æ¯’æ‰«æ
   - âœ… å›¾ç‰‡å‹ç¼©
   - âœ… æ°´å°æ·»åŠ 
   - âœ… æ–‡ä»¶è½¬æ¢æœåŠ¡

---

## ä¹ã€æ€»ç»“

### æ ¸å¿ƒè®¾è®¡æ€æƒ³

1. **æŠ½è±¡ä¼˜å…ˆ** - Provider æ¥å£æŠ½è±¡å­˜å‚¨ç»†èŠ‚
2. **èŒè´£åˆ†ç¦»** - å‰ç«¯ä¸Šä¼ ã€åç«¯å¤„ç†ã€å­˜å‚¨æœåŠ¡ç‹¬ç«‹
3. **çµæ´»é…ç½®** - æ”¯æŒå¤šç§å­˜å‚¨åç«¯ï¼Œä¸€é”®åˆ‡æ¢
4. **å®‰å…¨ç¬¬ä¸€** - ç­¾åä¸Šä¼ ã€ç±»å‹æ ¡éªŒã€æƒé™æ§åˆ¶

### å…³é”®ä¼˜åŠ¿

- âœ… æ”¯æŒç§æœ‰åŒ–éƒ¨ç½²ï¼ˆMinIOï¼‰
- âœ… æ”¯æŒäº‘ç«¯éƒ¨ç½²ï¼ˆä¸ƒç‰›äº‘ã€é˜¿é‡Œäº‘ï¼‰
- âœ… æ”¯æŒå¤šç§å­˜å‚¨åç«¯ï¼Œå¯æ‰©å±•
- âœ… å‰åç«¯è§£è€¦ï¼Œæ˜“ç»´æŠ¤
- âœ… å®‰å…¨å¯é ï¼Œç¬¦åˆä¼ä¸šæ ‡å‡†

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆå¯ä»¥æ»¡è¶³ä½ é¡¹ç›®çš„æ‰€æœ‰éœ€æ±‚ï¼Œæ—¢æ”¯æŒäº‘ç«¯éƒ¨ç½²ï¼Œä¹Ÿæ”¯æŒç§æœ‰åŒ–éƒ¨ç½²ï¼Œè¿˜ä¸ºæœªæ¥çš„æ‰©å±•ç•™è¶³äº†ç©ºé—´ï¼ğŸš€

