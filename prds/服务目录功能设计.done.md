服务目录 
就是每个app可以创建服务目录，这个服务目录是一个树形结构的，跟文件夹一样，
创建服务目录的server侧的体现是，新增ServiceTree记录


然后runtime侧的体现是啥？是在
对应app的代码目录的api下面创建 服务目录名字的package，然后在
package 下面创建一个init_.go 的文件，假设我们创建的服务目录名字是crm，假设这个服务目录的层级是一级
```go

package crm

import "fmt"

const (
	RouterGroup = "/crm"
)

func WithCurrentRouterGroup(router string) string {
	return fmt.Sprintf("%s/%s", RouterGroup, router)
}

```

假设我在crm目录下又创建了一个目录，这个目录叫 ticket的话这个文件是这样的


```go
package ticket

import "fmt"

const (
	RouterGroup = "/crm/ticket"
)

func WithCurrentRouterGroup(router string) string {
	return fmt.Sprintf("%s/%s", RouterGroup, router)
}
```


技术侧的实现方案，其实跟创建app的逻辑差不多，都是在server侧发送nats的消息，接收到nats的消息后创建即可，
这个无需重新编译因为没有新增或者修改代码,

2025年10月26日15点,补充main文件更新功能
再创建服务目录的时候
这里需要补充一点，假如我创建了一个crm的服务目录，创建了以上的操作以后，我还需要在main文件把刚刚的那个包给引入，为啥？因为只有引入以后我们的包才会被编译，要不然那个目录下的
路由不会被注册，

	_ "github.com/ai-agent-os/ai-agent-os/namespace/beiluo/test777/code/api/crm"
 	_ "github.com/ai-agent-os/ai-agent-os/namespace/${user}/${app}/code/api/${RouterGroup}"
```go
package main

import (
	_ "github.com/ai-agent-os/ai-agent-os/namespace/beiluo/test777/code/api/crm"
	"github.com/ai-agent-os/ai-agent-os/sdk/agent-app/app"
)

func main() {
	err := app.Run()
	if err != nil {
		panic(err)
	}
}

```
