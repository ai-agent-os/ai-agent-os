由于旧版本代码封装的不够好，复用性差，导致难以新增组件，另外核心文件已经快上万行代码了，已经无法优化了，成屎山了，所以我们要重构
删除一些不重要的逻辑，保留核心逻辑，另外我们的form的输入参数是会相当复杂的，例如list组件，其实对应的后端是一个go的结构体切片
这样的话，其实我们要做到能解析嵌套的数据，会非常麻烦，不容小觑

需要注意的点是啥
在旧版本里我们有OnInputFuzzy (只有select和多选select存在这个回调)
他的用法是啥？其实前端是一个select选择器，当字段的callback里存在OnInputFuzzy这个回调时候，会像table的回调一样触发回调，然后后端会去查询数据，然后返回数据

## 注意这是旧版本的（form函数），非当前使用的逻辑
函数：收银台

```go
type RetailSimpleCashierDeskReq struct {

    // 会员卡选择
    MemberID int `json:"member_id" runner:"name:会员卡" widget:"type:select" callback:"OnInputFuzzy" validate:"required" msg:"请选择会员卡"`

	// 商品数量列表
	ProductQuantities []RetailSimpleCashierProductQuantity `json:"product_quantities" runner:"name:商品清单" widget:"type:list" validate:"required,min=1" msg:"请至少选择一件商品"`
	
	// 备注信息
	Remarks string `json:"remarks" runner:"name:备注" widget:"type:input;mode:text_area"`
}

type RetailSimpleCashierProductQuantity struct {
    ProductID int `json:"product_id" runner:"name:商品" widget:"type:select" callback:"OnInputFuzzy" validate:"required" msg:"请选择商品"`
    Quantity  int `json:"quantity" runner:"name:数量" widget:"type:number;min:1" data:"example:1;default_value:1" validate:"required,min=1" msg:"数量必须大于0"`
}
```

场景1：收银台选择会员卡的select回调member_id 的回调，（此时我们回调返回了一条记录）
这个回调的特殊的是，我们选中后要用中文展示，但是提交时候要用value来提交也就是1，display_info是我们点击输入框时候回调返回的数据我们可以把display_info当作框当作k,v 来展示描述说明
```json
{
    "meta_data": {
        "cost": "473.126µs",
        "cost_memory": "22536",
        "memory": "2.85 MB",
        "method": "POST",
        "router": "_callback",
        "runner": "demo6",
        "trace_id": "20251030174025-gxw5aszh-zkmu0mi5-02nr6vqr-tqbxkjm5",
        "url_query": "",
        "user": "beiluo",
        "version": "v12",
        "x-user": "beiluo"
    },
    "headers": null,
    "code": 0,
    "msg": "ok",
    "trace_id": "20251030174025-gxw5aszh-zkmu0mi5-02nr6vqr-tqbxkjm5",
    "render_type": "form",
    "data": {
        "statistics": null,
        "values": [
            {
                "display_info": {
                    "余额": 9970.300000000001,
                    "卡号": "123",
                    "客户姓名": "刘北洛"
                },
                "icon": "",
                "label": "123 - 刘北洛 (余额:¥9970.30)",
                "value": 1
            }
        ]
    },
    "data_list": null,
    "multiple": false
}
```

还是这个收银台的函数
场景2
收银台商品数量列表新增商品
product_quantities是一个前端的表格，我们可以点击新增弹出弹窗，然后输入记录，当点击商品（product_id）时候会立刻弹出弹窗然后触发回调，返回以下数据


```json
{
  "meta_data": {
    "cost": "479.929µs",
    "cost_memory": "23624",
    "memory": "2.93 MB",
    "method": "POST",
    "router": "_callback",
    "runner": "demo6",
    "trace_id": "20251030173806-ygg38i8s-71utt5sy-m61nlhyb-wio9nx3e",
    "url_query": "",
    "user": "beiluo",
    "version": "v12",
    "x-user": "beiluo"
  },
  "headers": null,
  "code": 0,
  "msg": "ok",
  "trace_id": "20251030173806-ygg38i8s-71utt5sy-m61nlhyb-wio9nx3e",
  "render_type": "form",
  "data": {
    "statistics": {
      "优惠金额(元)": "sum(价格,*quantity,*0.1)",
      "会员价格(元)": "sum(价格,*quantity,*0.9)",
      "会员折扣": "9折优惠",
      "商品原价(元)": "sum(价格,*quantity)",
      "商品总数": "sum(quantity)",
      "商品种类": "count(价格)",
      "配送说明": "满99元包邮"
    },
    "values": [
      {
        "display_info": {
          "价格": 5,
          "商品名称": "百事可乐",
          "库存": 97
        },
        "icon": "",
        "label": "百事可乐 - ¥5.00 (库存:97)",
        "value": 1
      },
      {
        "display_info": {
          "价格": 6,
          "商品名称": "薯片",
          "库存": 97
        },
        "icon": "",
        "label": "薯片 - ¥6.00 (库存:97)",
        "value": 2
      }
    ]
  },
  "data_list": null,
  "multiple": false
}
```

这个数据更复杂一些，还包含了聚合数据statistics，这个的作用就是，统计你选择的指标，什么时候支持返回统计信息？
list内包含select
select支持多选的情况下，例如这个member_id支持多选，我们可以选择多个会员卡的情况，我们也会发展示聚合信息
statistics聚合计算的参数我们取display_info和当前的例如RetailSimpleCashierProductQuantity的同级这两个，例如“价格”从display_info取，quantity从RetailSimpleCashierProductQuantity取
这样我们就做到一个聚合计算的逻辑，无需前端写了


注意以上是旧版的，我只是想表达一下，我们的form函数没有那么简单


同样，table函数的字段也支持 OnInputFuzzy

## 新版本的思考？
新版本我们打算换一个名字，我们打算换成OnSelectFuzzy或者直接叫OnSelect？ 意味着这个是select组件的专属回调

我们的这个旧版的OnInputFuzzy可以说是一个王者级别的功能，整个系统最复杂，但是又最有用，交互性最强的一个功能了，他的存在给代码带来了巨大的复杂度，但是没他做不了复杂的逻辑
真的是又爱又恨，综合之下我们新版本还是选择保留这个功能，


旧版本还支持by_values这种方式
为啥需要这个？
因为旧版本强的可怕
旧版本的form表单和table函数，只要你输入参数，我们都会把参数记录到url上面，这样我们可以把填好的表单当链接发送给别人，别人连填都不用填，直接在地址栏粘贴回车即可渲染出填好的表单
但是此时有个问题就是像select这种，我们展示的是中文，但是存储的是id这种的，我们怎么办？

这是我们旧版本的办法，能识别出是地址栏直接粘贴的那种，我们直接去load这个数据了（我把这个过程称之为：回想），通过添加"input_type": "by_field_value", 来标识这个是通过value的值来查询的
```json
{
  "code": "member_id",
  "_code": "member_id",
  "value": 1,
  "request": {
    "product_quantities": [
      {
        "product_id": 1,
        "quantity": 1
      },
      {
        "product_id": 2,
        "quantity": 1
      }
    ],
    "member_id": 1,
    "remarks": "测试"
  },
  "input_type": "by_field_value",
  "value_type": "number"
}
```
下面是响应结果
```json
{
    "meta_data": {
        "cost": "410.459µs",
        "cost_memory": "19560",
        "memory": "2.91 MB",
        "method": "POST",
        "router": "_callback",
        "runner": "demo6",
        "trace_id": "20251030182603-hdbw1qh7-qknb10k6-jdmz0oli-y5kgunf7",
        "url_query": "",
        "user": "beiluo",
        "version": "v12",
        "x-user": "beiluo"
    },
    "headers": null,
    "code": 0,
    "msg": "ok",
    "trace_id": "20251030182603-hdbw1qh7-qknb10k6-jdmz0oli-y5kgunf7",
    "render_type": "form",
    "data": {
        "statistics": null,
        "values": [
            {
                "display_info": {
                    "余额": 9970.300000000001,
                    "卡号": "123",
                    "客户姓名": "刘北洛"
                },
                "icon": "",
                "label": "123 - 刘北洛 (余额:¥9970.30)",
                "value": 1
            }
        ]
    },
    "data_list": null,
    "multiple": false
}
```


假如正常输入，我们可以模糊查询是这样的input_type没填写，这样我们会从数据库模糊查询然后返回让用户自己选择

```json
{
  "code": "member_id",
  "_code": "member_id",
  "value": "刘",
  "request": {
    "product_quantities": [
      {
        "product_id": 1,
        "quantity": 1
      },
      {
        "product_id": 2,
        "quantity": 1
      }
    ],
    "member_id": 1,
    "remarks": "测试"
  }
}
```


总之这个是想表达的是，form的数据结构是非常复杂的，需要支持各种嵌套，另外还要支持，支持回想，是个非常复杂的工程，旧版本经常出现提交时候字段类型和后端预期不同的问题，其实就是前端没有做好转换
预期我想的是，我们需要一个通用的form提交方法，在提交时候把函数的详情带进去，然后再和formData做check，类型不对的要帮忙转换成函数详情的类型，统一在这个底层的函数内做转换，
formData复杂一些无所谓，最终我们的目的只是提交时候数据对就可，所以，这一块我们要好好设计，需要花大量时间思考，另外怎么做嵌套组件的递归渲染和字段数据的存储呢？另外后续扩展新组件怎么办呢？

旧版本我们都是没有做好这个最核心的点导致我们所有的努力都白费了，因为这个是最核心的逻辑，我们没做好，其他的做的再好没意义，所以这是旧版失败的原因，旧版本现在来看如果不考虑技术层面，那说他是高富帅“吴彦祖”也不为过
主题非常漂亮，渲染的界面非常漂亮，支持的组件也非常，功能也很多，支持空间用例，例如我们把填好的表单，直接保存，就像是保存一个链接一样，后续别人可以根据用用例快速打开表单
这样方便省事，省的从头开始输入表单，好处可太多了举例
我们有个证书申请的表单，参数非常复杂，我们没有用例的话，需要张嘴问来问去，还容易填错，但是一旦有了用例，我们官方可以直接把表单填好，例如
一年-ca证书-通配符-亚数厂商-(腾讯系)
三年-xx证书-通配符-gs厂商-(阿里系)
这种，直接帮我填好那种，方便的很，题外话吧，反正我们新版本要把核心的功能做好再考虑这些功能

