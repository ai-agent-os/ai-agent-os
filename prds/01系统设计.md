整个系统的设计思路是这样的，一个应用代表一个go的项目，一个服务目录代表一个go的package，一个go的文件（function）代表一个系统
一个app可以包含无数个服务目录，一个服务目录下可以包含无数个系统，就是这么个逻辑，

目前的逻辑是我们的每个文件都是基于sdk写的，我们的sdk是高度封装的，跟我们的runtime引擎是完美契合的，他们穿一条裤子的，量身定做的

整体流程，
用户线创建一个应用（工作空间）假如叫tencent_oa
然后用户又创建了一个服务目录（类似menu的分组）叫crm（客户服务）
然后用户在前端crm服务目录里打开对话框
用户：我需要一个工单管理系统
1分钟后，大模型（[llm-coder](../core/llm-coder) 还没实现）基于我的sdk生成了下面的crm_ticket.go文件，

```go
//<文件>crm_ticket.go</文件>
package crm

import (
	"github.com/ai-agent-os/ai-agent-os/pkg/gormx/query"
	"github.com/ai-agent-os/ai-agent-os/sdk/agent-app/app"
	"github.com/ai-agent-os/ai-agent-os/sdk/agent-app/callback"
	"github.com/ai-agent-os/ai-agent-os/sdk/agent-app/response"
	"gorm.io/gorm"
)

type CrmTicket struct {
	// 框架标签：runner:"name:工单ID" - 设置字段在前端的显示名称
	// 框架标签：permission:"read" - 字段只读权限（不能编辑）
	// 注意：gorm:"column:id" 明确指定数据库列名，确保映射正确
	ID int `json:"id" gorm:"primaryKey;autoIncrement;column:id" widget:"name:ID;type:ID" permission:"read"` //在table 表格里只读，不能编辑

	// 框架标签：widget:"type:timestamp;format:YYYY-MM-DD HH:mm:ss" - 日期时间选择器组件
	// 注意：gorm:"autoCreateTime:milli" 自动填充创建时间（毫秒级时间戳，必须是毫秒级别）
	CreatedAt int64 `json:"created_at" gorm:"autoCreateTime:milli;column:created_at"  widget:"name:创建时间;type:timestamp;format:YYYY-MM-DD HH:mm:ss" permission:"read"`

	// 框架标签：widget:"type:timestamp;format:YYYY-MM-DD HH:mm:ss" - 日期时间选择器组件，（毫秒级时间戳，必须是毫秒级别）
	UpdatedAt int64 `json:"updated_at" gorm:"autoUpdateTime:milli;column:updated_at" widget:"name:更新时间;type:timestamp;format:YYYY-MM-DD HH:mm:ss" permission:"read"`

	// 框架标签：widget:"-" - 隐藏字段（不在前端显示）
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index;column:deleted_at" widget:"-"` //不做展示

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,min=2,max=200" - 必填字段，长度2-200字符
	Title string `json:"title" gorm:"column:title" widget:"name:工单标题;type:input" search:"like" validate:"required,min=2,max=200"` //该字段支持模糊搜索，同时新增时候前端会验证validate，后端sdk内部也会验证

	// 框架标签：widget:"type:text_area" - 多行文本区域组件
	// 框架标签：validate:"required,min=10" - 必填字段，至少10字符
	Description string `json:"description" gorm:"column:description" widget:"name:问题描述;type:text_area" validate:"required,min=10"`

	// 框架标签：widget:"type:select;options:低,中,高;default:中" - 下拉选择组件（选项：低/中/高）
	// 框架标签：validate:"required,oneof=低,中,高" - 必填字段，值必须是选项之一
	Priority string `json:"priority" gorm:"column:priority" widget:"name:优先级;type:select;options:低,中,高;default:中" validate:"required,oneof=低,中,高"`

	// 框架标签：widget:"type:select;options:待处理,处理中,已完成,已关闭;default:待处理" - 下拉选择组件
	// 框架标签：validate:"required,oneof=待处理,处理中,已完成,已关闭" - 值必须是有效状态
	Status string `json:"status" gorm:"column:status"  widget:"name:工单状态;type:select;options:待处理,处理中,已完成,已关闭;default:待处理" validate:"required,oneof=待处理,处理中,已完成,已关闭"`

	// 框架标签：validate:"required,min=11,max=20" - 必填字段，长度11-20字符
	Phone string `json:"phone" gorm:"column:phone" widget:"name:联系电话;type:input" validate:"required,min=11,max=20"`

	// 框架标签：widget:"type:text_area" - 多行文本区域组件
	Remark string `json:"remark" gorm:"column:remark"  widget:"name:备注;type:text_area"`

	// 创建用户：用户组件
	CreateBy string `json:"create_by" gorm:"column:create_by" widget:"name:创建用户;type:user" permission:"read"` //read 表示只读，表示要后端赋值的，非read的字段前端界面会自动渲染成用户选择器进行选择
}

func (t *CrmTicket) TableName() string {
	return "crm_ticket"
}

var CrmTicketTemplate = &app.TableTemplate{
	BaseConfig: app.BaseConfig{
		Name:     "工单管理",
		Tags:     []string{"工单管理系统"},
		Desc:     "一个简单的工单管理系统 ........",
		Request:  &CrmTicketSearchReq{},
		Response: []*CrmTicket{},
		CreateTables: []interface{}{
			&CrmTicket{},
		},
	},
	AutoCrudTable: &CrmTicket{},

	OnTableAddRow: func(ctx *app.Context, req *callback.OnTableAddRowReq) (*callback.OnTableAddRowResp, error) {
		db := ctx.GetGormDB()
		var row CrmTicket
		if err := ctx.ShouldBindValidate(&row); err != nil { //这里内部会用validate的库验证validate的标签
			return nil, err
		}
		row.CreateBy = ctx.GetRequestUser() //获取请求用户
		err := db.Create(&row).Error
		if err != nil {
			return nil, err
		}
		//这里还没想好要返回什么有价值的信息，先留空吧
		return &callback.OnTableAddRowResp{}, nil
	},
	OnTableUpdateRows: func(ctx *app.Context, req *callback.OnTableUpdateRowReq) (*callback.OnTableUpdateRowResp, error) {
		db := ctx.GetGormDB()
		var updateFields CrmTicket
		if err := ctx.ShouldBind(&updateFields); err != nil { //这里不会验证validate，为啥？因为前端只传递了变更的字段，所以无需验证，所以updateFields只有 更新的字段才会有值，没更新的字段是零值
			return nil, err
		}
		//注意：updateFields主要是方便安全的操作变更的字段，如果更新数据我们还是配合用req.GetUpdates()来，这样例如某些字符串想更新成空，或者int想更新成0是可以实现的，
		//用updateFields 的话，gorm是无法更新零值的

		updates := req.GetUpdates()                                   //-> map[string]interface{} 这里值包含此次变更的字段，例如用户把status 变更成：“已完成”，那么这里的map就是只有一个 status:已完成
		err := db.Where("id = ?", req.GetId()).Updates(updates).Error //这是标准的更新方式
		if err != nil {
			return nil, err
		}
		//这里还没想好要返回什么有价值的信息，先留空吧
		return &callback.OnTableUpdateRowResp{}, nil
	},
	OnTableDeleteRows: func(ctx *app.Context, req *callback.OnTableDeleteRowsReq) (*callback.OnTableDeleteRowsResp, error) {
		db := ctx.GetGormDB()
		err := db.Delete(&CrmTicket{}, "id in ?", req.GetIds()).Error
		if err != nil {
			return nil, err
		}

		//这里还没想好要返回什么有价值的信息，先留空吧
		return &callback.OnTableDeleteRowsResp{}, nil
	},
}

type CrmTicketSearchReq struct {
	*query.SearchFilterPageReq //前端会传递符合框架规范的查询字符串，里面包含AutoCrudTable这里这张表的字段相关的 查询，排序，分页等等参数，后端无需关心这些
}

func CrmTicketSearch(ctx *app.Context, resp response.Response) error {
	var req CrmTicketSearchReq
	if err := ctx.ShouldBind(&req); err != nil {
		return err
	}
	db := ctx.GetGormDB()

	var lists []*CrmTicket
	//直接把SearchFilterPageReq透传到框架里，框架可以直接处理内部的逻辑，最终返回的数据是lists，同时会包含分页的信息
	return resp.Table(lists).AutoSearchFilterPaged(db, &CrmTicket{}, req.SearchFilterPageReq).Build()
}

func init() {
	app.GET(WithCurrentRouterGroup("crm_ticket"), CrmTicketSearch, CrmTicketTemplate)
}

```





然后把文件直接写到对应的crm的目录中
然后此时我们的前端在生成代码并写入目录后，我们会调用app/update的接口 来更新app的版本，然后更新的话，做的事情很多了，会编译新版本，然后直接部署，部署后会立即给新版本发送app的更新事件
这时候，我们sdk有内置的api可以做diff的操作（逻辑是app.GET 这种把路由注册到app里，然后CrmTicketTemplate的Request和Response这些我们都赋值了我们的model，此时已经可以对model进行解析了），
不仅可以解析出字段，还可解析出tag，可以直接解析成[widget](../sdk/agent-app/widget) widget.Field 这种类型，这时候我们就知道新增的api的请求和响应的数据结构是啥了，然后在接口返回的时候把数据返回出去，然后server侧会更新数据
在server_tree 新增api的数据，会记录这个api的请求参数和响应参数，这时候，前端点击到指定的api时候，可以立即渲染出页面，非常牛逼，假如代码改了一个字段，我们再调用update接口即可
然后再返回的数据里是包含新增，更新，删除的api的，我们直接更新即可，前端立即刷新，至此完美闭环，无需写一行代码，一个完整的工单管理系统诞生了

fork的燎原之势
从以上文件可以看出，这个文件就是一个完整的工单管理系统，完整的crud功能，后续整个app的所有服务目录的所有系统都是围绕着go的文件展开，一文件一系统
这个模式有个非常大的好处就是方便分发，这个文件直接copy到另一个app的任何目录，都可直接编译通过直接运行，无任何依赖，在前端的表现就是他们的服务目录里多了一个工单系统，也就是说
我这个系统可以被任何人fork，他们直接fork到他们自己的目录里即可直接编译成功，然后立即拥有工单管理系统，这就是fork功能的底层逻辑，非常简单，此工单管理系统可以被无数人fork，牛逼炸了，无需重复造轮子
