# 应用更新机制改造方案

## 改造方案确认事项（2025-11-07）

### 核心确认
1. **容器命名格式**：`{user}-{app}-{version}`
   - 示例：`luobei-filetest-v34`
   - user 和 app 不支持连字符，简化解析逻辑

2. **旧容器处理策略**：只停止，不删除
   - 更新成功后停止旧容器，保留以便快速回滚
   - 后续新增定时清理逻辑，定期清理停止的旧版本容器

3. **向后兼容**：无需向后兼容
   - 当前处于开发阶段，产品未上线，无历史债务
   - 直接使用新容器命名格式，无需处理旧格式容器

4. **容器名解析**：使用 `strings.Split(containerName, "-")` 即可
   - 格式：`{user}-{app}-{version}`
   - 最后一部分是 version，前面是 user-app

5. **优雅关闭流程（三次握手）**：
   - **第一次握手**：新版本启动后，runtime 收到启动通知（MessageTypeStatusStartup）
   - **第二次握手**：runtime 发送 shutdown 命令（MessageTypeStatusShutdown）给旧版本
   - **第三次握手**：旧版本处理完所有任务后，发送 close 通知（MessageTypeStatusClose）确认关闭完成
   - **停止容器**：runtime 收到 close 通知后，stop 旧容器（不删除）
   - **超时处理**：如果 30 秒内未收到 close 通知，强制 stop 容器

---

## 一、现状梳理

### 1.1 当前架构

#### 容器管理策略
- **容器命名规则**：`{user}-{app}`（如 `luobei-filetest`）
- **容器生命周期**：一个应用对应一个容器，容器长期运行
- **数据卷挂载**：应用目录通过 bind mount 挂载到容器的 `/app` 目录

#### 更新流程（UpdateApp）
1. **编译新版本**：在宿主机编译生成新的可执行文件（32-34MB）
2. **更新版本文件**：更新 `version.json` 和 `current_version.txt`
3. **启动新版本**：
   - **如果应用正在运行**：在容器内启动新进程（`ExecCommand` + `setsid nohup`）
   - **如果应用未运行**：启动容器（`startAppContainer`）
4. **等待启动通知**：通过 NATS 等待新版本启动通知（60秒超时）
5. **获取 API diff**：发送更新回调，获取 API 变更信息
6. **旧版本清理**：**不在 UpdateApp 中处理**，由定时清理任务处理

#### 旧版本清理机制（定时任务）
- **清理任务**：`CleanupNonCurrentVersions()` 每30秒执行一次
- **清理策略**：
  - 只保留 `current_version.txt` 中的当前版本
  - 关闭非当前版本且 QPS 为 0 的版本
  - 通过 NATS 发送 shutdown 命令给旧版本
- **清理时机**：更新后，新旧版本会同时运行，直到清理任务检测到旧版本无流量后才会关闭

#### 进程管理
- **启动方式**：`setsid nohup ./releases/{binary} </dev/null >/dev/null 2>&1 &`
- **进程隔离**：使用 `setsid` 创建新会话，避免僵尸进程
- **资源清理**：进程退出时调用 `Close()` 清理资源（NATS连接、数据库连接、文件缓存等）

#### 服务发现
- **基于 NATS 消息**：应用启动/关闭时发送状态通知
  - 启动通知：`runtime.status.{user}.{app}.{version}` (MessageTypeStatusStartup)
  - 关闭通知：`runtime.status.{user}.{app}.{version}` (MessageTypeStatusClose)
- **版本跟踪**：`AppDiscoveryService` 维护应用和版本的状态信息
  - `apps map[string]*discovery.AppInfo` - 内存中维护应用状态
  - `AppInfo.Versions map[string]*discovery.AppVersion` - 每个应用的版本列表
- **容器信息**：记录 `ContainerID` 和 `ProcessID`
- **关键方法**：
  - `GetRunningVersions(user, app)` - 获取所有运行中的版本
  - `IsAppVersionRunning(user, app, version)` - 检查特定版本是否运行
  - `handleStartupNotification()` - 处理启动通知
  - `handleCloseNotification()` - 处理关闭通知

### 1.2 关键代码位置

#### 容器命名（存在不一致）
```go
// core/app-runtime/service/app_manage_service.go:414 (UpdateApp)
containerName := fmt.Sprintf("%s-%s", user, app)  // 使用 "-"

// core/app-runtime/service/app_manage_service.go:1106 (StartAppVersion)
containerName := fmt.Sprintf("%s_%s", user, app)   // 使用 "_"

// core/app-runtime/server/handlers.go:388 (ensureAppVersionRunning)
containerName := fmt.Sprintf("%s_%s", user, app)   // 使用 "_"
```

**注意**：代码中存在容器命名不一致的问题，需要统一。

#### 更新流程（UpdateApp 方法）
```go
// core/app-runtime/service/app_manage_service.go:336-559

// 1. 编译新版本
buildResult, err := s.BuildApp(ctx, user, app, buildOpts)
newVersion := buildResult.Version

// 2. 更新版本文件
s.updateVersionJson(absAppDir, user, app, newVersion)

// 3. 根据运行状态决定启动方式
containerName := fmt.Sprintf("%s-%s", user, app)  // 注意：使用 "-"
if isRunning {
    // 在容器内启动新进程（灰度发布）
    binaryName := fmt.Sprintf("%s_%s_%s", user, app, newVersion)
    startCmd := fmt.Sprintf("cd /app/workplace/bin && setsid nohup ./releases/%s </dev/null >/dev/null 2>&1 &", binaryName)
    s.containerService.ExecCommand(ctx, containerName, []string{"/bin/sh", "-c", startCmd})
} else {
    // 启动容器（容器会自动启动应用）
    s.startAppContainer(ctx, containerName, appDirRel, newVersion)
}

// 4. 等待启动通知（通过 NATS）
waiterChan := s.registerStartupWaiter(user, app, newVersion)
select {
case notification := <-waiterChan:
    // 启动成功
case <-time.After(60 * time.Second):
    // 启动超时（不返回错误，继续执行）
}

// 5. 获取 API diff（通过 NATS Request/Reply）
updateCallbackResponse, _ := s.sendUpdateCallbackAndWait(ctx, user, app, newVersion)

// 注意：UpdateApp 中**没有**主动停止旧版本的逻辑
// 旧版本由定时清理任务（CleanupNonCurrentVersions）处理
```

#### 旧版本清理流程（定时任务）
```go
// core/app-runtime/service/app_manage_service.go:1032-1082
// CleanupNonCurrentVersions - 每30秒执行一次

// 1. 读取 current_version.txt
currentVersion := s.getCurrentVersion(ctx, user, app)

// 2. 获取所有运行中的版本
runningApps := s.appDiscoveryService.GetRunningApps()
appInfo := runningApps[user + "/" + app]

// 3. 关闭非当前版本且无流量的版本
for _, version := range appInfo.Versions {
    if version.Version == currentVersion {
        continue  // 跳过当前版本
    }
    
    if !s.QPSTracker.IsSafeToShutdown(user, app, version.Version) {
        continue  // 有流量，不关闭
    }
    
    // 发送 shutdown 命令
    s.ShutdownAppVersion(ctx, user, app, version.Version)
}
```

#### 服务发现
```go
// core/app-runtime/service/app_discovery_service.go
// 通过 NATS 消息跟踪应用版本状态
// 支持 GetRunningVersions() 获取所有运行中的版本
```

---

## 二、问题分析

### 2.1 当前更新机制的问题分析

#### 问题1：更新流程中不主动停止旧版本
- **现状**：`UpdateApp()` 方法中**没有**主动停止旧版本的逻辑
- **影响**：更新后，新旧版本会同时运行在同一容器内
- **清理机制**：依赖定时清理任务（30秒一次）来关闭旧版本
- **问题**：
  - 旧版本清理有延迟（最多30秒）
  - 如果旧版本仍有流量，不会被关闭
  - 新旧版本同时运行期间，资源占用翻倍

#### 问题2：容器长期运行，资源累积
- **现状**：容器名 `{user}-{app}`，一个应用一个容器，容器长期运行
- **影响**：
  - 文件缓存累积（每次更新加载新可执行文件到缓存）
  - 旧版本文件可能仍在文件缓存中
  - 容器内资源无法完全释放

#### 问题3：容器命名不一致
- **现状**：代码中存在两种命名格式
  - `UpdateApp()`: `{user}-{app}` (连字符)
  - `StartAppVersion()`: `{user}_{app}` (下划线)
- **影响**：可能导致容器查找失败

### 2.2 内存累积问题

#### 问题现象
- **每次更新内存增长**：更新后 `podman stats` 显示的内存增长约 16MB
- **重启后内存下降**：容器重启后内存从 39MB 降到 20MB
- **进程内存稳定**：进程实际内存（RSS）稳定在 20-22MB

#### 根本原因

1. **文件缓存累积**
   - 每次更新时，新版本可执行文件（32-34MB）被加载到文件缓存
   - 旧版本文件可能仍在文件缓存中
   - Linux 文件缓存不会因为宿主机内存压力而自动清理容器内的缓存
   - 如果容器没有内存限制，文件缓存可能无限增长

2. **容器内存管理机制**
   - 容器内文件缓存是容器自己的内存空间
   - 宿主机内存不足时，不会主动清理容器内的文件缓存
   - 容器内文件缓存只有在容器内内存压力大时才会被回收
   - 如果容器没有设置内存限制，文件缓存可能一直占用内存

3. **文件删除后缓存不释放**
   - 即使删除旧版本文件，文件缓存中的页面可能仍然占用内存
   - 这些"不可访问"的缓存只有在内存压力大时才会被回收
   - 如果容器没有内存限制，这些缓存可能一直占用内存

#### 数据验证

| 场景 | podman stats | 进程 RSS | cgroup memory.current | file cache |
|------|-------------|----------|----------------------|------------|
| 重启后 | 20.09MB | 20.21MB | 20.33MB | 15.36MB |
| 更新后 | 39.47MB | 22.02MB | 58.23MB | 52.96MB |
| 增长 | +19.38MB | +1.81MB | +37.9MB | +37.6MB |

**结论**：内存增长主要来自文件缓存，不是进程内存泄漏。

### 2.2 资源清理问题

#### 当前清理机制
- **进程退出时**：调用 `Close()` 清理资源
- **资源类型**：NATS连接、数据库连接、文件缓存、goroutine等
- **清理效果**：进程内存（RSS）会立即释放，但文件缓存可能不会立即释放

#### 潜在问题
- **文件缓存不释放**：即使进程退出，文件缓存可能仍然占用内存
- **旧版本文件残留**：旧版本可执行文件可能仍在文件缓存中
- **容器资源累积**：长期运行可能导致容器资源累积

### 2.3 架构问题

#### 当前架构的局限性
1. **容器复用导致资源累积**：同一个容器长期运行，资源可能累积
2. **版本隔离不足**：多个版本在同一容器内运行，资源隔离不够
3. **灰度发布复杂**：需要在同一容器内管理多个进程
4. **回滚困难**：需要重新启动旧版本进程，而不是直接切换容器

---

## 三、改造方案

### 3.1 方案概述

**核心思想**：每次更新启动新容器，每个版本独立容器运行。

#### 方案特点
- **版本隔离**：每个版本独立容器，资源完全隔离
- **内存清理**：旧容器停止后，所有内存（包括文件缓存）都会被释放
- **灰度发布**：可以同时运行多个容器，server侧做流量控制
- **回滚简单**：直接启动旧版本容器即可

### 3.2 容器命名策略

#### 新命名规则（已确认）
```go
// 当前：containerName = fmt.Sprintf("%s-%s", user, app)
// 新方案：containerName = fmt.Sprintf("%s-%s-%s", user, app, version)
```

#### 示例
- `luobei-filetest-v34`：版本 v34 的容器
- `luobei-filetest-v35`：版本 v35 的容器
- `luobei-filetest-v36`：版本 v36 的容器

#### 优势
- **版本唯一性**：每个版本有独立的容器名，不会冲突
- **易于管理**：可以通过容器名直接识别版本
- **支持多版本**：可以同时运行多个版本的容器

#### 容器名解析
- **user 和 app 不支持连字符**：简化了解析逻辑
- **解析函数**：`parseContainerName(containerName)` 可以简单通过 `strings.Split(containerName, "-")` 解析

### 3.3 更新流程设计

#### 单版本更新流程（默认）- 优雅关闭流程（类似三次握手）

```
1. 编译新版本
   └─> 生成可执行文件：{user}_{app}_{newVersion}
   
2. 创建新版本容器
   └─> 容器名：{user}-{app}-{newVersion}
   └─> 挂载数据卷：/app（应用目录）
   └─> 启动命令：/start.sh {newVersion}
   
3. 等待新版本启动（第一次握手）
   └─> 监听 NATS 启动通知（MessageTypeStatusStartup）
   └─> 超时：60秒
   └─> 收到启动通知后，确认新版本已就绪
   
4. 发送关闭命令给旧版本（第二次握手）
   └─> 查找旧版本容器：{user}-{app}-{oldVersion}
   └─> 发送 shutdown 命令（MessageTypeStatusShutdown）给旧版本（通过 NATS）
   └─> 旧版本收到后：
       - 停止接收新请求
       - 等待所有正在处理的函数/任务完成（最多30秒）
       - 清理资源（NATS连接、数据库连接、文件缓存等）
       - 发送 close 通知（MessageTypeStatusClose）确认关闭完成
   
5. 等待旧版本关闭确认（第三次握手）
   └─> 监听旧版本的 close 通知（MessageTypeStatusClose）
   └─> 超时：30秒（与旧版本等待函数完成的时间一致）
   └─> 收到 close 通知后，确认旧版本已优雅关闭
   
6. 停止旧容器
   └─> 收到旧版本的 close 通知后，调用 s.containerService.StopContainer()
   └─> **注意**：只停止容器，不删除（后续新增定时清理逻辑）
   
注意：与当前机制的区别
- 当前：在同一个容器内启动新进程，旧进程由定时任务清理
- 新方案：创建新容器，优雅关闭旧容器（三次握手确认），停止但不删除容器
```

#### 优雅关闭流程的优势

1. **数据安全**：确保旧版本处理完所有正在执行的函数/任务，避免数据丢失
2. **平滑切换**：新版本启动后再关闭旧版本，实现零停机更新
3. **资源清理**：旧版本在关闭前完成资源清理（NATS连接、数据库连接、文件缓存等）
4. **可观测性**：通过三次握手确认每个阶段的状态，便于监控和调试

#### 优雅关闭流程的关键点

1. **超时处理**：
   - 新版本启动超时：60秒（如果超时，继续执行，不阻塞更新）
   - 旧版本关闭超时：30秒（如果超时，强制停止容器）

2. **等待机制**：
   - Runtime 需要注册等待器，监听旧版本的 close 通知
   - 可以使用类似 `registerStartupWaiter` 的机制，注册 `registerCloseWaiter`

3. **容器停止时机**：
   - **必须在收到旧版本的 close 通知后才 stop 容器**
   - 如果超时未收到 close 通知，也应该 stop 容器（防止旧版本卡死）

4. **错误处理**：
   - 如果旧版本容器不存在，跳过关闭流程
   - 如果发送 shutdown 命令失败，记录日志但不阻塞更新
   - 如果等待 close 通知超时，记录警告并强制停止容器

#### 灰度发布流程（可选，后续实现）
```
1. 创建新容器（v36）
   └─> 容器名：{user}-{app}-v36
   └─> 启动新版本
   
2. 同时运行两个容器
   └─> v35 容器：运行旧版本
   └─> v36 容器：运行新版本
   
3. 流量控制（后续实现）
   └─> Server侧实现流量分配机制
   └─> 逐步切换流量
   
4. 完全切换后
   └─> 停止 v35 容器（不删除，后续新增定时清理逻辑）
```

### 3.4 服务发现调整

#### 当前服务发现机制
- **基于 NATS 消息**：应用启动/关闭时发送状态通知
- **版本跟踪**：`AppDiscoveryService` 维护应用和版本的状态信息
- **容器信息**：记录 `ContainerID` 和 `ProcessID`

#### 新方案调整
- **容器名包含版本**：容器名从 `{user}-{app}` 变为 `{user}-{app}-{version}`
- **多容器支持**：需要支持通过 `user/app` 查找所有运行中的容器版本
- **版本查找**：需要支持通过容器名查找对应的版本信息

#### 需要调整的接口
```go
// 当前：通过容器名查找应用
// core/app-runtime/service/container_service.go
IsContainerRunning(ctx, containerName string) (bool, error)

// 新方案：需要支持
// 1. 通过 user/app 查找所有运行中的容器版本
GetRunningContainersByApp(ctx, user, app string) ([]ContainerInfo, error)

// 2. 通过容器名解析版本信息（容器名格式：{user}-{app}-{version}）
ParseContainerName(containerName string) (user, app, version string, error)

// 3. 检查特定版本容器是否运行
IsVersionContainerRunning(ctx, user, app, version string) (bool, error)

// 4. 列出所有版本的容器（包括停止的）
ListVersionContainers(ctx, user, app string) ([]ContainerInfo, error)
```

#### 当前代码中的关键逻辑
```go
// core/app-runtime/server/handlers.go:154-191
// handleFunctionServerRequest - 处理来自 app-server 的请求
// 1. 检查版本是否运行：s.isAppVersionRunning(user, app, version)
// 2. 如果不在运行：s.ensureAppVersionRunning() - 尝试启动
// 3. 转发请求：s.forwardToApp() - 通过 NATS 转发到应用

// core/app-runtime/service/app_manage_service.go:887-915
// ShutdownAppVersion - 发送 shutdown 命令
// 通过 NATS 发送到：app.status.{user}.{app}.{version}
```

### 3.5 容器管理调整

#### 容器创建
```go
// 当前：containerName = fmt.Sprintf("%s-%s", user, app)
// 新方案：containerName = fmt.Sprintf("%s-%s-%s", user, app, version)

func (s *AppManageService) createVersionContainer(ctx context.Context, user, app, version string) error {
    containerName := fmt.Sprintf("%s-%s-%s", user, app, version)
    // 检查容器是否已存在
    // 如果存在且运行中，返回错误
    // 如果存在但已停止，删除后重新创建
    // 创建新容器
    return s.containerService.RunContainerWithCommand(...)
}
```

#### 容器停止（不删除）- 优雅关闭流程
```go
func (s *AppManageService) stopOldVersionContainer(ctx context.Context, user, app, oldVersion string) error {
    containerName := fmt.Sprintf("%s-%s-%s", user, app, oldVersion)
    
    // 1. 检查容器是否存在
    exists, err := s.containerService.IsContainerRunning(ctx, containerName)
    if err != nil || !exists {
        logger.Infof(ctx, "Old container %s not found, skipping", containerName)
        return nil
    }
    
    // 2. 发送 shutdown 命令给旧版本（第二次握手）
    if err := s.ShutdownAppVersion(ctx, user, app, oldVersion); err != nil {
        logger.Warnf(ctx, "Failed to send shutdown command: %v", err)
        // 不返回错误，继续执行
    }
    
    // 3. 注册关闭等待器，等待旧版本的 close 通知（第三次握手）
    closeWaiterChan := s.registerCloseWaiter(user, app, oldVersion)
    defer s.unregisterCloseWaiter(user, app, oldVersion)
    
    // 4. 等待旧版本关闭确认（最多30秒，与旧版本等待函数完成的时间一致）
    select {
    case <-closeWaiterChan:
        logger.Infof(ctx, "Received close notification from old version %s/%s/%s", user, app, oldVersion)
    case <-time.After(30 * time.Second):
        logger.Warnf(ctx, "Timeout waiting for close notification from old version %s/%s/%s, forcing stop", user, app, oldVersion)
        // 超时后强制停止
    }
    
    // 5. 停止容器（不删除，保留以便快速回滚）
    if err := s.containerService.StopContainer(ctx, containerName); err != nil {
        return fmt.Errorf("failed to stop container: %w", err)
    }
    
    logger.Infof(ctx, "Old container %s stopped successfully", containerName)
    return nil
}
```

#### 需要新增的等待器机制
```go
// 关闭等待器管理（类似启动等待器）
type CloseNotification struct {
    User      string
    App       string
    Version   string
    CloseTime time.Time
}

// registerCloseWaiter 注册关闭等待器
func (s *AppManageService) registerCloseWaiter(user, app, version string) chan *CloseNotification {
    key := fmt.Sprintf("%s/%s/%s", user, app, version)
    s.closeWaitersMu.Lock()
    defer s.closeWaitersMu.Unlock()
    
    waiterChan := make(chan *CloseNotification, 1)
    s.closeWaiters[key] = waiterChan
    return waiterChan
}

// unregisterCloseWaiter 注销关闭等待器
func (s *AppManageService) unregisterCloseWaiter(user, app, version string) {
    key := fmt.Sprintf("%s/%s/%s", user, app, version)
    s.closeWaitersMu.Lock()
    defer s.closeWaitersMu.Unlock()
    
    if waiterChan, exists := s.closeWaiters[key]; exists {
        close(waiterChan)
        delete(s.closeWaiters, key)
    }
}

// notifyCloseWaiter 通知关闭等待器（在 AppDiscoveryService.handleCloseNotification 中调用）
func (s *AppManageService) notifyCloseWaiter(user, app, version string, notification *CloseNotification) {
    key := fmt.Sprintf("%s/%s/%s", user, app, version)
    s.closeWaitersMu.RLock()
    defer s.closeWaitersMu.RUnlock()
    
    if waiterChan, exists := s.closeWaiters[key]; exists {
        select {
        case waiterChan <- notification:
        default:
            // 通道已满或已关闭，忽略
        }
    }
}
```

#### 容器清理策略（已确认）
- **停止策略**：更新成功后只停止旧容器，不删除
- **后续优化**：后续新增定时清理逻辑，定期清理停止的旧版本容器
- **回滚支持**：保留停止的容器便于快速回滚

### 3.6 灰度发布支持（后续实现）

#### 说明
- 当前阶段：支持同时运行多个版本容器
- 流量控制：Server侧流量控制机制后续实现
- 当前方案：先实现多容器运行能力，为后续流量控制做准备

---

## 四、改造点清单

### 4.1 核心改造点

#### 1. 容器命名策略（高优先级）
**文件**：`core/app-runtime/service/app_manage_service.go`

**修改点**：
- `UpdateApp()` 方法：容器名从 `{user}-{app}` 改为 `{user}-{app}-{version}`
- `startAppContainer()` 方法：容器名参数调整
- `DeleteApp()` 方法：需要删除所有版本的容器
- `StartAppVersion()` 方法：容器名调整

**影响范围**：
- 所有使用容器名的地方都需要调整
- 服务发现需要支持新容器名格式

#### 2. 更新流程重构（高优先级）
**文件**：`core/app-runtime/service/app_manage_service.go`

**修改点**：
- `UpdateApp()` 方法：重构更新流程
  - 移除"在容器内启动新进程"的逻辑
  - 改为"创建新容器 → 等待新版本启动 → 优雅关闭旧容器（三次握手）"
- 新增 `createVersionContainer()` 方法：创建版本容器
- 新增 `stopOldVersionContainer()` 方法：优雅关闭旧版本容器（三次握手流程）
  - 发送 shutdown 命令（第二次握手）
  - 等待 close 通知（第三次握手）
  - 收到 close 通知后 stop 容器
- 新增关闭等待器机制：
  - `registerCloseWaiter()` - 注册关闭等待器
  - `unregisterCloseWaiter()` - 注销关闭等待器
  - `notifyCloseWaiter()` - 通知关闭等待器（在 AppDiscoveryService 中调用）

**流程变化对比**：

**当前流程**：
```go
// UpdateApp() 中的逻辑
if isRunning {
    // 在同一个容器内启动新进程
    ExecCommand(containerName, startCmd)  // containerName = "{user}-{app}"
} else {
    // 启动容器（如果容器不存在）
    startAppContainer(containerName, ...)
}

// 等待启动通知
waitForStartup(user, app, newVersion)

// 获取 API diff
sendUpdateCallbackAndWait(...)

// 注意：没有停止旧版本的逻辑
// 旧版本由定时清理任务（CleanupNonCurrentVersions）处理
```

**新流程（优雅关闭流程）**：
```go
// UpdateApp() 中的新逻辑
// 1. 创建新版本容器
newContainerName := fmt.Sprintf("%s-%s-%s", user, app, newVersion)
createVersionContainer(ctx, newContainerName, ...)

// 2. 等待新版本启动（第一次握手）
waitForStartup(user, app, newVersion)  // 监听 MessageTypeStatusStartup

// 3. 优雅关闭旧容器（如果存在）- 三次握手流程
if oldVersion != "" && oldVersion != "unknown" {
    oldContainerName := fmt.Sprintf("%s-%s-%s", user, app, oldVersion)
    // 内部流程：
    //   a. 发送 shutdown 命令（第二次握手）
    //   b. 等待 close 通知（第三次握手）
    //   c. 收到 close 通知后，stop 容器
    stopOldVersionContainer(ctx, oldContainerName)
}

// 4. 获取 API diff
sendUpdateCallbackAndWait(...)

// 5. 注意：只停止旧容器，不删除（后续新增定时清理逻辑）
```

**关键变化**：
1. **容器命名**：从 `{user}-{app}` 变为 `{user}-{app}-{version}`
2. **容器创建**：每次更新创建新容器，而不是在容器内启动新进程
3. **旧版本处理**：优雅关闭流程（三次握手）
   - 第一次握手：新版本启动确认
   - 第二次握手：发送 shutdown 命令给旧版本
   - 第三次握手：等待旧版本 close 通知确认
   - 收到 close 通知后 stop 容器
4. **资源清理**：容器停止后，所有资源（包括文件缓存）立即释放
5. **等待器机制**：新增关闭等待器，类似启动等待器，用于监听旧版本的 close 通知

#### 3. 容器管理接口扩展（中优先级）
**文件**：`core/app-runtime/service/container_service.go`

**新增接口**：
```go
// 通过 user/app 查找所有运行中的容器版本
GetRunningContainersByApp(ctx context.Context, user, app string) ([]ContainerInfo, error)

// 通过容器名查找版本信息
ParseContainerName(containerName string) (user, app, version string, error)

// 检查特定版本容器是否运行
IsVersionContainerRunning(ctx context.Context, user, app, version string) (bool, error)

// 列出所有版本的容器（包括停止的）
ListVersionContainers(ctx context.Context, user, app string) ([]ContainerInfo, error)
```

#### 4. 服务发现调整（中优先级）
**文件**：`core/app-runtime/service/app_discovery_service.go`

**修改点**：
- `handleStartupNotification()` 方法：容器名包含版本信息
- `handleCloseNotification()` 方法：
  - 容器名包含版本信息
  - **关键**：在收到 close 通知后，调用 `AppManageService.notifyCloseWaiter()` 通知关闭等待器
  - 这是优雅关闭流程的第三次握手确认
- 支持通过 `user/app` 查找所有运行中的容器版本
- 容器信息记录：`ContainerID` 对应版本容器

**数据结构调整**：
```go
// discovery.AppVersion 可能需要调整
type AppVersion struct {
    Version     string
    Status      string
    StartTime   time.Time
    LastSeen    time.Time
    ContainerID string  // 版本容器的 ID
    ContainerName string // 版本容器的名称 {user}-{app}-{version}
    ProcessID   string  // 可能不再需要（容器内只有一个进程）
}
```

#### 5. 请求路由调整（中优先级）
**文件**：`core/app-runtime/server/handlers.go`

**修改点**：
- `handleFunctionServerRequest()` 方法：需要根据版本查找对应的容器
- `ensureAppVersionRunning()` 方法：需要创建版本容器，而不是在容器内启动进程
- `forwardToApp()` 方法：需要转发到正确的版本容器

**逻辑变化**：
```go
// 当前：通过容器名查找应用
containerName := fmt.Sprintf("%s_%s", user, app)
IsContainerRunning(containerName)

// 新方案：通过版本查找容器
containerName := fmt.Sprintf("%s-%s-%s", user, app, version)
IsVersionContainerRunning(user, app, version)
```

#### 6. 容器清理机制（后续实现）
**文件**：`core/app-runtime/service/app_manage_service.go`

**当前实现**：
- 更新成功后只停止旧容器，不删除

**后续新增功能**：
- 定期清理停止的旧版本容器
- 配置保留的旧版本容器数量（如最近5个版本）

### 4.2 兼容性考虑（已确认）

#### 向后兼容
- **无需向后兼容**：当前处于开发阶段，产品未上线，无历史债务
- **直接改造**：直接使用新容器命名格式，无需处理旧格式容器

#### 容器名解析
- **user 和 app 不支持连字符**：简化了解析逻辑
- **解析实现**：使用 `strings.Split(containerName, "-")` 即可解析

### 4.3 测试要点

#### 功能测试
1. **单版本更新**：更新流程是否正常
2. **多版本运行**：是否可以同时运行多个版本容器
3. **旧容器清理**：旧容器是否正确停止和删除
4. **服务发现**：版本信息是否正确更新
5. **请求路由**：请求是否正确路由到对应版本容器

#### 性能测试
1. **容器启动时间**：新容器启动时间（应该比进程启动慢）
2. **内存使用**：更新后内存是否正常释放
3. **资源占用**：多容器运行时的资源占用

#### 稳定性测试
1. **更新失败处理**：新容器启动失败时的回滚机制
2. **旧容器停止失败**：旧容器无法停止时的处理
3. **并发更新**：同时更新多个应用时的稳定性

---

## 五、实施计划

### 5.1 阶段一：基础改造（核心功能）

#### 目标
实现基本的"每次更新新容器"功能

#### 任务清单
1. ✅ 修改容器命名策略：`{user}-{app}-{version}`
2. ✅ 重构 `UpdateApp()` 方法：改为创建新容器
3. ✅ 实现 `createVersionContainer()` 方法
4. ✅ 实现 `stopOldVersionContainer()` 方法
5. ✅ 调整服务发现：支持新容器名格式
6. ✅ 调整请求路由：根据版本查找容器

#### 预计工作量
- **开发时间**：2-3天
- **测试时间**：1-2天
- **总计**：3-5天

### 5.2 阶段二：优化和完善（可选功能）

#### 目标
优化容器管理，支持灰度发布

#### 任务清单
1. ⬜ 实现容器清理机制（延迟删除、定期清理）
2. ⬜ 实现多容器运行支持（为后续灰度发布做准备）
3. ⬜ 容器管理接口扩展
4. ⬜ 监控和日志优化
5. ⬜ Server侧流量控制（后续实现）

#### 预计工作量
- **开发时间**：3-5天
- **测试时间**：2-3天
- **总计**：5-8天

### 5.3 阶段三：迁移和验证（生产就绪）

#### 目标
生产环境验证和优化

#### 任务清单
1. ⬜ 生产环境测试
2. ⬜ 性能优化
3. ⬜ 文档完善
4. ⬜ 监控告警

#### 预计工作量
- **测试时间**：3-5天
- **优化时间**：2-3天
- **总计**：5-8天

---

## 六、风险评估

### 6.1 技术风险

#### 风险1：容器启动开销
- **风险描述**：容器启动比进程启动慢（几秒到几十秒）
- **影响**：更新速度可能变慢
- **缓解措施**：
  - 优化容器启动流程
  - 使用容器预热机制
  - 异步启动，不阻塞更新流程

#### 风险2：容器数量增长
- **风险描述**：如果旧容器没有及时删除，容器数量会增长
- **影响**：可能影响系统资源
- **缓解措施**：
  - 实现自动清理机制
  - 设置保留的旧容器数量限制
  - 定期清理停止的容器

#### 风险3：服务发现延迟
- **风险描述**：新容器启动后，服务发现可能延迟更新
- **影响**：请求可能路由失败
- **缓解措施**：
  - 等待启动通知后再切换流量
  - 实现健康检查机制
  - 支持快速回滚

### 6.2 业务风险

#### 风险1：更新失败
- **风险描述**：新容器启动失败，旧容器已停止
- **影响**：服务中断
- **缓解措施**：
  - 先启动新容器，确认启动成功后再停止旧容器
  - 实现快速回滚机制
  - 保留旧容器一段时间（延迟删除）

#### 风险2：数据一致性
- **风险描述**：多容器运行时，数据卷挂载可能有问题
- **影响**：数据不一致
- **缓解措施**：
  - 确保数据卷正确挂载
  - 使用只读数据卷（如果需要）
  - 数据持久化验证

### 6.3 运维风险

#### 风险1：容器管理复杂度
- **风险描述**：容器数量增加，管理复杂度提高
- **影响**：运维成本增加
- **缓解措施**：
  - 实现自动化清理机制
  - 提供容器管理工具
  - 完善监控和告警

#### 风险2：回滚复杂度
- **风险描述**：回滚需要重新启动旧版本容器
- **影响**：回滚时间可能较长
- **缓解措施**：
  - 实现快速回滚机制
  - 保留旧容器一段时间
  - 提供一键回滚工具

---

## 七、收益分析

### 7.1 内存问题解决

#### 当前问题
- 每次更新内存增长约 16MB
- 文件缓存累积，无法自动清理
- 重启容器才能释放内存

#### 改造后效果
- ✅ 旧容器停止后，所有内存（包括文件缓存）立即释放
- ✅ 不再有文件缓存累积问题
- ✅ 内存使用稳定，不会持续增长

### 7.2 架构优化

#### 当前架构
- 容器长期运行，资源可能累积
- 版本隔离不足
- 灰度发布复杂

#### 改造后效果
- ✅ 版本完全隔离，互不影响
- ✅ 资源清理彻底
- ✅ 灰度发布更清晰（多容器 + server流量控制）

### 7.3 运维优化

#### 当前问题
- 回滚需要重新启动进程
- 容器管理复杂
- 问题排查困难

#### 改造后效果
- ✅ 回滚简单（直接启动旧版本容器）
- ✅ 容器管理更清晰（每个版本独立容器）
- ✅ 问题排查更容易（版本隔离）

---

## 八、总结

### 8.1 方案优势

1. **彻底解决内存问题**：旧容器停止后，所有内存立即释放
2. **版本完全隔离**：每个版本独立容器，互不影响
3. **符合云原生理念**：容器应该是无状态的、可替换的
4. **支持灰度发布**：多容器 + server流量控制
5. **回滚简单**：直接启动旧版本容器

### 8.2 实施建议

1. **分阶段实施**：先实现核心功能，再优化和完善
2. **充分测试**：在测试环境充分验证后再上线
3. **监控告警**：完善监控和告警机制
4. **文档完善**：更新相关文档和操作手册

### 8.3 后续优化方向

1. **容器预热**：提前创建容器，减少启动时间
2. **智能清理**：根据使用情况智能清理旧容器
3. **健康检查**：实现容器健康检查机制
4. **自动回滚**：新版本异常时自动回滚
5. **流量控制**：Server侧实现流量控制策略（后续实现）

---

## 附录

### A. 相关文件清单

#### 核心文件
- `core/app-runtime/service/app_manage_service.go` - 应用管理服务
- `core/app-runtime/service/container_service.go` - 容器服务
- `core/app-runtime/service/app_discovery_service.go` - 服务发现
- `core/app-runtime/server/handlers.go` - 请求处理

#### 配置文件
- `configs/app-runtime.yaml` - Runtime 配置
- `configs/api-gateway.yaml` - 网关配置

### B. 关键数据结构

```go
// 容器信息
type ContainerInfo struct {
    Name        string  // {user}-{app}-{version}
    User        string
    App         string
    Version     string
    Status      string  // running, stopped, exited
    CreatedAt   time.Time
    StartedAt   time.Time
    StoppedAt   time.Time
}

// 应用版本信息
type AppVersion struct {
    Version       string
    Status        string
    StartTime     time.Time
    LastSeen      time.Time
    ContainerID   string
    ContainerName string  // {user}-{app}-{version}
}
```

### C. 配置示例

```yaml
# app-runtime 配置
app_runtime:
  container:
    # 容器命名格式（已确认）
    name_format: "{user}-{app}-{version}"
    
    # 旧容器清理策略（后续实现）
    # 当前阶段：只停止容器，不删除
    # 后续新增定时清理逻辑时使用以下配置
    cleanup:
      # 延迟删除时间（秒）- 后续功能
      delay_delete: 300
      # 保留的旧容器数量 - 后续功能
      keep_versions: 5
      # 定期清理间隔（秒）- 后续功能
      cleanup_interval: 3600
```

---

**文档版本**：v1.1  
**创建时间**：2025-11-07  
**最后更新**：2025-11-07

**更新说明**：
- 确认容器命名格式：`{user}-{app}-{version}`
- 确认旧容器处理策略：只停止，不删除（后续新增定时清理逻辑）
- 确认无需向后兼容（开发阶段，无历史债务）
- 确认 user 和 app 不支持连字符，简化容器名解析

