[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
# 当前阶段使用的关系
g = _, _        # 用户-角色关系：g(user, role)
g2 = _, _       # 资源继承关系：g2(resource, parent_resource)

# 预留：组织架构关系（后续扩展）
g3 = _, _       # 用户-部门关系：g3(user, department_path)
g4 = _, _       # 部门-角色关系：g4(department_path, role)

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
# ⭐ 权限匹配模式：Matcher 模式的权限映射（推荐方案）
# 
# 核心设计理念：
#   - 使用语义清晰的权限标识（directory:manage、app:manage）替代通配符权限（*）
#   - 通过 Matcher 规则实现权限映射，自动覆盖所有子资源权限
#   - 通配符权限（*）仅作为备用，用于特殊场景（临时权限、测试等）
# 
# 支持多种权限匹配方式：
# 1. 直接权限：用户直接拥有权限（精确匹配）
# 2. 角色权限：用户通过角色拥有权限
# 3. 资源继承：子资源继承父资源权限（通过 keyMatch2 路径匹配）
# 4. ⭐ Matcher 权限映射：directory:manage 和 app:manage 权限自动覆盖所有子资源（主要使用）
# 5. 通配符权限：p.act == "*" 表示拥有所有权限（备用，特殊场景使用）
# 6. 预留：组织架构权限（通过 g3、g4 关系，待实现）
# 
# ⭐ 优化：使用 keyMatch2 路径匹配实现资源继承
# ⭐ 优势：
#   - 数据量少：一条策略覆盖整个子树（如 /luobei/operations/*）
#   - 性能优秀：路径匹配比关系遍历更快
#   - 管理简单：策略数量大幅减少
#   - 语义清晰：directory:manage 比 * 更明确，便于审计和理解
# 
# 权限匹配逻辑（按优先级）：
# 1. g(r.sub, p.sub): 用户通过角色拥有权限
# 2. r.obj == p.obj: 精确匹配资源路径
# 3. keyMatch2(r.obj, p.obj): 路径匹配（支持通配符 *），实现资源继承
#    * 例如：keyMatch2("/luobei/operations/tools/videos/convert", "/luobei/operations/*") → true
#    * 这样，授予 /luobei/operations/* 权限后，所有子资源自动继承
# 4. r.act == p.act: 操作类型精确匹配（最高优先级）
# 5. p.act == "*": 通配符权限（备用，特殊场景使用）
#    * 适用场景：临时权限、测试场景、需要授予所有权限且不需要区分操作类型
#    * 不推荐作为主要权限方式，优先使用 directory:manage 和 app:manage
# 6. ⭐ (p.act == "directory:manage" && keyMatch2(r.obj, p.obj)): 目录管理权限自动覆盖所有子资源（主要使用）
#    * 权限映射规则：directory:manage → 自动覆盖所有子资源的以下权限：
#      - function:read, function:execute, function:create, function:update, function:delete
#      - table:create, table:update, table:delete, table:read
#      - form:submit, form:read（表单提交权限）
#      - chart:read（拥有 chart:read 权限即视为拥有 chart:query 权限）
#      - directory:read, directory:create, directory:update, directory:delete
#    * 示例：策略是 /a/a4/b1/*, directory:manage
#      - 检查 /a/a4/b1/func1, function:create → 允许 ✅
#      - 检查 /a/a4/b1/table1, table:create → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:create → 允许 ✅
#    * 语义清晰：明确表示这是目录管理权限，便于审计和理解
# 7. ⭐ (p.act == "app:manage" && keyMatch2(r.obj, p.obj)): 应用管理权限自动覆盖所有子资源（主要使用）
#    * 权限映射规则：app:manage → 自动覆盖应用下所有资源的权限
#      - 包括所有目录的 directory:manage 权限
#      - 包括所有函数的 function:* 权限
#      - 包括所有表格、表单、图表的权限
#    * 示例：策略是 /user/app1/*, app:manage
#      - 检查 /user/app1/dir1/func1, function:create → 允许 ✅
#      - 检查 /user/app1/dir1, directory:create → 允许 ✅
#    * 语义清晰：明确表示这是应用管理权限，便于审计和理解
# 
# ⭐ 权限粒度问题解决方案：
# 问题：策略 action 是 directory:manage，检查 action 是 function:create，两者不匹配
# 解决：通过 Matcher 规则实现权限映射，directory:manage 自动拥有所有子资源的权限
# 优势：在 Casbin 模型层处理，性能好，逻辑清晰，符合直觉
m = g(r.sub, p.sub) && (r.obj == p.obj || keyMatch2(r.obj, p.obj)) && (r.act == p.act || p.act == "*" || (p.act == "directory:manage" && keyMatch2(r.obj, p.obj)) || (p.act == "app:manage" && keyMatch2(r.obj, p.obj)))

