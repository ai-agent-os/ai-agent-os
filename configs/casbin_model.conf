[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
# 当前阶段使用的关系
g = _, _        # 用户-角色关系：g(user, role)
g2 = _, _       # 资源继承关系：g2(resource, parent_resource)

# 预留：组织架构关系（后续扩展）
g3 = _, _       # 用户-部门关系：g3(user, department_path)
g4 = _, _       # 部门-角色关系：g4(department_path, role)

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
# ⭐ 权限匹配模式：Matcher 模式的权限映射（推荐方案）
# 
# 核心设计理念：
#   - 使用语义清晰的权限标识（directory:manage、app:manage）替代通配符权限（*）
#   - 通过 Matcher 规则实现权限映射，自动覆盖所有子资源权限
#   - 通配符权限（*）仅作为备用，用于特殊场景（临时权限、测试等）
# 
# 支持多种权限匹配方式：
# 1. 直接权限：用户直接拥有权限（精确匹配）
# 2. 角色权限：用户通过角色拥有权限
# 3. 资源继承：子资源继承父资源权限（通过 keyMatch2 路径匹配）
# 4. ⭐ Matcher 权限映射：directory:manage 和 app:manage 权限自动覆盖所有子资源（主要使用）
# 5. 通配符权限：p.act == "*" 表示拥有所有权限（备用，特殊场景使用）
# 6. 预留：组织架构权限（通过 g3、g4 关系，待实现）
# 
# ⭐ 优化：使用 keyMatch2 路径匹配实现资源继承
# ⭐ 优势：
#   - 数据量少：一条策略覆盖整个子树（如 /luobei/operations/*）
#   - 性能优秀：路径匹配比关系遍历更快
#   - 管理简单：策略数量大幅减少
#   - 语义清晰：directory:manage 比 * 更明确，便于审计和理解
# 
# 权限匹配逻辑（按优先级）：
# 1. g(r.sub, p.sub): 用户通过角色拥有权限
# 2. r.obj == p.obj: 精确匹配资源路径
# 3. keyMatch2(r.obj, p.obj): 路径匹配（支持通配符 *），实现资源继承
#    * 例如：keyMatch2("/luobei/operations/tools/videos/convert", "/luobei/operations/*") → true
#    * 这样，授予 /luobei/operations/* 权限后，所有子资源自动继承
# 4. r.act == p.act: 操作类型精确匹配（最高优先级）
# 5. p.act == "*": 通配符权限（备用，特殊场景使用）
#    * 适用场景：临时权限、测试场景、需要授予所有权限且不需要区分操作类型
#    * 不推荐作为主要权限方式，优先使用 directory:manage 和 app:manage
# 6. ⭐ (p.act == "directory:manage" && keyMatch2(r.obj, p.obj)): 目录管理权限自动覆盖所有子资源（主要使用）
#    * 权限映射规则：directory:manage → 自动覆盖所有子资源的以下权限：
#      - function:read, function:manage, function:write, function:update, function:delete
#      - table:write, table:update, table:delete, table:read
#      - form:write, form:read（表单写入权限）
#      - chart:read（拥有 chart:read 权限即视为拥有 chart:query 权限）
#      - directory:read, directory:write, directory:update, directory:delete
#    * 示例：策略是 /a/a4/b1/*, directory:manage
#      - 检查 /a/a4/b1/func1, function:write → 允许 ✅
#      - 检查 /a/a4/b1/table1, table:write → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:write → 允许 ✅
#    * 语义清晰：明确表示这是目录管理权限，便于审计和理解
# 7. ⭐ (p.act == "app:manage" && keyMatch2(r.obj, p.obj)): 应用管理权限自动覆盖所有子资源（主要使用）
#    * 权限映射规则：app:manage → 自动覆盖应用下所有资源的权限
#      - 包括所有目录的 directory:manage 权限
#      - 包括所有函数的 function:* 权限
#      - 包括所有表格、表单、图表的权限
#    * 示例：策略是 /user/app1/*, app:manage
#      - 检查 /user/app1/dir1/func1, function:write → 允许 ✅
#      - 检查 /user/app1/dir1, directory:write → 允许 ✅
#    * 语义清晰：明确表示这是应用管理权限，便于审计和理解
# 8. ⭐ (p.act == "function:manage" && r.obj == p.obj): 函数所有权权限自动覆盖该函数的所有操作权限（主要使用）
#    * 权限映射规则：function:manage → 自动覆盖该函数的所有操作权限：
#      - function:read（函数查看）
#      - table:write, table:update, table:delete（表格操作，仅对 table 类型函数）
#      - form:write（表单提交，仅对 form 类型函数）
#      - chart:read（图表查看，仅对 chart 类型函数）
#    * 示例：策略是 /luobei/operations/data/vote/biz_vote_system_option_list, function:manage
#      - 检查 /luobei/operations/data/vote/biz_vote_system_option_list, table:write → 允许 ✅
#      - 检查 /luobei/operations/data/vote/biz_vote_system_option_list, table:update → 允许 ✅
#      - 检查 /luobei/operations/data/vote/biz_vote_system_option_list, table:delete → 允许 ✅
#      - 检查 /luobei/operations/data/vote/biz_vote_system_option_list, function:read → 允许 ✅
#    * 注意：function:manage 使用精确路径匹配（r.obj == p.obj），不使用 keyMatch2，因为函数是叶子节点
#    * 语义清晰：明确表示这是函数所有权权限，便于审计和理解
# 
# ⭐ 权限粒度问题解决方案：
# 问题：策略 action 是 directory:manage，检查 action 是 function:write，两者不匹配
# 解决：通过 Matcher 规则实现权限映射，directory:manage 自动拥有所有子资源的权限
# ⭐ 权限语义说明：
#   - write 权限：通用的写入权限，包含创建和更新的概念
#   - 目录的 write 权限：可以让子函数继承该目录的 write 权限
#   - 函数的 write 权限：对于 table 类型，相当于有了 create 权限，可以新增记录
# 优势：在 Casbin 模型层处理，性能好，逻辑清晰，符合直觉
# 9. ⭐ (p.act == "directory:read" && keyMatch2(r.obj, p.obj) && (r.act == "function:read" || r.act == "table:read" || r.act == "chart:read" || r.act == "directory:read")): 目录查看权限自动覆盖子资源的查看权限（主要使用）
#    * 权限映射规则：directory:read → 自动覆盖所有子资源的以下权限：
#      - function:read（函数查看）
#      - table:read（表格查看）
#      - chart:read（图表查看）
#      - directory:read（子目录查看）
#    * 示例：策略是 /a/a4/b1/*, directory:read
#      - 检查 /a/a4/b1/func1, function:read → 允许 ✅
#      - 检查 /a/a4/b1/table1, table:read → 允许 ✅
#      - 检查 /a/a4/b1/chart1, chart:read → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:read → 允许 ✅
#    * 语义清晰：明确表示这是目录查看权限，子资源自动继承查看权限
# 10. ⭐ (p.act == "directory:write" && keyMatch2(r.obj, p.obj) && (r.act == "table:write" || r.act == "form:write" || r.act == "directory:write")): 目录写入权限自动覆盖子资源的写入权限（主要使用）
#    * 权限映射规则：directory:write → 自动覆盖所有子资源的以下权限：
#      - table:write（表格新增记录，仅对 table 类型函数）
#      - form:write（表单提交，仅对 form 类型函数）
#      - directory:write（子目录写入）
#    * 示例：策略是 /a/a4/b1/*, directory:write
#      - 检查 /a/a4/b1/table1, table:write → 允许 ✅
#      - 检查 /a/a4/b1/form1, form:write → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:write → 允许 ✅
#    * 注意：chart 类型函数不继承 write 权限
#    * 语义清晰：明确表示这是目录写入权限，子资源自动继承写入权限
# 11. ⭐ (p.act == "directory:update" && keyMatch2(r.obj, p.obj) && (r.act == "table:update" || r.act == "directory:update")): 目录更新权限自动覆盖子资源的更新权限（主要使用）
#    * 权限映射规则：directory:update → 自动覆盖所有子资源的以下权限：
#      - table:update（表格更新记录，仅对 table 类型函数）
#      - directory:update（子目录更新）
#    * 示例：策略是 /a/a4/b1/*, directory:update
#      - 检查 /a/a4/b1/table1, table:update → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:update → 允许 ✅
#    * 语义清晰：明确表示这是目录更新权限，子资源自动继承更新权限
# 12. ⭐ (p.act == "directory:delete" && keyMatch2(r.obj, p.obj) && (r.act == "table:delete" || r.act == "directory:delete")): 目录删除权限自动覆盖子资源的删除权限（主要使用）
#    * 权限映射规则：directory:delete → 自动覆盖所有子资源的以下权限：
#      - table:delete（表格删除记录，仅对 table 类型函数）
#      - directory:delete（子目录删除）
#    * 示例：策略是 /a/a4/b1/*, directory:delete
#      - 检查 /a/a4/b1/table1, table:delete → 允许 ✅
#      - 检查 /a/a4/b1/subdir, directory:delete → 允许 ✅
#    * 语义清晰：明确表示这是目录删除权限，子资源自动继承删除权限
m = g(r.sub, p.sub) && (r.obj == p.obj || keyMatch2(r.obj, p.obj)) && (r.act == p.act || p.act == "*" || (p.act == "directory:manage" && keyMatch2(r.obj, p.obj)) || (p.act == "app:manage" && keyMatch2(r.obj, p.obj)) || (p.act == "function:manage" && r.obj == p.obj) || (p.act == "directory:read" && keyMatch2(r.obj, p.obj) && (r.act == "function:read" || r.act == "table:read" || r.act == "chart:read" || r.act == "directory:read")) || (p.act == "directory:write" && keyMatch2(r.obj, p.obj) && (r.act == "table:write" || r.act == "form:write" || r.act == "directory:write")) || (p.act == "directory:update" && keyMatch2(r.obj, p.obj) && (r.act == "table:update" || r.act == "directory:update")) || (p.act == "directory:delete" && keyMatch2(r.obj, p.obj) && (r.act == "table:delete" || r.act == "directory:delete")))

