# 组件统一化设计方案

## 一、问题分析

### 1.1 当前问题

#### 问题1: 组件参数不一致
- 不同组件的 props 接口可能不同
- 难以统一管理和维护
- 组件之间难以互换使用

#### 问题2: 组件文件过多
- `TableWidget.ts`（请求参数）
- `ResponseTableWidget.ts`（响应参数）
- `FormWidget.ts`（请求参数）
- `ResponseFormWidget.ts`（响应参数）
- 一个类型可能有多个文件，维护成本高

### 1.2 用户需求

1. **参数统一**：所有组件传递的参数保持一致
2. **组件合并**：将同一类型的请求和响应组件合并，通过 `mode` 区分场景

## 二、设计方案

### 2.1 统一的 Props 接口

```typescript
// types/widget.ts
export interface WidgetComponentProps {
  // 基础属性
  field: FieldConfig
  value: FieldValue
  
  // 场景标识
  mode: 'edit' | 'response' | 'table-cell' | 'detail' | 'search'
  
  // 可选属性
  formManager?: ReactiveFormDataManager | null
  formRenderer?: FormRendererContext | null
  depth?: number
  
  // 场景特定属性
  searchType?: string  // 用于 search 模式
  rowData?: any  // 用于 table-cell 模式
}
```

### 2.2 组件合并方案

#### 方案A: 完全合并（推荐）

**一个组件文件，通过 `mode` prop 区分场景**

```
widgets/
  ├─ InputWidget.vue        # 统一组件
  ├─ TableWidget.vue        # 统一组件（包含请求和响应）
  ├─ FormWidget.vue         # 统一组件（包含请求和响应）
  ├─ SelectWidget.vue       # 统一组件
  └─ ...
```

**实现方式**：
```vue
<!-- TableWidget.vue -->
<script setup lang="ts">
interface Props {
  field: FieldConfig
  value: FieldValue
  mode: 'edit' | 'response' | 'table-cell' | 'detail'
  formManager?: ReactiveFormDataManager | null
  formRenderer?: FormRendererContext | null
  depth?: number
}

const props = withDefaults(defineProps<Props>(), {
  mode: 'edit',
  depth: 0
})

// 根据 mode 决定渲染逻辑
const renderContent = computed(() => {
  switch (props.mode) {
    case 'edit':
      return renderEditMode()  // 可编辑表格
    case 'response':
      return renderResponseMode()  // 只读表格
    case 'table-cell':
      return renderTableCellMode()  // 表格单元格
    case 'detail':
      return renderDetailMode()  // 详情展示
  }
})
</script>
```

#### 方案B: 部分合并（渐进式）

**保留部分分离，但共享核心逻辑**

```
widgets/
  ├─ TableWidget.vue        # 请求参数（可编辑）
  ├─ TableWidgetBase.vue    # 共享的基础逻辑
  └─ ResponseTableWidget.vue  # 响应参数（只读，使用 TableWidgetBase）
```

### 2.3 组件内部实现

#### TableWidget.vue 统一实现

```vue
<!-- TableWidget.vue -->
<template>
  <div class="table-widget">
    <!-- 根据 mode 渲染不同的内容 -->
    <template v-if="mode === 'edit'">
      <!-- 可编辑表格 -->
      <el-table :data="tableData">
        <!-- 可编辑列 -->
        <el-table-column>
          <template #default="{ row, $index }">
            <component
              :is="getTableCellComponent(field)"
              :field="field"
              :value="row[field.code]"
              :row-data="row"
              :row-index="$index"
              mode="table-cell"
            />
          </template>
        </el-table-column>
        <!-- 操作列：新增、编辑、删除 -->
        <el-table-column label="操作">
          <template #default="{ $index }">
            <el-button @click="handleEdit($index)">编辑</el-button>
            <el-button @click="handleDelete($index)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
      <!-- 聚合统计 -->
      <div v-if="statisticsConfig" class="statistics">
        <div v-for="(value, label) in statisticsResult" :key="label">
          {{ label }}: {{ value }}
        </div>
      </div>
    </template>
    
    <template v-else-if="mode === 'response'">
      <!-- 只读表格 -->
      <el-table :data="tableData" border>
        <el-table-column
          v-for="field in fields"
          :key="field.code"
          :prop="field.code"
          :label="field.name"
        >
          <template #default="{ row }">
            <component
              :is="getTableCellComponent(field)"
              :field="field"
              :value="row[field.code]"
              mode="table-cell"
            />
          </template>
        </el-table-column>
      </el-table>
      <!-- 详情抽屉 -->
      <el-drawer v-model="showDetailDrawer">
        <!-- 详情内容 -->
      </el-drawer>
    </template>
    
    <template v-else-if="mode === 'table-cell'">
      <!-- 表格单元格渲染 -->
      <span>{{ formatValue(value) }}</span>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue'
import type { FieldConfig, FieldValue } from '../types/field'
import type { ReactiveFormDataManager, FormRendererContext } from '../types'

interface Props {
  field: FieldConfig
  value: FieldValue
  mode: 'edit' | 'response' | 'table-cell' | 'detail'
  formManager?: ReactiveFormDataManager | null
  formRenderer?: FormRendererContext | null
  depth?: number
}

const props = withDefaults(defineProps<Props>(), {
  mode: 'edit',
  depth: 0
})

// 计算属性
const tableData = computed(() => {
  return Array.isArray(props.value?.raw) ? props.value.raw : []
})

const fields = computed(() => {
  return props.field.children || []
})

// 编辑模式的状态
const editingIndex = ref<number | null>(null)
const isAdding = ref(false)
const statisticsConfig = ref<any>(null)
const statisticsResult = computed(() => {
  // 聚合计算逻辑
  if (!statisticsConfig.value) return {}
  // ...
})

// 响应模式的状态
const showDetailDrawer = ref(false)

// 方法
function handleEdit(index: number) {
  // 编辑逻辑
}

function handleDelete(index: number) {
  // 删除逻辑
}

function formatValue(value: FieldValue): string {
  // 格式化逻辑
}
</script>
```

## 三、方案对比

### 3.1 方案A: 完全合并

#### 优点
1. ✅ **文件数量少**：一个类型一个文件
2. ✅ **代码复用**：共享核心逻辑
3. ✅ **维护简单**：只需维护一个文件
4. ✅ **参数统一**：所有场景使用相同的 props

#### 缺点
1. ❌ **文件可能较大**：包含多种场景的逻辑
2. ❌ **条件判断多**：需要根据 mode 判断

#### 适用场景
- 组件逻辑相似度高
- 场景差异主要是 UI 展示
- 希望减少文件数量

### 3.2 方案B: 部分合并

#### 优点
1. ✅ **逻辑清晰**：不同场景分离
2. ✅ **文件较小**：每个文件职责单一

#### 缺点
1. ❌ **文件数量多**：一个类型多个文件
2. ❌ **代码重复**：可能有一些重复逻辑

#### 适用场景
- 组件逻辑差异较大
- 场景差异不仅仅是 UI
- 希望保持代码清晰

## 四、推荐方案

### 4.1 推荐：方案A（完全合并）

**理由**：
1. **TableWidget 和 ResponseTableWidget 的核心逻辑相似**
   - 都是渲染表格
   - 都是渲染表格单元格
   - 主要差异是：可编辑 vs 只读

2. **通过 mode 可以清晰区分场景**
   - `mode="edit"` - 可编辑表格
   - `mode="response"` - 只读表格
   - `mode="table-cell"` - 表格单元格
   - `mode="detail"` - 详情展示

3. **代码复用性更好**
   - 共享表格渲染逻辑
   - 共享单元格渲染逻辑
   - 共享格式化逻辑

4. **维护成本更低**
   - 只需维护一个文件
   - 修改逻辑时只需改一处

### 4.2 实现建议

#### 建议1: 使用组合式函数提取共享逻辑

```typescript
// composables/useTableWidget.ts
export function useTableWidget(props: WidgetComponentProps) {
  // 共享的表格数据计算
  const tableData = computed(() => {
    return Array.isArray(props.value?.raw) ? props.value.raw : []
  })
  
  // 共享的字段列表
  const fields = computed(() => {
    return props.field.children || []
  })
  
  // 共享的格式化方法
  const formatValue = (value: FieldValue): string => {
    // ...
  }
  
  return {
    tableData,
    fields,
    formatValue
  }
}
```

#### 建议2: 使用组合式函数分离场景逻辑

```typescript
// composables/useTableEditMode.ts
export function useTableEditMode(props: WidgetComponentProps) {
  // 编辑模式特有的逻辑
  const editingIndex = ref<number | null>(null)
  const handleEdit = (index: number) => { /* ... */ }
  const handleDelete = (index: number) => { /* ... */ }
  
  return {
    editingIndex,
    handleEdit,
    handleDelete
  }
}

// composables/useTableResponseMode.ts
export function useTableResponseMode(props: WidgetComponentProps) {
  // 响应模式特有的逻辑
  const showDetailDrawer = ref(false)
  const handleShowDetail = (row: any) => { /* ... */ }
  
  return {
    showDetailDrawer,
    handleShowDetail
  }
}
```

#### 建议3: 组件内部使用组合式函数

```vue
<!-- TableWidget.vue -->
<script setup lang="ts">
import { useTableWidget } from '@/composables/useTableWidget'
import { useTableEditMode } from '@/composables/useTableEditMode'
import { useTableResponseMode } from '@/composables/useTableResponseMode'

const props = defineProps<WidgetComponentProps>()

// 共享逻辑
const { tableData, fields, formatValue } = useTableWidget(props)

// 场景特定逻辑
const editMode = useTableEditMode(props)
const responseMode = useTableResponseMode(props)
</script>
```

## 五、统一 Props 接口设计

### 5.1 完整的 Props 接口

```typescript
// types/widget.ts
export interface WidgetComponentProps {
  // ========== 必需属性 ==========
  /** 字段配置 */
  field: FieldConfig
  
  /** 字段值 */
  value: FieldValue
  
  /** 场景模式 */
  mode: 'edit' | 'response' | 'table-cell' | 'detail' | 'search'
  
  // ========== 可选属性 ==========
  /** 表单数据管理器（编辑模式需要） */
  formManager?: ReactiveFormDataManager | null
  
  /** FormRenderer 上下文（编辑模式需要） */
  formRenderer?: FormRendererContext | null
  
  /** 嵌套深度（用于防止无限递归） */
  depth?: number
  
  // ========== 场景特定属性 ==========
  /** 搜索类型（用于 search 模式） */
  searchType?: string
  
  /** 行数据（用于 table-cell 模式） */
  rowData?: any
  
  /** 行索引（用于 table-cell 模式） */
  rowIndex?: number
}
```

### 5.2 Props 验证

```typescript
// 在组件中使用 props 验证
const props = withDefaults(defineProps<WidgetComponentProps>(), {
  mode: 'edit',
  depth: 0
})

// 根据 mode 验证必需属性
if (props.mode === 'edit') {
  if (!props.formManager) {
    console.warn('TableWidget: edit mode requires formManager')
  }
  if (!props.formRenderer) {
    console.warn('TableWidget: edit mode requires formRenderer')
  }
}
```

## 六、实施建议

### 6.1 第一步：统一 Props 接口

1. 定义统一的 `WidgetComponentProps` 接口
2. 所有组件都使用这个接口
3. 确保 props 名称和类型一致

### 6.2 第二步：合并组件

1. 先合并 `TableWidget` 和 `ResponseTableWidget`
2. 再合并 `FormWidget` 和 `ResponseFormWidget`
3. 其他组件根据情况决定是否合并

### 6.3 第三步：提取共享逻辑

1. 使用组合式函数提取共享逻辑
2. 使用组合式函数分离场景逻辑
3. 保持组件文件简洁

### 6.4 第四步：测试验证

1. 测试所有场景（edit、response、table-cell、detail、search）
2. 确保功能正常
3. 确保性能正常

## 七、总结

### 7.1 参数统一

✅ **所有组件使用统一的 `WidgetComponentProps` 接口**
- 便于统一管理
- 便于组件互换
- 便于维护

### 7.2 组件合并

✅ **推荐完全合并方案**
- 一个类型一个文件
- 通过 `mode` prop 区分场景
- 使用组合式函数提取共享逻辑

### 7.3 优势

1. **文件数量减少**：从 2 个文件减少到 1 个
2. **代码复用**：共享核心逻辑
3. **维护简单**：只需维护一个文件
4. **参数统一**：所有场景使用相同的 props

### 7.4 注意事项

1. **文件可能较大**：需要合理组织代码
2. **条件判断多**：使用组合式函数分离逻辑
3. **测试要充分**：确保所有场景都正常工作

## 八、示例代码

### 8.1 统一的 TableWidget.vue

```vue
<!-- TableWidget.vue -->
<template>
  <div class="table-widget">
    <!-- 编辑模式 -->
    <template v-if="mode === 'edit'">
      <EditTable
        :field="field"
        :value="value"
        :form-manager="formManager"
        :form-renderer="formRenderer"
        :depth="depth"
      />
    </template>
    
    <!-- 响应模式 -->
    <template v-else-if="mode === 'response'">
      <ResponseTable
        :field="field"
        :value="value"
        :depth="depth"
      />
    </template>
    
    <!-- 表格单元格模式 -->
    <template v-else-if="mode === 'table-cell'">
      <TableCell
        :field="field"
        :value="value"
        :row-data="rowData"
        :row-index="rowIndex"
      />
    </template>
  </div>
</template>

<script setup lang="ts">
import { defineProps } from 'vue'
import type { WidgetComponentProps } from '../types/widget'
import EditTable from './modes/EditTable.vue'
import ResponseTable from './modes/ResponseTable.vue'
import TableCell from './modes/TableCell.vue'

const props = defineProps<WidgetComponentProps>()
</script>
```

### 8.2 使用方式

```vue
<!-- 请求参数（可编辑） -->
<TableWidget
  :field="field"
  :value="formDataStore.getValue(field.code)"
  :form-manager="formManager"
  :form-renderer="formRenderer"
  mode="edit"
/>

<!-- 响应参数（只读） -->
<TableWidget
  :field="field"
  :value="responseDataStore.data?.[field.code]"
  mode="response"
/>

<!-- 表格单元格 -->
<TableWidget
  :field="field"
  :value="row[field.code]"
  :row-data="row"
  :row-index="index"
  mode="table-cell"
/>
```

